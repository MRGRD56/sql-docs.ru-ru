---
description: Использование расширений Visual C++
title: Использование расширений Visual C++ | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: ado
ms.custom: ''
ms.date: 11/08/2018
ms.reviewer: ''
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- Visual C++ [ADO], using VC++ extensions
- ADO, Visual C++
ms.assetid: ff759185-df41-4507-8d12-0921894ffbd9
author: rothja
ms.author: jroth
ms.openlocfilehash: b5acd1b06bbaad8476ac48261ba49a6ca90cb0b5
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "100028659"
---
# <a name="visual-c-extensions"></a>Расширения Visual C++
## <a name="the-iadorecordbinding-interface"></a>Интерфейс Иадорекордбиндинг
 Расширения Microsoft Visual C++ для ADO связывают или связывают поля объекта [Recordset](../../reference/ado-api/recordset-object-ado.md) с переменными C/C++. При изменении текущей строки привязанного **набора записей** все привязанные поля в **наборе записей** копируются в переменные C/C++. При необходимости скопированные данные преобразуются в объявленный тип данных переменной C/C++.

 Метод **биндторекордсет** интерфейса **иадорекордбиндинг** привязывает поля к переменным C/C++. Метод **AddNew** добавляет новую строку к связанному **набору записей**. Метод **Update** заполняет поля в новых строках **набора записей** или обновляет поля в существующих строках значениями переменных C/C++.

 Интерфейс **иадорекордбиндинг** реализуется объектом **Recordset** . Вы не можете самостоятельно кодировать реализацию.

## <a name="binding-entries"></a>Привязка записей
 Расширения Visual C++ для полей схемы ADO объекта [Recordset](../../reference/ado-api/recordset-object-ado.md) в переменные C/C++. Определение сопоставления между полем и переменной называется *записью привязки*. Макросы предоставляют записи привязки для числовых, фиксированной длины и данных переменной длины. Записи привязки и переменные C/C++ объявляются в классе, производном от класса Visual C++ Extensions, **кадорекордбиндинг**. Класс **кадорекордбиндинг** определяется внутренне с помощью макросов записи привязки.

 ADO внутренне сопоставляет параметры в этих макросах с OLE DB структурой **DBBINDING** и создает объект OLE DB **метода доступа** для управления перемещением и преобразованием данных между полями и переменными. OLE DB определяет данные, состоящие из трех частей: *буфера* , в котором хранятся данные; *состояние* , указывающее, было ли поле успешно сохранено в буфере или как переменная должна быть восстановлена в поле; и *длину* данных. (Дополнительные сведения см. в разделе [Получение и Настройка данных (OLE DB)](/previous-versions/windows/desktop/ms713700(v=vs.85))в справочнике по OLE DBному программисту.)

## <a name="header-file"></a>Файл заголовка
 Добавьте следующий файл в приложение, чтобы использовать расширения Visual C++ для ADO:

```cpp
#include <icrsint.h>
```

## <a name="binding-recordset-fields"></a>Привязка полей набора записей

#### <a name="to-bind-recordset-fields-to-cc-variables"></a>Привязка полей набора записей к переменным C/C++

1.  Создайте класс, производный от класса **кадорекордбиндинг** .

2.  Укажите записи привязки и соответствующие переменные C/C++ в производном классе. Закрепление записей привязки между **BEGIN_ADO_BINDING** и **END_ADO_BINDING** макросами. Не завершайте макросы запятыми или точками с запятой. Соответствующие разделители задаются автоматически каждым макросом.

     Укажите одну запись привязки для каждого поля, которое должно быть сопоставлено с переменной C/C++. Используйте соответствующий член из семейства макросов **ADO_FIXED_LENGTH_ENTRY**, **ADO_NUMERIC_ENTRY** или **ADO_VARIABLE_LENGTH_ENTRY** .

3.  В приложении создайте экземпляр класса, производного от **кадорекордбиндинг**. Получите интерфейс **иадорекордбиндинг** из **набора записей**. Затем вызовите метод **биндторекордсет** , чтобы привязать поля **набора записей** к переменным C/C++.

 Дополнительные сведения см. в [примере расширений Visual C++](./visual-c-extensions-example.md).

## <a name="interface-methods"></a>Методы интерфейса
 Интерфейс **иадорекордбиндинг** имеет три метода: **биндторекордсет**, **AddNew** и **Update**. Единственным аргументом для каждого метода является указатель на экземпляр класса, производного от **кадорекордбиндинг**. Поэтому методы **AddNew** и **Update** не могут указывать какие бы то ни было параметры метода ADO намесакес.

## <a name="syntax"></a>Синтаксис
 Метод **биндторекордсет** связывает поля **набора записей** с переменными C/C++.

```cpp
BindToRecordset(CADORecordBinding *binding)
```

 Метод **AddNew** вызывает его тезка, метод ADO [AddNew](../../reference/ado-api/addnew-method-ado.md) для добавления новой строки к **набору записей**.

```cpp
AddNew(CADORecordBinding *binding)
```

 Метод **Update** вызывает его тезка, метод [обновления](../../reference/ado-api/update-method.md) ADO для обновления **набора записей**.

```cpp
Update(CADORecordBinding *binding)
```

## <a name="binding-entry-macros"></a>Привязка макросов для записи
 Макросы записи привязки определяют связь между полем **набора записей** и переменной. Начальный и конечный макросы ограничивают набор записей привязки.

 Для данных с фиксированной длиной, таких как **аддате** или **адбулеан**, предоставляются семейства макросов. числовые данные, такие как **адтининт**, **адинтежер** или **аддаубле**; и данные переменной длины, такие как **адчар**, **адварчар** или **адварбинари**. Все числовые типы, за исключением **адварнумерик**, также являются типами фиксированной длины. Каждое семейство имеет разные наборы параметров, что позволяет исключить сведения о привязке, не представляющие интереса.

 Дополнительные сведения см. в разделе [приложение а. типы данных](/previous-versions/windows/desktop/ms723969(v=vs.85))OLE DB справочнике программиста.

### <a name="begin-binding-entries"></a>Начало записи привязки
 **BEGIN_ADO_BINDING**(*класс*)

### <a name="fixed-length-data"></a>Fixed-Length данных
 **ADO_FIXED_LENGTH_ENTRY**(*порядковый номер, тип данных, буфер, состояние, изменение*)

 **ADO_FIXED_LENGTH_ENTRY2**(*порядковый номер, тип данных, буфер, изменение*)

### <a name="numeric-data"></a>Числовые данные
 **ADO_NUMERIC_ENTRY**(*порядковый номер, тип данных, буфер, точность, масштаб, состояние, изменение*)

 **ADO_NUMERIC_ENTRY2**(*порядковый номер, тип данных, буфер, точность, масштаб, изменение*)

### <a name="variable-length-data"></a>Variable-Length данных
 **ADO_VARIABLE_LENGTH_ENTRY**(*порядковый номер, тип данных, буфер, размер, состояние, длина, изменение*)

 **ADO_VARIABLE_LENGTH_ENTRY2**(*порядковый номер, тип данных, буфер, размер, состояние, изменение*)

 **ADO_VARIABLE_LENGTH_ENTRY3**(*порядковый номер, тип данных, буфер, размер, длина, изменение*)

 **ADO_VARIABLE_LENGTH_ENTRY4**(*порядковый номер, тип данных, буфер, размер, изменение*)

### <a name="end-binding-entries"></a>Конец записей привязки
 **END_ADO_BINDING**()

|Параметр|Описание|
|---------------|-----------------|
|*Класс*|Класс, в котором определены записи привязки и переменные C/C++.|
|*Порядковый номер*|Порядковый номер, считая от одного поля **набора записей** , соответствующего переменной C/C++.|
|*DataType*|Эквивалентный тип данных ADO переменной C/C++ (см. [дататипинум](../../reference/ado-api/datatypeenum.md) для получения списка допустимых типов данных). При необходимости значение поля **набора записей** будет преобразовано в этот тип данных.|
|*Буфер*|Имя переменной C/C++, в которой будет храниться поле **набора записей** .|
|*Size*|Максимальный размер *буфера* в байтах. Если *buffer* будет содержать строку переменной длины, разрешите свободное место для завершающего нуля.|
|*Состояние*|Имя переменной, указывающей, является ли содержимое *буфера* допустимым и было ли преобразование поля в *тип данных* прошло успешно.<br /><br /> Два наиболее важных значения для этой переменной — **адфлдок**, что означает успешность преобразования. и **адфлднулл**, что означает, что значение поля было бы вариантом типа VT_NULL и не просто пустым.<br /><br /> Возможные значения *состояния* перечислены в следующей таблице "значения состояния".|
|*Изменение*|Логический флаг; значение TRUE показывает, что ADO разрешено обновлять соответствующее поле **набора записей** значением, содержащимся в *буфере*.<br /><br /> Присвойте параметру логического *изменения* значение true, чтобы разрешить ADO обновление привязанного поля, и значение false, если необходимо проверить поле, но не изменять его.|
|*Точность*|Количество цифр, которое может быть представлено в числовой переменной.|
|*Масштаб*|Число десятичных разрядов в числовой переменной.|
|*Длина*|Имя 4-байтовой переменной, которая будет содержать фактическую длину данных в *буфере*.|

## <a name="status-values"></a>Индикаторы состояния
 Значение переменной *Status* указывает, успешно ли скопировано поле в переменную.

 При задании данных *состояние* может иметь значение **адфлднулл** , чтобы указать, что поле **набора записей** должно иметь значение null.

|Константа|Значение|Описание|
|--------------|-----------|-----------------|
|**adFldOK**|0|Возвращено значение поля, отличное от NULL.|
|**adFldBadAccessor**|1|Недопустимая привязка.|
|**adFldCantConvertValue**|2|Не удалось преобразовать значение по причинам, отличным от несоответствия знаков или переполнения данных.|
|**adFldNull**|3|При получении поля указывает, что было возвращено значение null.<br /><br /> При установке поля указывает, что поле должно иметь значение **null** , если поле не может кодировать **значение NULL** (например, массив символов или целое число).|
|**адфлдтрункатед**|4|Данные переменной длины или числовые цифры были усечены.|
|**адфлдсигнмисматч**|5|Значение имеет подпись, а тип данных переменной не подписан.|
|**адфлддатаоверфлов**|6|Значение больше, чем может храниться в переменной типа данных.|
|**adFldCantCreate**|7|Неизвестный тип столбца и поле уже открыты.|
|**адфлдунаваилабле**|8|Не удалось определить значение поля. Например, для нового неназначенного поля без значения по умолчанию.|
|**адфлдпермиссиондениед**|9|При обновлении нет разрешения на запись данных.|
|**адфлдинтегритивиолатион**|10|При обновлении значение поля нарушает целостность столбцов.|
|**adFldSchemaViolation**|11|При обновлении значение поля нарушает схему столбца.|
|**адфлдбадстатус**|12|При обновлении недопустимый параметр состояния.|
|**adFldDefault**|13|При обновлении использовалось значение по умолчанию.|

## <a name="see-also"></a>См. также:
 [Заголовок Visual C++ расширений](./visual-c-extensions-header.md) [Visual C++ Extensions](./visual-c-extensions-example.md)