---
description: Использование параметризованных команд
title: Операции с параметризованными командами | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: ado
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- data shaping [ADO], parameterized commands
- parameterized commands [ADO]
ms.assetid: 4fae0d54-83b6-4ead-99cc-bcf532daa121
author: rothja
ms.author: jroth
ms.openlocfilehash: 55eaf3798ee8d14a776da14010b4b6617d0e2723
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "100032656"
---
# <a name="operation-of-parameterized-commands"></a>Использование параметризованных команд
При работе с большим дочерним **набором записей**, особенно по сравнению с размером родительского **набора записей**, но при этом требуется доступ только к нескольким дочерним главам, может оказаться более эффективным использование параметризованной команды.  
  
 *Непараметризованная команда* извлекает как все родительские, так и дочерние **наборы записей**, добавляет столбец раздела к родительскому элементу, а затем присваивает ссылку на соответствующую дочернюю главу для каждой родительской строки.  
  
 *Параметризованная команда* извлекает весь родительский **набор записей**, но извлекает только **набор записей** раздела при обращении к столбцу глав. Это различие в стратегии извлечения может дать значительные преимущества для повышения производительности.  
  
 Например, можно указать следующее:  
  
```  
SHAPE {SELECT * FROM customer}   
   APPEND ({SELECT * FROM orders WHERE cust_id = ?}   
   RELATE cust_id TO PARAMETER 0)  
```  
  
 Родительская и дочерняя таблицы имеют общие имена столбцов, *cust_id*. *Дочерняя команда* имеет заполнитель "?", к которому относится предложение Relate (то есть "... ПАРАМЕТР 0 ").  
  
> [!NOTE]
>  Предложение PARAMETER относится только к синтаксису команды Shape. Он не связан ни с объектом [параметров](../../reference/ado-api/parameter-object.md) ADO, ни с коллекцией [Parameters](../../reference/ado-api/parameters-collection-ado.md) .  
  
 При выполнении команды параметризованной формы происходит следующее:  
  
1.  Выполняется *родительская команда* , которая возвращает родительский **набор записей** из таблицы Customers.  
  
2.  Столбец раздела добавляется к родительскому **набору записей**.  
  
3.  При доступе к столбцу раздела в родительской строке выполняется *дочерняя команда* с использованием значения Customer.cust_id в качестве значения параметра.  
  
4.  Все строки в наборе строк поставщика данных, созданные на шаге 3, используются для заполнения дочернего **набора записей**. В этом примере это все строки в таблице Orders, в которых cust_id равно значению customer.cust_id. По умолчанию дочерние **наборы записей** кэшируются на клиенте до тех пор, пока не будут освобождены все ссылки на родительский **набор записей** . Чтобы изменить это поведение, задайте для **дочерних строк кэша** [динамических свойств](../../reference/ado-api/ado-dynamic-property-index.md) **набора записей** **значение false**.  
  
5.  Ссылка на полученные дочерние строки (то есть главу дочернего **набора записей**) помещается в столбец Chapter текущей строки родительского **набора записей**.  
  
6.  Шаги 3-5 повторяются при обращении к столбцу глав другой строки.  
  
 По умолчанию динамическое свойство **кэша дочерних строк** имеет значение **true** . Поведение кэширования зависит от значений параметров запроса. В запросе с одним параметром, дочерний **набор записей** для заданного значения параметра будет кэширован между запросами для дочернего элемента с этим значением. Следующий код демонстрирует это:  
  
```  
SCmd = "SHAPE {select * from customer} " & _  
         "APPEND({select * from orders where cust_id = ?} " & _  
         "RELATE cust_id TO PARAMETER 0) AS chpCustOrder"  
Rst1.Open sCmd, Cnn1  
Set RstChild = Rst1("chpCustOrder").Value  
Rst1.MoveNext      ' Next cust_id passed to Param 0, & new rs fetched   
                   ' into RstChild.  
Rst1.MovePrevious  ' RstChild now holds cached rs, saving round trip.  
```  
  
 В запросе с двумя или более параметрами кэшированный дочерний элемент используется только в том случае, если все значения параметров соответствуют кэшированным значениям.  
  
## <a name="parameterized-commands-and-complex-parent-child-relations"></a>Параметризованные команды и сложные родительские подчиненные отношения  
 Кроме использования параметризованных команд для повышения производительности иерархии типов эквивалентного объединения, параметризованные команды можно использовать для поддержки более сложных связей типа «родители-потомки». Например, рассмотрим небольшую базу данных отличаются с двумя таблицами: одна состоит из групп (team_id, team_name) и других игр (Дата, home_team, visiting_team).  
  
 Используя непараметризованную иерархию, невозможно связать таблицы Teams и Games таким образом, чтобы дочерний **набор записей** для каждой группы содержал полное расписание. Вы можете создавать главы, которые содержат начальное расписание или расписание поездок, но не оба. Это обусловлено тем, что предложение СВЯЗЫВАНИЯ ограничивается связями типа «родители-потомки» в форме (PC1 = CC1) и (PC2 = PC2). Таким образом, если ваша команда включает "связь team_id с home_team, team_id visiting_team", вы получите только игры, в которых Рабочая группа воспроизводила себя. Требуется следующее: "(team_id = home_team) или (team_id = visiting_team)", но поставщик фигур не поддерживает предложение "или".  
  
 Чтобы получить нужный результат, можно использовать параметризованную команду. Пример:  
  
```  
SHAPE {SELECT * FROM teams}   
APPEND ({SELECT * FROM games WHERE home_team = ? OR visiting_team = ?}   
        RELATE team_id TO PARAMETER 0,   
               team_id TO PARAMETER 1)   
```  
  
 В этом примере для получения необходимого результата применяется более гибкое предложение SQL WHERE.  
  
> [!NOTE]
>  При использовании предложений WHERE параметры не могут использовать типы данных SQL для Text, ntext и Image, что приведет к ошибке, которая содержит следующее описание: `Invalid operator for data type` .  
  
## <a name="see-also"></a>См. также:  
 [Пример формирования данных](./data-shaping-example.md)   
 [Грамматика формальной фигуры](./formal-shape-grammar.md)   
 [Общие сведения о командах формирования данных](./shape-commands-in-general.md)