---
description: Работа с наборами записей
title: Работа с наборами записей | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: ado
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- Recordset object [ADO]
ms.assetid: bdf9a56a-de4a-44de-9111-2f11ab7b16ea
author: rothja
ms.author: jroth
ms.openlocfilehash: 4e64608adc461534a30630a6b8b8d29d0478544a
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "100032256"
---
# <a name="working-with-recordsets"></a>Работа с наборами записей
Объект **Recordset** содержит встроенные функции, которые позволяют изменить порядок данных в результирующем наборе, чтобы найти определенную запись на основе заданных условий, а также оптимизировать эти операции поиска с помощью индексов. Доступность этих функций зависит от поставщика и в некоторых случаях, например от свойства [index](../../../ado/reference/ado-api/index-property.md) — структуры самого источника данных.  
  
## <a name="arranging-data"></a>Упорядочение данных  
 Часто наиболее эффективный способ упорядочения данных в **наборе записей** заключается в указании предложения ORDER BY в команде SQL, используемой для возврата результатов. Однако может потребоваться изменить порядок данных в уже созданном **наборе записей** . С помощью свойства **Sort** можно установить порядок, в котором будут перемещаться строки **набора записей** . Кроме того, свойство **Filter** определяет, к каким строкам можно получить доступ при просмотре строк.  
  
 Свойство **Sort** задает или возвращает **строковое** значение, указывающее имена полей в **наборе записей** , по которому выполняется сортировка. Каждое имя отделяется запятой и при необходимости за ним следует пробел и ключевое слово **ASC** (которое сортирует поле в возрастающем порядке) или **DESC** (Сортирует поле в убывающем порядке). По умолчанию, если ключевое слово не указано, поле сортируется в возрастающем порядке.  
  
 Операция сортировки эффективна, поскольку данные физически не переупорядочиваются, но к ним обращаются в порядке, указанном индексом.  
  
 Для свойства **Sort** необходимо, чтобы свойство [CursorLocation](../../../ado/reference/ado-api/cursorlocation-property-ado.md) было установлено в значение **адусеклиент**. Для каждого поля, указанного в свойстве **Sort** , будет создан временный индекс, если индекс еще не существует.  
  
 Если задать для свойства **Sort** пустую строку, строки будут сброшены в исходный порядок и удалены временные индексы. Существующие индексы не будут удалены.  
  
 Предположим, что **набор записей** содержит три поля с именами *FirstName*, *middleInitial* и *LastName*. Задайте для свойства **Sort** строку " `lastName DESC, firstName ASC` ", которая будет упорядочивать **набор записей** по фамилии в убывающем порядке, а затем по имени по возрастанию. Инициал отчества игнорируется.  
  
 Ни одно поле, на которое ссылается строка условий сортировки, не может называться "ASC" или "DESC", так как эти имена конфликтуют с ключевыми словами **ASC** и **DESC**. Присвойте полю с конфликтующим именем псевдоним, используя ключевое слово **as** в запросе, возвращающем **набор записей**.  
  
 Дополнительные сведения о фильтрации **набора записей** см. в разделе «Фильтрация результатов» далее в этом разделе.  
  
## <a name="finding-a-specific-record"></a>Поиск конкретной записи  
 ADO предоставляет методы [поиска](../../../ado/reference/ado-api/find-method-ado.md) и [поиска для](../../../ado/reference/ado-api/seek-method.md) поиска конкретной записи в **наборе записей**. Метод **Find** поддерживается множеством поставщиков, но ограничен одним критерием поиска. Метод **Seek** поддерживает поиск по нескольким критериям, но не поддерживается многими поставщиками.  
  
 Индексы в полях могут значительно повысить производительность метода **Find** , а также свойства **сортировки** и **фильтрации** объекта **Recordset** . Для объекта **поля** можно создать внутренний индекс, задав его динамическое свойство [optimize](../../../ado/reference/ado-api/optimize-property-dynamic-ado.md) . Это динамическое свойство добавляется в коллекцию **Properties** объекта **field** , если для свойства [CursorLocation](../../../ado/reference/ado-api/cursorlocation-property-ado.md) задано значение **адусеклиент**. Помните, что этот индекс является внутренним по отношению к ADO. Вы не можете получить доступ к нему или использовать его для других целей. Кроме того, этот индекс отличается от свойства [index](../../../ado/reference/ado-api/index-property.md) объекта **Recordset** .  
  
 Метод **Find** быстро находит значение в столбце (поле) **набора записей**. Часто можно увеличить скорость метода **Find** в столбце с помощью свойства **optimize** , чтобы создать на нем индекс.  
  
 Метод **Find** ограничивает поиск содержимым одного поля. Метод **Seek** требует наличия индекса и также имеет и другие ограничения. Если необходимо выполнить поиск по нескольким полям, которые не являются основанием индекса, или если поставщик не поддерживает индексы, результаты можно ограничить с помощью свойства **Filter** объекта **Recordset** .  
  
### <a name="find"></a>Поиск  
 Метод **Find** выполняет поиск строки, удовлетворяющей заданному условию, в **наборе записей** . При необходимости можно указать направление поиска, начальную строку и смещение от начальной строки. Если критерий достигнут, текущая строка устанавливается на найденной записи; в противном случае в качестве расположения задается конец (или начало) **набора записей** в зависимости от направления поиска.  
  
 Для этого критерия можно указать только одно имя столбца. Иными словами, этот метод не поддерживает поиск по столбцам.  
  
 Оператор сравнения для критерия может иметь значение " **>** " (больше), "* * \<**" (less than), "=" (equal), "> =" (больше или равно), "<=" (меньше или равно), "<>" (не равно) или "Like" (сопоставление шаблонов).  
  
 Значение критерия может быть строкой, числом с плавающей запятой или датой. Строковые значения разделяются одинарными кавычками или символами "#" (знак решетки) (например, "State =" WA "или" State = #WA # "). Значения даты разделяются знаками "#" (знак решетки) (например, "start_date > #7/22/97 #").  
  
 Если оператор сравнения имеет значение LIKE, строковый параметр может содержать звездочку (*) для поиска одного или нескольких вхождений любого символа или подстроки. Например, "состояние Like \* " "соответствует Майн и Массачусетс. Для поиска подстроки, содержащейся в значениях, можно также использовать начальную и конечную звездочки. Например, "состояние Like" \* соответствует " \* Аляска, как Арканзас так и Массачусетс.  
  
 Звездочки можно использовать только в конце строки критериев или вместе в начале и в конце строки критерия, как показано выше. Нельзя использовать звездочку в качестве начального подстановочного знака ("* str") или встроенного подстановочного знака ( \* r). Это приведет к ошибке.  
  
### <a name="seek-and-index"></a>Поиск и индексирование  
 Используйте метод **Seek** вместе со свойством **index** , если базовый поставщик поддерживает индексы в объекте **Recordset** . Используйте метод [поддерживает](../../../ado/reference/ado-api/supports-method.md)**(адсик)** , чтобы определить, поддерживает ли базовый поставщик **Поиск**, и **поддерживает метод (адиндекс)** , чтобы определить, поддерживает ли поставщик индексы. (Например, [поставщик OLE DB для Microsoft Jet](../../../ado/guide/appendixes/microsoft-ole-db-provider-for-microsoft-jet.md) поддерживает **Поиск** и **индексирование**.)  
  
 Если **Seek** не находит нужную строку, ошибка не возникает и строка располагается в конце **набора записей**. Перед выполнением этого метода задайте для свойства **index** нужный индекс.  
  
 Этот метод поддерживается только с курсорами на стороне сервера. Поиск не поддерживается, если значение свойства [CursorLocation](../../../ado/reference/ado-api/cursorlocation-property-ado.md) объекта **Recordset** равно **адусеклиент**.  
  
 Этот метод можно использовать только в том случае, если объект **Recordset** открыт с [коммандтипинум](../../../ado/reference/ado-api/commandtypeenum.md) значением **адкмдтабледирект**.  
  
## <a name="filtering-the-results"></a>Фильтрация результатов  
 Метод **Find** ограничивает поиск содержимым одного поля. Метод **Seek** требует наличия индекса и также имеет и другие ограничения. Если необходимо выполнить поиск по нескольким полям, которые не являются основанием индекса, или если поставщик не поддерживает индексы, результаты можно ограничить с помощью свойства **Filter** объекта **Recordset** .  
  
 Используйте свойство **Filter** для выборочного отображения записей в объекте **набора записей** . Отфильтрованный **набор записей** становится текущим курсором. Это означает, что записи, не удовлетворяющие условиям **фильтра** , недоступны в **наборе записей** до тех пор, пока **Фильтр** не будет удален. Затрагиваются другие свойства, возвращающие значения, основанные на текущем курсоре, такие как **примеры AbsolutePosition**, **примеры absolutepage**, **RecordCount** и **PageCount**. Это связано с тем, что при установке свойства **фильтра** в конкретное значение текущая запись перемещается в первую запись, удовлетворяющую новому значению.  
  
 Свойство **Filter** принимает аргумент типа Variant. Это значение представляет один из трех методов использования свойства **Filter** : строку условий, константу **филтерграупенум** или массив закладок. Дополнительные сведения см. в разделах фильтрация с помощью строки критериев, фильтрация с помощью константы и фильтрация с помощью закладок далее в этом разделе.  
  
> [!NOTE]
>  Если вы знакомы с данными, которые необходимо выбрать, обычно более эффективно открывать **набор записей** с помощью инструкции SQL, которая эффективно Фильтрует результирующий набор, вместо того чтобы полагаться на свойство **Filter** .  
  
 Чтобы удалить фильтр из **набора записей**, используйте константу **адфилтерноне** . Установка свойства **фильтра** в виде строки нулевой длины ("") оказывает тот же результат, что и при использовании константы **адфилтерноне** .  
  
### <a name="filtering-with-a-criteria-string"></a>Фильтрация с помощью строки условий  
 Строка критериев состоит из предложений в форме *значения оператора FieldName* (например, `"LastName = 'Smith'"` ). Составные предложения можно создавать путем сцепления отдельных предложений с **and** (например, `"LastName = 'Smith' AND FirstName = 'John'"` ) и **or** (например, `"LastName = 'Smith' OR LastName = 'Jones'"` ). Используйте следующие рекомендации для строк критериев:  
  
-   *Fieldname* должно быть допустимым именем поля из **набора записей**. Если имя поля содержит пробелы, имя необходимо заключить в квадратные скобки.  
  
-   *Оператор* должен быть одним из следующих: **\<**, **>** , **\<=**, **>=** , **<>** , **=** или **Like**.  
  
-   *Значение* — это значение, с помощью которого будут сравниваться значения полей (например,,, `'Smith'` `#8/24/95#` `12.345` или `$50.00` ). Используйте одинарные кавычки (') со строками и знаками фунта ( `#` ) с датами. Для чисел можно использовать десятичные разделители, знаки доллара и экспоненциальное представление. Если *оператор* имеет значение **Like**, то *value* может использовать символы-шаблоны. Только звездочка ( \* ) и знак процента (%) подстановочные знаки допускаются и должны быть последними символами в строке. *Значение* не может быть равно null.  
  
    > [!NOTE]
    >  Чтобы включить одинарные кавычки (') в *значении* фильтра, используйте две одинарные кавычки для представления одного. Например, для фильтрации по *O'Malley)* строка критериев должна иметь значение `"col1 = 'O''Malley'"` . Чтобы включить одинарные кавычки как в начале, так и в конце значения фильтра, заключите строку в знаки фунта (#). Например, для фильтрации по *"1"* строка критериев должна иметь значение `"col1 = #'1'#"` .  
  
 Приоритет между **and** и **or** не существует. Предложения могут быть сгруппированы в круглые скобки. Однако нельзя сгруппировать предложения, Соединенные **или** , а затем объединить группу с другим предложением с оператором AND, как показано ниже.  
  
```  
(LastName = 'Smith' OR LastName = 'Jones') AND FirstName = 'John'  
```  
  
 Вместо этого следует создать этот фильтр следующим образом.  
  
```  
(LastName = 'Smith' AND FirstName = 'John') OR (LastName = 'Jones' AND FirstName = 'John')  
```  
  
 В предложении **Like** можно использовать подстановочный знак в начале и конце шаблона (например, `LastName Like '*mit*'` ) или только в конце шаблона (например, `LastName Like 'Smit*'` ).  
  
### <a name="filtering-with-a-constant"></a>Фильтрация с помощью константы  
 Для фильтрации **наборов записей** доступны следующие константы.  
  
|Константа|Описание|  
|--------------|-----------------|  
|**adFilterAffectedRecords**|Фильтры для просмотра только тех записей, на которые повлияли последние операции **удаления**, повторной **синхронизации**, **UpdateBatch** или **CancelBatch** .|  
|**адфилтерконфликтингрекордс**|Фильтры для просмотра записей, которые не прошли Последнее обновление пакета.|  
|**adFilterFetchedRecords**|Фильтры для просмотра записей в текущем кэше, то есть результатов последнего вызова для получения записей из базы данных.|  
|**адфилтерноне**|Удаляет текущий фильтр и восстанавливает все записи для просмотра.|  
|**адфилтерпендингрекордс**|Фильтры для просмотра только тех записей, которые были изменены, но еще не отправлены на сервер. Применяется только для режима пакетного обновления.|  
  
 Константы фильтра упрощают устранение конфликтов отдельных записей в режиме пакетного обновления, позволяя просматривать, например, только те записи, которые были затронуты во время последнего вызова метода **UpdateBatch** , как показано в следующем примере.  
  
 `Attribute VB_Name = "modExaminingData"`  
  
### <a name="filtering-with-bookmarks"></a>Фильтрация с помощью закладок  
 Наконец, можно передать массив вариантов закладок в свойство **Filter** . Результирующий курсор будет содержать только те записи, закладка которых была передана свойству. В следующем примере кода создается массив закладок из записей в **наборе записей** , имеющих "B" в поле *ProductName* . Затем массив передается в свойство **Filter** и отображает сведения о результирующем отфильтрованном **наборе записей**.  
  
```  
'BeginFilterBkmk  
Dim vBkmkArray() As Variant  
Dim i As Integer  
  
'Recordset created using "SELECT * FROM Products" as command.  
'So, we will check to see if ProductName has a capital B, and  
'if so, add to the array.  
i = 0  
Do While Not objRs.EOF  
    If InStr(1, objRs("ProductName"), "B") Then  
        ReDim Preserve vBkmkArray(i)  
        vBkmkArray(i) = objRs.Bookmark  
        i = i + 1  
        Debug.Print objRs("ProductName")  
    End If  
    objRs.MoveNext  
Loop  
  
'Filter using the array of bookmarks.  
objRs.Filter = vBkmkArray  
  
objRs.MoveFirst  
Do While Not objRs.EOF  
    Debug.Print objRs("ProductName")  
    objRs.MoveNext  
Loop  
'EndFilterBkmk  
```  
  
## <a name="creating-a-clone-of-a-recordset"></a>Создание клона набора записей  
 Используйте метод **clone** для создания нескольких повторяющихся объектов **набора записей** , особенно если требуется поддерживать более одной текущей записи в заданном наборе записей. Использование метода **clone** более эффективно, чем создание и открытие нового объекта **набора записей** с тем же определением, что и у исходного.  
  
 Текущей записи только что созданного клона изначально присваивается первая запись. Указатель текущей записи в клонированном **наборе записей** не синхронизирован с исходным или наоборот. Можно перемещаться по отдельности в каждом **наборе записей**.  
  
 Изменения, вносимые в один объект **набора записей** , отображаются во всех его клонах независимо от типа курсора. Однако после выполнения инструкции [Requery](../../../ado/reference/ado-api/requery-method.md) для исходного **набора записей** клоны больше не будут синхронизироваться с исходным.  
  
 Закрытие исходного **набора записей** не приводит к закрытию его копий, а копирование не приводит к закрытию оригинала и других копий.  
  
 Объект **набора записей** можно клонировать, только если он поддерживает закладки. Значения закладок взаимозаменяемы; то есть ссылка на закладку из одного объекта **Recordset** ссылается на одну и ту же запись в любом из его клонов.
