---
title: Пользовательские функции R с использованием rxExec
description: Узнайте, как с помощью смоделированных данных демонстрируется выполнение пользовательской функции R на удаленном сервере.
ms.prod: sql
ms.technology: machine-learning-services
ms.date: 11/27/2018
ms.topic: tutorial
author: dphansen
ms.author: davidph
ms.custom: seo-lt-2019
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: b8f03c64dc86e6d23113f3a35ae669f216b66489
ms.sourcegitcommit: cfa04a73b26312bf18d8f6296891679166e2754d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2020
ms.locfileid: "92195156"
---
# <a name="run-custom-r-functions-on-sql-server-using-rxexec-sql-server-and-revoscaler-tutorial"></a>Выполнение пользовательских функций R в SQL Server с помощью rxExec (учебник по SQL Server и RevoScaleR)
[!INCLUDE [SQL Server 2016 and later](../../includes/applies-to-version/sqlserver2016.md)]

Эта часть 14 входит в состав [серии учебников по RevoScaleR](deepdive-data-science-deep-dive-using-the-revoscaler-packages.md), посвященной использованию [функций RevoScaleR](/machine-learning-server/r-reference/revoscaler/revoscaler) в SQL Server.

В этом учебнике с помощью смоделированных данных демонстрируется выполнение пользовательской функции R на удаленном сервере.

Пользовательские функции R можно выполнять в контексте SQL Server путем передачи через [rxExec](/machine-learning-server/r-reference/revoscaler/rxexec) при условии, что все библиотеки, необходимые для скрипта, также установлены на сервере и совместимы с базовым дистрибутивом R. 

Функция **rxExec** в **RevoScaleR** обеспечивает механизм для выполнения любого требуемого скрипта R. Кроме того, функция **rxExec** позволяет явно распределять нагрузку по нескольким ядрам на одном сервере, повышая масштабируемость скриптов, которые в противном случае были бы ограничены лимитами ресурсов собственной подсистемы R.

## <a name="prerequisites"></a>Предварительные требования

+ [Службы машинного обучения SQL Server (с R)](../install/sql-machine-learning-services-windows-install.md) или [Службы SQL Server 2016 R (в базе данных)](../install/sql-r-services-windows-install.md)
  
+ [Разрешения для базы данных](../security/user-permission.md) и имя пользователя для входа в базу данных SQL Server

+ [Рабочая станция разработки с библиотеками RevoScaleR](../r/set-up-a-data-science-client.md)

Дистрибутив R на клиентской рабочей станции предоставляет встроенное средство **Rgui**, которое можно использовать для выполнения скрипта R в этом учебнике. Вы также можете использовать интегрированную среду разработки, например RStudio или Инструменты R для Visual Studio.

## <a name="create-the-remote-compute-context"></a>Создание удаленного контекста вычисления

Выполните приведенные ниже команды R на клиентской рабочей станции. Например, при использовании **Rgui** выполните их из следующей папки: C:\Program Files\Microsoft\R Client\R_SERVER\bin\x64\.

1. Укажите строку подключения к экземпляру SQL Server, в котором будут производиться вычисления. На этом сервере должна быть настроена интеграция со средой R. В этом упражнении имя базы данных не используется, но в строке подключения оно требуется. Если у вас есть тестовая база данных или образец базы данных, можно использовать их.

    **Использование имени для входа SQL**

    ```R
    sqlConnString <- "Driver=SQL Server;Server=<SQL-Server-instance-name>; Database=<database-name>;Uid=<SQL-user-name>;Pwd=<password>"
    ```

    **Использование проверки подлинности Windows**

    ```R
    sqlConnString <- "Driver=SQL Server;Server=<SQL-Server-instance-name>;Database=<database-name>;Trusted_Connection=True"
    ```

2. Создайте удаленный контекст вычисления для экземпляра SQL Server, указанного в строке подключения.

    ```R
    sqlCompute <- RxInSqlServer(connectionString = sqlConnString)
    ```

3. Активируйте контекст вычисления, а затем получите определение объекта в качестве подтверждения. Вы должны увидеть свойства объекта контекста вычисления.

    ```R
    rxSetComputeContext(sqlCompute)
    rxGetComputeContext()
    ```

## <a name="create-the-custom-function"></a>Создание пользовательской функции

В этом упражнении вы создадите пользовательскую функцию R, которая имитирует популярную азартную игру, заключающуюся в бросании двух кубиков. Выигрыш или проигрыш определяется по указанным ниже правилам.

+ Если при первом броске выпала сумма очков 7 или 11, вы выигрываете.
+ Если выпала сумма очков 2, 3 или 12, вы проигрываете.
+ Если выпала сумма 4, 5, 6, 8, 9 или 10, это число становится "пойнтом", и нужно продолжать бросать кости, пока снова не выпадет "пойнт" (выигрыш) или сумма 7 (проигрыш).

Эту игру легко смоделировать в R, создав пользовательскую функцию, которую затем можно выполнять много раз.

1.  Создайте пользовательскую функцию, используя следующий код R:
  
    ```R
    rollDice <- function()
    {
        result <- NULL
        point <- NULL
        count <- 1
            while (is.null(result))
            {
                roll <- sum(sample(6, 2, replace=TRUE))
  
                if (is.null(point))
                { point <- roll }
                if (count == 1 && (roll == 7 || roll == 11))
                {  result <- "Win" }
                else if (count == 1 && (roll == 2 || roll == 3 || roll == 12))
                { result <- "Loss" }
                else if (count > 1 && roll == 7 )
                { result <- "Loss" }
                else if (count > 1 && point == roll)
                { result <- "Win" }
                else { count <- count + 1 }
            }
            result
    }
    ```
  
2.  Чтобы смоделировать одну игру в кости, выполните эту функцию.
  
    ```R
    rollDice()
    ```
  
    Выиграли вы или проиграли?
  
Теперь, когда у вас есть работающий скрипт, давайте посмотрим, как можно выполнять функцию многократно с помощью **rxExec**, чтобы создать моделирование, позволяющее определить вероятность выигрыша.

## <a name="pass-rolldice-in-rxexec"></a>Передача rollDice() в rxExec

Чтобы выполнить произвольную функцию в контексте удаленного сервера SQL Server, вызовите функцию **rxExec**.

1. Вызовите эту пользовательскую функцию в качестве аргумента **rxExec** вместе с другими параметрами, которые изменяют симуляцию.
  
    ```R
    sqlServerExec <- rxExec(rollDice, timesToRun=20, RNGseed="auto")
    length(sqlServerExec)
    ```
  
    + Аргумент *timesToRun* позволяет указать, сколько раз должна выполняться функция.  В этом случае кости бросаются 20 раз.
  
    + Аргументы *RNGseed* и *RNGkind* позволяют управлять генерацией случайных чисел. Если параметр *RNGseed* имеет значение **auto**, в каждом рабочем процессе инициализируется параллельный поток случайных чисел.
  
2. Функция **rxExec** создает список с одним элементом для каждого запуска, однако, пока список не заполнится, практически ничего происходить не будет. Когда все итерации будут завершены, строка, начинающаяся с **length**, вернет значение.
  
    После этого можно перейти к следующему шагу, чтобы получить сводку по выигрышам и проигрышам.
  
3. Преобразуйте полученный список в вектор с помощью функции R **unlist** и обобщите результаты с помощью функции **table** .
  
    ```R
    table(unlist(sqlServerExec))
    ```
  
    Результаты должны выглядеть примерно так:
  
     *Проигрыш Выигрыш* *12 8*

## <a name="conclusion"></a>Заключение

Хотя это упрощенное упражнение, оно демонстрирует важный механизм интеграции произвольных функций R в скрипт R, выполняемый на сервере SQL Server. Обобщим основные моменты, делающие этот механизм возможным.

+ На сервере SQL Server должна быть настроена служба машинного обучения и интеграция со средой R: [Службы машинного обучения SQL Server](../install/sql-machine-learning-services-windows-install.md) с компонентом R или [SQL Server 2016 R Services (в базе данных)](../install/sql-r-services-windows-install.md).

+ На сервере SQL Server должны быть установлены библиотеки с открытым кодом или сторонние библиотеки, которые используются в функции, включая зависимости. Дополнительные сведения см. в статье [Установка новых пакетов R](../package-management/install-additional-r-packages-on-sql-server.md).

+ При перемещении скрипта из среды разработки в защищенную рабочую среду можно столкнуться с ограничениями, накладываемыми брандмауэром и конфигурацией сети. Тщательно протестируйте скрипт, чтобы убедиться в том, что он может выполняться требуемым образом.

## <a name="next-steps"></a>Дальнейшие действия

Более сложный пример использования **rxExec** см. в следующей статье: [Крупномодульный параллелизм с использованием foreach и rxExec](https://blog.revolutionanalytics.com/2015/04/coarse-grain-parallelism-with-foreach-and-rxexec.html)