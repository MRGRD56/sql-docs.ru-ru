---
title: Преобразование кода R для SQL
description: Перенос кода R в хранимую процедуру SQL Server для развертывания решения и доступа к реляционным данным в SQL Server.
ms.prod: sql
ms.technology: machine-learning-services
ms.date: 10/06/2020
ms.topic: how-to
author: dphansen
ms.author: davidph
ms.custom: seo-lt-2019
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=azuresqldb-mi-current'
ms.openlocfilehash: 56a52c3245d364bd1b111dbe5fedbda9da48e493
ms.sourcegitcommit: 1a544cf4dd2720b124c3697d1e62ae7741db757c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2020
ms.locfileid: "97470955"
---
# <a name="convert-r-code-for-execution-in-sql-server-in-database-instances"></a>Преобразование кода R для выполнения в экземплярах SQL Server (в базе данных)
[!INCLUDE [SQL Server 2016 SQL MI](../../includes/applies-to-version/sqlserver2016-asdbmi.md)]

В этой статье приводятся общие рекомендации по изменению кода R для работы в SQL Server. 

При переносе кода R из R Studio или другой среды в SQL Server дополнительные изменения как правило не требуется. Например, это верно для простого кода, такого как функция, которая принимает и возвращает некоторые значения. Кроме того, удобно переносить пакеты **RevoScaleR** или **MicrosoftML**, которые поддерживают разные контексты выполнения с минимальными изменениями.

Тем не менее, в следующих случаях может потребоваться значительная переработка кода:

+ Вы используете библиотеки R, которые осуществляют доступ к сети или не могут быть установлены в SQL Server.
+ В коде выполняются отдельные вызовы источников данных, расположенных вне среды SQL Server, таких как листы Excel, файлы в общих папках или другие базы данных. 
+ Вам требуется выполнить код в параметре *\@script* процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md) и также параметризовать хранимую процедуру.
+ Исходное решение включает несколько шагов, которые в рабочей среде эффективнее выполнять по отдельности. В качестве примера можно сравнить подготовку данных или формирование признаков с обучением модели, оценкой и созданием отчетов.
+ Вы хотите оптимизировать производительность, изменяя библиотеки, используя параллельное выполнение или передавая нагрузки некоторых процессов в SQL Server. 

## <a name="step-1-plan-requirements-and-resources"></a>Шаг 1. Планирование ресурсов и требований

### <a name="packages"></a>Пакеты

+ Определите необходимые пакеты и убедитесь, что они работают в SQL Server.
 
+ Заранее установите пакеты в заданную по умолчанию библиотеку пакетов, которую используют службы машинного обучения. Пользовательские библиотеки не поддерживаются.

### <a name="data-sources"></a>Источники данных

+ Если вы планируете внедрить код R в процедуру [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), определите первичный и вторичный источники данных. 

  + В качестве **первичных** источников выступают большие наборы данных, например обучающие данные модели или входные данные для прогнозирования. Спланируйте сопоставление самого большого набора данных с входным параметром процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md).

  + В качестве **вторичных** источников обычно используются наборы меньшего размера, например списки факторов или дополнительные переменные группирования. 
  
  На данный момент процедура sp_execute_external_script поддерживает только один набор данных в качестве входного параметра. При необходимости вы можете добавить несколько скалярных или двоичных входов.

  Вызовы хранимой процедуры, которым предшествует EXECUTE, нельзя использовать в качестве входных данных процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). При этом вы можете использовать запросы, представления и любые другие допустимые инструкции SELECT.

+ Определите нужные выходные данные. Если код R выполняется с помощью хранимой процедуры sp_execute_external_script, она может возвращать только один кадр данных. Тем не менее, вы можете определить несколько скалярных выходов, таких как графики и модели в двоичном формате, а также другие скалярные значения, получаемые на основе кода R или параметров SQL.

### <a name="data-types"></a>Типы данных

+ Составьте контрольный список возможных проблем с типами данных.

  Службы машинного обучения SQL Server поддерживают все типы данных R. Тем не менее, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживает гораздо большее число типов данных, чем R. Таким образом, при отправке данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в R и в обратном направлении выполняются определенные неявные преобразования типов данных. Кроме того, может потребоваться явным образом привести или преобразовать некоторые данные. 

  Значения NULL поддерживаются. Тем не менее, R использует структуру данных `na` для представления отсутствующих значений, подобных значениям NULL.

+ Рекомендуется убрать зависимости от данных, которые нельзя использовать в R. Например, типы данных rowid и GUID из SQL Server не поддерживаются в R и приводят к возникновению ошибок.

  Дополнительные сведения см. в разделе [Библиотеки R и типы данных](../r/r-libraries-and-data-types.md).

## <a name="step-2-convert-or-repackage-code"></a>Шаг 2. Преобразование или переупаковка кода

Объем необходимых изменений в коде зависит от того, планируете ли вы отправлять код R с удаленного клиента для выполнения в контексте вычислений SQL Server или хотите развернуть код в составе хранимой процедуры, что позволяет повысить производительность и безопасность. Упаковка кода в хранимую процедуру сопряжена с некоторыми дополнительными ограничениями. 

+ Чтобы избежать перемещения данных, по возможности определяйте в качестве первичных входных данных SQL-запрос.

+ При выполнении кода R в хранимой процедуры вы передаете несколько **скалярных** входов. Для всех параметров, которые требуется использовать в выходных данных, добавьте ключевое слово **OUTPUT**. 

  Например, следующий скалярный вход `@model_name` содержит имя модели, которое также включается в выходные данные в отдельном столбце:

  ```sql
  EXEC sp_execute_external_script @model_name="DefaultModel" OUTPUT, @language=N'R', @script=N'R code here'
  ```

+ Все переменные, передаваемые в качестве параметров хранимой процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), должны быть сопоставлены с переменными в коде R. По умолчанию переменные сопоставляются по имени.

  Все столбцы во входном наборе данных также должны быть сопоставлены с переменными в скрипте R.  Предположим, что скрипт R содержит следующую формулу:

  ```R
  formula <- ArrDelay ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
  ```
  
  Если входной набор данных не содержит столбцы с именами ArrDelay, CRSDepTime, DayOfWeek, CRSDepHour и DayOfWeek, возникает ошибка.

+ В некоторых случаях необходимо заранее определить схему выходных данных для результатов.

  Например, чтобы вставить данные в таблицу, необходимо использовать инструкцию **WITH RESULT SET** для определения схемы.

  Схема выходных данных также обязательна, если скрипт R использует аргумент `@parallel=1`. Дело в том, что SQL Server может распределить запрос между несколькими параллельными процессами и собирать результаты в конце. Поэтому схему вывода необходимо подготовить до того, как могут быть созданы параллельные процессы.
  
  В других случаях схему результатов можно опустить, указав параметр **WITH RESULT SETS UNDEFINED**. Эта инструкция возвращает набор данных из скрипта R, не присваивая имена столбцам и не указывая типы данных SQL.

+ Рассмотрите возможность создания данных времени и отслеживания с использованием T-SQL вместо R.

  Например, для передачи системного времени или других сведений, используемых при аудите и хранении, можно добавить вызов T-SQL, который передается в результаты, вместо того чтобы создавать аналогичные данные в скрипте R. 

### <a name="improve-performance-and-security"></a>Повышение производительности и безопасности

::: moniker range=">=sql-server-2016||>=sql-server-linux-ver15"
+ Не рекомендуется записывать прогнозы или промежуточные результаты в файл. Чтобы избежать перемещения данных, вместо этого следует записывать прогнозы в таблицу.
::: moniker-end

+ Выполняйте все запросы заранее и используйте планы запросов SQL Server для определения задач, которые могут выполняться параллельно.

  Если входной запрос может выполняться параллельно, задайте параметр `@parallel=1` как часть аргументов процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). 

  Параллельная обработка с использованием этого параметра обычно поддерживается, если SQL Server может работать с секционированными таблицами или распределять запрос между несколькими процессами и выполнять статистическую обработку результатов в конце. Параллельная обработка с использованием этого параметра обычно не поддерживается, если для обучения моделей применяются алгоритмы, требующие считывания всех данных, или если требуется создать агрегаты.

+ Определите, нет ли в коде R действий, которые можно выполнять отдельно или более эффективно с помощью вызова отдельной хранимой процедуры. Например, вы можете повысить производительность, формируя или извлекая признаки отдельно и сохраняя значения в таблице.

+ Ищите способы для выполнения вычислений на основе наборов с использованием кода T-SQL, а не R.

  ::: moniker range=">=sql-server-2016||>=sql-server-linux-ver15"
  Например, это решение R демонстрирует, как пользовательские функции T-SQL и R могут выполнять одинаковую задачу по формированию признаков: [Пошаговое руководство по обработке и анализу данных](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md).
  ::: moniker-end

+ По возможности замените обычные функции R функциями **ScaleR**, поддерживающими распределенное выполнение. Дополнительные сведения см. в статье [Сравнение функций Base R и Scale R](/machine-learning-server/r-reference/revoscaler/revoscaler-compared-to-base-r).

+ Вместе с разработчиком базы данных определите способы повысить производительность с помощью таких возможностей SQL Server, как [оптимизированные для памяти таблицы](../../relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables.md) или, если вы используете выпуск Enterprise, [Resource Governor](../../relational-databases/resource-governor/resource-governor.md).

## <a name="step-3-prepare-for-deployment"></a>Шаг 3. Подготовка к развертыванию

+ Обратитесь к администратору, чтобы установить и протестировать пакеты до развертывания кода. 

  В среде разработки допустимо устанавливать пакеты как часть кода, но это не рекомендуется делать в рабочей среде. 

  Пользовательские библиотеки не поддерживаются, даже если вы используете хранимые процедуры или выполняете код R в контексте вычислений SQL Server.

### <a name="package-your-r-code-in-a-stored-procedure"></a>Упаковка кода R в хранимую процедуру

+ Относительно простой код можно внедрить в пользовательскую функцию T-SQL без изменений, как описывается в этих примерах:

  + [Формирование признаков с помощью T-SQL и R](../tutorials/r-taxi-classification-create-features.md)

+ Для преобразования более сложного кода используйте пакет R **sqlrutils**. С помощью этого пакета опытные пользователи R могут создавать эффективный код хранимых процедур. 

  Для начала необходимо переписать код R в виде отдельной функции с четко определенными входными и выходными данными.

  Далее с помощью пакета **sqlrutils** создайте входные и выходные данные в корректном формате. Пакет **sqlrutils** создает полный код хранимой процедуры и также может зарегистрировать ее в базе данных. 

  Дополнительные сведения и примеры см. в статье, посвященной пакету [sqlrutils (SQL)](ref-r-sqlrutils.md).

### <a name="integrate-with-other-workflows"></a>Интеграция с другими рабочими процессами

+ Используйте средства T-SQL и процессы извлечения, преобразования и загрузки. Выполняйте формирование и извлечение признаков, а также очистку данных, заранее в рамках процессов обработки данных.

  При работе в специализированной среде разработки R, такой как [!INCLUDE[rsql_rtvs_md](../../includes/rsql-rtvs-md.md)] или RStudio, вы можете выполнять извлечение данных на компьютер, их последовательный анализ и запись или отображение результатов. 
  
  Однако при переносе кода R в SQL Server большую часть этого процесса можно упростить или делегировать другим средствам SQL Server. 

+ Используйте безопасные стратегии асинхронной визуализации.

  Пользователи SQL Server часто не могут получить доступ к файлам на сервере, а клиентские средства SQL как правило не поддерживают графическое устройство R. Если в вашем решении создаются диаграммы и другие графические элементы, рекомендуется экспортировать их в виде двоичных данных и записывать или сохранять в таблицу.

+ Упакуйте функции прогнозирования и оценки в хранимые процедуры, что позволит приложениям напрямую обращаться к ним.

## <a name="next-steps"></a>Дальнейшие действия

Примеры развертывания решения R в SQL Server можно найти в следующих статьях:

+ [Руководство по Разработка прогнозной модели в R с помощью машинного обучения SQL](../tutorials/r-predictive-model-introduction.md)

+ [Учебник по R. Прогнозирование стоимости поездки в нью-йоркском такси с использованием двоичной классификации](../tutorials/r-taxi-classification-introduction.md)

::: moniker range=">=sql-server-2016||>=sql-server-linux-ver15"
+ [Комплексное решение по обработке и анализу данных](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md) — в этой статье приведено сравнение формирования признаков в R и T-SQL
::: moniker-end
