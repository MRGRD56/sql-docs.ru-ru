---
title: Технический документ. Диагностика и устранение конфликтов спин-блокировок
description: В этой статье подробно рассматривается диагностика и устранение конфликтов спин-блокировок в SQL Server. Эта статья была изначально опубликована командой SQLCAT в корпорации Майкрософт.
ms.date: 09/30/2020
ms.prod: sql
ms.reviewer: wiassaf
ms.technology: performance
ms.topic: how-to
author: bluefooted
ms.author: pamela
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: 8d7d68e5eec8ddef36970d073b96e54db80b2947
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "100074985"
---
# <a name="diagnose-and-resolve-spinlock-contention-on-sql-server"></a>Диагностика и устранение конфликтов спин-блокировок на SQL Server

Эта статья содержит подробные сведения о том, как обнаружить и устранить проблемы, связанные с конфликтами спин-блокировок, в приложениях SQL Server в системах с высоким уровнем параллелизма.

> [!NOTE]
> Рекомендации и лучшие методики, описанные здесь, основаны на реальном опыте разработки и развертывания реальных систем OLTP. Первоначально эта статья была опубликована командой консультирования клиентов Microsoft SQL Server (SQLCAT).

## <a name="background"></a>История

В прошлом на обычных компьютерах с ОС Windows Server использовался только один или два микропроцессора (ЦП), а сами ЦП содержали только одно "ядро". Увеличение вычислительной мощности компьютера было достигнуто за счет использования более быстрых процессоров, что стало возможным в значительной степени благодаря повышению плотности транзисторов. Согласно "закону Мура", плотность транзисторов, то есть количество транзисторов, которые можно разместить на интегральной схеме, стабильно удваивается каждые два года с момента разработки первого однокристального ЦП общего назначения в 1971 году. В последние годы традиционный подход увеличения вычислительной мощности компьютеров с помощью более быстрых процессоров был дополнен созданием компьютеров с несколькими процессорами. На момент написания этой статьи архитектура ЦП Intel Nehalem поддерживает до восьми ядер в одном ЦП, которые при использовании систем с восемью сокетами можно удвоить до 128 логических процессоров с помощью технологии Hyper-Threading. По мере увеличения числа логических процессоров на компьютерах, совместимых с архитектурой x86, растет и число проблем, связанных с параллелизмом, поскольку логические процессоры конкурируют за ресурсы. В этом руководство описано, как обнаружить и устранить определенные проблемы, связанные с состязанием за ресурсы, возникающие при работе приложений SQL Server в системах с высоким уровнем параллелизма с некоторыми рабочими нагрузками.

В этом разделе мы проанализируем уроки, усвоенные командой SQLCAT при диагностике и устранении проблем с конфликтами спин-блокировок. Конфликты спин-блокировок — это одна из проблем параллелизма, которая наблюдается в реальных рабочих нагрузках клиентов в высокомасштабируемых системах.

## <a name="symptoms-and-causes-of-spinlock-contention"></a>Симптомы и причины конфликтов спин-блокировок

В этом разделе описано, как диагностировать проблемы с *конфликтами спин-блокировок*, которые негативно влияют на производительность приложений OLTP на SQL Server. Диагностику спин-блокировок и устранение неполадок следует рассматривать как сложную тему, которая требует знаний средств отладки и внутреннего устройства Windows.

Спин-блокировки — это упрощенные примитивы синхронизации, используемые для защиты доступа к структурам данных. Спин-блокировки не являются уникальными для SQL Server. Операционная система использует их, когда доступ к определенной структуре данных требуется только в течение короткого времени. Когда поток, пытающийся получить спин-блокировку, не может получить доступ, он входит в цикл, периодически проверяя, доступен ли ресурс, вместо немедленной приостановки. По истечении некоторого периода времени поток, ожидающий спин-блокировку, приостанавливается, пока не сможет получить ресурс. Приостановка позволяет выполнять другие потоки на том же ЦП. Такое поведение называется задержкой и будет рассмотрено более подробно далее в этой статье.

SQL Server использует спин-блокировки для защиты доступа к некоторым внутренним структурам данных. Спин-блокировки используются в обработчике для сериализации доступа к определенным структурам данных таким же образом, как и при кратковременных блокировках. Основное различие между кратковременными блокировками и спин-блокировками заключается в том, что спин-блокировки будут вращаться (выполняться в цикле) в течение периода проверки доступности структуры данных, тогда как поток, пытающийся получить доступ к структуре, защищенной кратковременной блокировкой, немедленно приостанавливается, если ресурс недоступен. Для приостановки требуется переключение контекста потока с ЦП, чтобы можно было выполнить другой поток. Это относительно дорогостоящая операция, и для ресурсов, которые удерживаются в течение короткого времени, более эффективно в целом, чтобы поток выполнялся в цикле, периодически проверяя доступность ресурса.

## <a name="symptoms"></a>Симптомы

В любой загруженной системе с высоким уровнем параллелизма активное состязание за часто используемые структуры, защищенные спин-блокировками, является нормальным. Такое использование считается проблемным, только если состязание приводит к значительным расходам ресурсов ЦП. Статистика спин-блокировок предоставляется динамическим административным представлением *sys.dm_os_spinlock_stats* в SQL Server. Например, этот запрос дает следующие выходные данные:

> [!NOTE]
> Дополнительные сведения об интерпретации данных, возвращаемых этим динамическим административным представлением, обсуждаются далее в этой статье.

```sql
select * from sys.dm_os_spinlock_stats
order by spins desc
```

![Вывод sys.dm_os_spinlock_stats](./media/diagnose-resolve-spinlock-contention/image4.png)

Статистика, предоставляемая этим запросом, описана ниже.

| Столбец | Описание |
|---|---|
| **Collisions** | Это значение увеличивается при каждой блокировке доступа потока к ресурсу, защищенному спин-блокировкой. |
| **Spins** | Это значение увеличивается при каждом выполнении цикла потоком во время ожидания доступности спин-блокировки. Это мера объема работы, которую поток выполняет при попытке получить ресурс. |
| **Spins_per_collision** | Количество вращений на один конфликт. |
| **Sleep time** | Связано с событиями задержек, но не относится к методам, описанным в этой статье. |
| **Backoffs** | Происходит, когда "вращающий" поток, пытающийся получить доступ к удерживаемому ресурсу, определил, что ему нужно разрешить выполнение других потоков на том же ЦП. |

Для целей этого обсуждения особый интерес представляют статистические данные о количестве коллизий, вращений и событий задержек, которые происходят в течение определенного периода времени, когда система находится под большой нагрузкой. Когда поток пытается получить доступ к ресурсу, защищенному спин-блокировкой, возникает конфликт. При возникновении конфликта счетчик конфликтов увеличивается, и поток начинает вращаться в цикле и периодически проверяет, доступен ли ресурс. При каждом вращении (цикле) потока число вращений увеличивается.

Количество вращений на конфликт — это мера количества вращений, происходящих во время удержания потоком спин-блокировки, которая сообщает, сколько вращений происходит, пока потоки удерживают спин-блокировку. Например, небольшое количество вращений на один конфликт и большое количество конфликтов означает, что под спин-блокировкой происходит небольшое количество вращений, и за них состязаются множество потоков. Большое количество вращений означает, что время, потраченное на вращение в коде спин-блокировки, является относительно долгим (то есть код проходит через большое количество записей в хэш-контейнере). По мере роста конкуренции (а значит, и роста количества конфликтов) число вращений также увеличивается.

Задержки можно рассматривать аналогично вращениям. Во избежание чрезмерного расходования ресурсов ЦП спин-блокировки не будут работать бесконечно, пока не смогут получить доступ к удерживаемому ресурсу. Чтобы предотвратить чрезмерное использование ресурсов ЦП, спин-блокировки выполняют задержку, то есть останавливают цикл и "засыпают". Спин-блокировки выполняют задержку независимо от того, получат ли они когда-либо владение целевым ресурсом. Это делается для того, чтобы другие потоки могли быть запланированы на ЦП в надежде, что это может привести к более продуктивной работе. Поведение по умолчанию для обработчика — вращение в течение фиксированного интервала времени до выполнения задержки. Попытка получить спин-блокировку требует сохранения состояния параллелизма кэша, что является операцией, более интенсивно использующей ЦП по сравнению с вращением. Таким образом, попытки получить спин-блокировки выполняются экономно и не выполняются при каждом вращении потока. В SQL Server определенные типы спин-блокировок (например, LOCK_HASH) были улучшены с помощью экспоненциального увеличения интервала между попытками получения спин-блокировки (до определенного предела), что часто сокращает негативное влияние на производительность ЦП.

На следующей схеме представлено концептуальное представление алгоритма спин-блокировки.

![Концептуальное представление алгоритма спин-блокировки](./media/diagnose-resolve-spinlock-contention/image5.png)

## <a name="typical-scenarios"></a>Типичные сценарии

Конфликты спин-блокировок могут происходить по целому ряду причин, которые могут не относиться к решениям по проектированию баз данных. Поскольку спин-блокировки закрывают доступ к внутренним структурам данных, конфликты спин-блокировок не проявляются таким же образом, как и состязание за кратковременные блокировки буфера, что непосредственно влияет на выбор схемы и шаблоны доступа к данным.

Симптом, который в основном связан с конфликтами спин-блокировок, — это высокий уровень потребления ресурсов ЦП в результате большого числа вращений и большого числа потоков, пытающихся получить одну и ту же спин-блокировку. Как правило, это наблюдалось в системах с \>= 24 и чаще всего в системах с \>= 32 ядер ЦП. Как упоминалось ранее, некоторый уровень состязаний за спин-блокировки является нормальным для систем OLTP с высокой степенью параллелизма и со значительной нагрузкой, и часто динамическое административное представление *sys.dm_os_spinlock_stats* сообщает о большом количестве вращений (миллиарды и триллионы) в системах, которые работают в течение длительного времени. Опять же, наблюдаемое большое количество вращений для любого типа спин-блокировок не является достаточным, чтобы сказать, что это отрицательно сказывается на производительности рабочей нагрузки.

Сочетание нескольких из следующих симптомов может указывать на конфликты спин-блокировок.

* Для конкретного типа спин-блокировки наблюдается большое количество вращений и задержек.

* В системе наблюдается высокая загрузка ЦП или скачки потребления ЦП. В сценариях с высокой загрузкой ЦП наблюдается высокий уровень ожидания сигнала SOS_SCHEDULER_YEILD (сообщаемые динамическим административным представлением *sys.dm_os_wait_stats*).

* В системе наблюдается высокий уровень параллелизма.

* Использование ЦП и количество вращений увеличиваются непропорционально пропускной способности.

   > [!IMPORTANT]
   > Даже если выполняется каждое из вышеперечисленных условий, возможно, основная причина высокой загрузки ЦП кроется в другом месте. На самом деле в подавляющем большинстве случаев увеличение загрузки ЦП обусловлено причинами, отличными от конфликтов спин-блокировок. Ниже перечислены некоторые из наиболее распространенных причин увеличения потребления ресурсов ЦП.

* Запросы, которые становятся более ресурсоемкими с течением времени из-за роста базовых данных, что приводит к необходимости выполнять дополнительные логические операции чтения резидентных данных.

* Изменения в планах запросов, которые приводят к неоптимальному выполнению.

Если выполняются все эти условия, проведите дальнейшее исследование возможных проблем с конфликтами спин-блокировок.

Одной из распространенных проблем, которые легко диагностировать, является значительное расхождение в пропускной способности и использовании ЦП. Во многих рабочих нагрузках OLTP существует связь между (пропускная способность / число пользователей в системе) и потреблением ресурсов ЦП. Большое количество вращений, наблюдаемой в сочетании с значительным расхождением потребления ресурсов ЦП и пропускной способности, могут указывать на конфликты спин-блокировок, приводящие к дополнительной нагрузке на ЦП. Важно отметить, что этот тип расхождения часто наблюдается в системах, когда определенные запросы становятся более ресурсоемкими с течением времени. Например, запросы к наборам данных, которые со временем выполняют больше логических операций чтения, могут привести к аналогичным симптомам.

При устранении проблем такого типа крайне важно попытаться устранить другие более распространенные причины высокой загрузки ЦП.

## <a name="example"></a>Пример

В следующем примере существует почти линейная связь между потреблением ЦП и пропускной способностью, измеряемой транзакциями в секунду. Некоторое расхождение здесь является нормальным, поскольку при увеличении рабочей нагрузки возникают накладные расходы. Как показано ниже, это расхождение становится существенным. Кроме того, пропускная способность резко падает, когда загрузка ЦП достигает 100 %.

![Загрузка ЦП в мониторе производительности](./media/diagnose-resolve-spinlock-contention/image7.png)

При измерении количества вращений с интервалом в 3 минуты можно увидеть больше экспоненциальное, чем линейное увеличение числа вращений, которое указывает на то, что состязание за спин-блокировки может быть проблемным.

![Диаграмма вращений с интервалами в 3 минуты](./media/diagnose-resolve-spinlock-contention/image8.png)

Как уже отмечалось ранее, спин-блокировки наиболее часто встречаются в системах с высоким уровнем параллелизма и высокой загрузкой.

Ниже перечислены некоторые сценарии, которые подвержены этой проблеме.

* Проблемы разрешения имен, вызванные неспособностью определить полные имена объектов. Дополнительные сведения см. в разделе [Описание блокировок SQL Server, вызванных блокировками компиляции](https://support.microsoft.com/help/263889/how-to-troubleshoot-blocking-caused-by-compile-locks). В этой статье подробна описана эта проблема.

* Конфликты блокировок хэш-контейнеров в диспетчере блокировок для рабочих нагрузок, которые часто обращаются к одной и той же блокировке (например, совмещаемой блокировке для часто считываемых строк). Этот тип состязаний проявляется как спин-блокировка типа LOCK_HASH. В одном конкретном случае мы обнаружили, что эта проблема возникает в результате неправильно смоделированных шаблонов доступа в тестовой среде. В этой среде число потоков, постоянно обращающихся к одной и той же строке, превысило ожидаемое количество из-за неправильной настройки параметров тестирования.

* Высокая частота транзакций DTC при высокой степени задержки между координаторами транзакций MSDTC. Эта конкретная проблема подробно описана в записи блога SQLCAT [Resolving DTC Related Waits and Tuning Scalability of DTC](https://techcommunity.microsoft.com/t5/datacat/resolving-dtc-related-waits-and-tuning-scalability-of-dtc/ba-p/305054) (Устранение ожиданий, связанных с DTC, и настройка масштабируемости DTC).

## <a name="diagnosing-spinlock-contention"></a>Диагностика конфликтов спин-блокировок

В этом разделе содержатся сведения для диагностики конфликтов спин-блокировок в SQL Server. Основные средства, используемые для диагностики конфликтов спин-блокировок:

| Средство | Использовать |
|---|---|
| **Мониторинг производительности.** | Ищите высокую загрузку ЦП или расхождение между пропускной способностью и потреблением ресурсов ЦП. |
| **Динамическое административное представление sys.dm_os_spinlock_stats** | Ищите большое количество вращений и задержек с течением времени. |
| **Расширенные события SQL Server** | Используются для трассировки стеков вызовов для спин-блокировок, в которых наблюдается большое количество вращений. |
| **Дампы памяти** | В некоторых случаях дампы памяти процесса SQL Server и средств отладки Windows. Как правило, этот уровень анализа выполняется при привлечении групп поддержки Microsoft SQL Server. |

Общий технический процесс диагностики конфликтов спин-блокировок в SQL Server:

1. **Шаг 1**. Убедитесь, что существуют конфликты, которые могут быть связаны со спин-блокировками.

2. **Шаг 2**. Запишите статистические данные из *sys.dm\_os_spinlock_stats*, чтобы определить тип спин-блокировки, вызывающий наибольшие конфликты.

3. **Шаг 3**. Получите отладочные символы для sqlservr.exe (sqlservr.pdb) и поместите символы в тот же каталог, где находится исполняемый файл службы SQL Server (sqlservr.exe) экземпляра SQL Server. Чтобы просмотреть стеки вызовов для событий задержек, необходимо иметь символы для конкретной версии SQL Server, которую вы используете. Символы для SQL Server доступны на сервере символов Майкрософт. Дополнительные сведения о загрузке символов с сервера символов Майкрософт см. в разделе [Отладка с помощью символов](/windows/win32/dxtecharts/debugging-with-symbols).

4. **Шаг 4**. Используйте расширенные события SQL Server, чтобы отследить события задержек для интересующих типов спин-блокировок.

Расширенные события предоставляют возможность отслеживать события \"задержек\" и захватывать стек вызовов для операций, которые наиболее часто пытаются получить спин-блокировку. Анализируя стек вызовов, можно определить, какой тип операции участвует в конфликтах любой конкретной спин-блокировки.

## <a name="diagnostic-walkthrough"></a>Пошаговое руководство по диагностике

В следующем пошаговом руководстве показано, как использовать средства и методы для диагностики проблем с конфликтами спин-блокировок на реальном примере. Это пошаговое руководство основано на взаимодействии с клиентом, в ходе которого был проведен тест производительности для имитации приблизительно 6500 одновременных пользователей на сервере с 8 сокетами, 64 физическими ядрами и 1 ТБ памяти.

### <a name="symptoms"></a>Симптомы

В ЦП наблюдались периодические пиковые нагрузки, при которых загрузка достигала почти 100 %. Было обнаружено расхождение между пропускной способностью и потреблением ресурсов ЦП, что привело к проблеме. В момент, когда происходил значительный рост потребления ресурсов ЦП, было установлено большое количество вращений, происходивших во время интенсивного использования ЦП с определенными интервалами.

Это был крайний случай, когда состязание было таково, что было создано условие для конвоя спин-блокировок. Конвой возникает, когда потоки больше не могут выполнять обслуживание рабочей нагрузки, а вместо этого тратят все вычислительные ресурсы на попытки получения доступа к блокировке. В журнале системного монитора показано это расхождение между пропускной способностью журнала транзакций и потреблением ресурсов ЦП и, в конечном итоге, появление большого пика в использовании ЦП.

![Скачок загрузки ЦП в мониторе производительности](./media/diagnose-resolve-spinlock-contention/image9.png)

После запроса к *sys.dm_os_spinlock_stats* для определения существования больших конфликтов на SOS_CACHESTORE использовался скрипт расширенных событий для измерения количества событий задержки для интересующих типов спин-блокировок.

| Имя | Collisions | Вращений | Вращений на конфликт | Задержек |
|---|---|---|---|---|
| **SOS_CACHESTORE** |       14 752 117 |   942 869 471 526 |   63 914 |                67 900 620 |
| **SOS_SUSPEND_QUEUE** |   69 267 367 |   473 760 338 765 |   6840  |                2 167 281 |
| **LOCK_HASH** |           5 765 761 |    260 885 816 584 |   45 247 |                3 739 208 |
| **MUTEX** |               2 802 773 |    9 767 503 682 |     3485  |                350 997 |
| **SOS_SCHEDULER** |       1 207 007 |    3 692 845 572 |     3060  |                109 746 |

Самым простым способом количественного измерения влияния вращений является просмотр числа событий задержки, предоставляемых *sys.dm_os_spinlock_stats* за один и тот же интервал в 1 минуту для типов спин-блокировок с наибольшим числом вращений. Этот метод лучше распознает значительные конфликты, так как он указывает, что потоки исчерпали предел количества вращений при ожидании получения спин-блокировки. В следующем скрипте показана улучшенная методика, использующая расширенные события для измерения связанных событий задержки и определения конкретных путей к коду, в котором лежат конфликты.

Дополнительные сведения о расширенных событиях в SQL Server см. в статье [Введение в расширенные события SQL Server](./extended-events/extended-events.md).

**Скрипт**

```sql
/*
This Scriptis provided "AS IS" with no warranties, and confers no rights.

This script will monitor for backoff events over a given period of time and
capture the code paths (callstacks) for those.

--Find the spinlock types
select map_value, map_key, name from sys.dm_xe_map_values
where name = 'spinlock_types'
order by map_value asc

--Example: Get the type value for any given spinlock type
select map_value, map_key, name from sys.dm_xe_map_values
where map_value IN ('SOS_CACHESTORE', 'LOCK_HASH', 'MUTEX')

Examples:
61LOCK_HASH
144 SOS_CACHESTORE
08MUTEX

*/

--create the even session that will capture the callstacks to a bucketizer
--more information is available in this reference: http://msdn.microsoft.com/en-us/library/bb630354.aspx
create event session spin_lock_backoff on server
      add event sqlos.spinlock_backoff (action (package0.callstack)
where 
type = 61--LOCK_HASH
or type = 144--SOS_CACHESTORE
or type = 8--MUTEX
)
      add target package0.asynchronous_bucketizer (
            set filtering_event_name='sqlos.spinlock_backoff',
            source_type=1, source='package0.callstack')
      with (MAX_MEMORY=50MB, MEMORY_PARTITION_MODE = PER_NODE)

--Ensure the session was created
select * from sys.dm_xe_sessions
where name = 'spin_lock_backoff'

--Run this section to measure the contention 
alter event session spin_lock_backoff on server state=start

--wait to measure the number of backoffs over a 1 minute period
waitfor delay '00:01:00'

--To view the data
--1. Ensure the sqlservr.pdb is in the same directory as the sqlservr.exe
--2. Enable this trace flag to turn on symbol resolution 
DBCC traceon (3656, -1)

--Get the callstacks from the bucketize target
select event_session_address, target_name, execution_count, cast (target_data as XML)
from sys.dm_xe_session_targets xst
inner join sys.dm_xe_sessions xs on (xst.event_session_address = xs.address)
where xs.name = 'spin_lock_backoff'

--clean up the session 
alter event session spin_lock_backoff on server state=stop
drop event session spin_lock_backoff on server
```

Проанализировав выходные данные, можно увидеть стеки вызовов для наиболее распространенных путей кода для вращений SOS_CACHESTORE. Скрипт был запущен в несколько различных моментов времени во время высокой загрузки ЦП для проверки согласованности в возвращаемых стеках вызовов. Обратите внимание, что стеки вызовов с наибольшим числом контейнеров слотов являются общими для двух выводов (35 668 и 8506). Эти стеки вызовов имеют значение "slot count" (число слотов) на два порядка больше, чем следующая по величине запись. Это условие указывает на интересующий путь к коду.

> [!NOTE]
> Стеки вызовов, возвращенные предыдущим скриптом, не являются редкостью. При выполнении скрипта в течение 1 минуты мы наблюдали, что стеки вызовов с числом слотов более 1000 были проблемными, а стеки вызовов с числом слотов более 10 000 были проблемными с еще большей вероятностью, так как они имели большее число слотов.

> [!NOTE]
> Форматирование следующего вывода было очищено для удобства чтения.

**Выход 1**

```xml
<BucketizerTarget truncated="0" buckets="256">
<Slot count="35668" trunc="0">
  <value>
      XeSosPkg::spinlock_backoff::Publish 
      SpinlockBase::Sleep 
      SpinlockBase::Backoff 
      Spinlock<144,1,0>::SpinToAcquireOptimistic 
      SOS_CacheStore::GetUserData 
      OpenSystemTableRowset 
      CMEDScanBase::Rowset 
      CMEDScan::StartSearch 
      CMEDCatalogOwner::GetOwnerAliasIdFromSid 
      CMEDCatalogOwner::LookupPrimaryIdInCatalog CMEDCacheEntryFactory::GetProxiedCacheEntryByAltKey
      CMEDCatalogOwner::GetProxyOwnerBySID
      CMEDProxyDatabase::GetOwnerBySID
      ISECTmpEntryStore::Get 
      ISECTmpEntryStore::Get
      NTGroupInfo::`vector deleting destructor'
  </value> 
</Slot>
<Slot count="752" trunc="0">
  <value>
      XeSosPkg::spinlock_backoff::Publish 
      SpinlockBase::Sleep 
      SpinlockBase::Backoff 
      Spinlock<144,1,0>::SpinToAcquireOptimistic 
      SOS_CacheStore::GetUserData 
      OpenSystemTableRowset
      CMEDScanBase::Rowset 
      CMEDScan::StartSearch
      CMEDCatalogOwner::GetOwnerAliasIdFromSid CMEDCatalogOwner::LookupPrimaryIdInCatalog CMEDCacheEntryFactory::GetProxiedCacheEntryByAltKey             CMEDCatalogOwner::GetProxyOwnerBySID 
      CMEDProxyDatabase::GetOwnerBySID 
      ISECTmpEntryStore::Get
      ISECTmpEntryStore::Get 
      ISECTmpEntryStore::Get
  </value>
  </Slot>
```

**Выход 2**

```xml
<BucketizerTarget truncated="0" buckets="256">
<Slot count="8506" trunc="0">
  <value>
      XeSosPkg::spinlock_backoff::Publish 
      SpinlockBase::Sleep+c7 [ @ 0+0x0 SpinlockBase::Backoff Spinlock<144,1,0>::SpinToAcquireOptimistic
      SOS_CacheStore::GetUserData 
      OpenSystemTableRowset 
      CMEDScanBase::Rowset 
      CMEDScan::StartSearch
      CMEDCatalogOwner::GetOwnerAliasIdFromSid CMEDCatalogOwner::LookupPrimaryIdInCatalog CMEDCacheEntryFactory::GetProxiedCacheEntryByAltKey CMEDCatalogOwner::GetProxyOwnerBySID 
      CMEDProxyDatabase::GetOwnerBySID 
      ISECTmpEntryStore::Get
      ISECTmpEntryStore::Get
      NTGroupInfo::`vector deleting destructor'
</value> 
 </Slot>
<Slot count="190" trunc="0">
  <value>
      XeSosPkg::spinlock_backoff::Publish 
      SpinlockBase::Sleep
       SpinlockBase::Backoff 
      Spinlock<144,1,0>::SpinToAcquireOptimistic 
      SOS_CacheStore::GetUserData 
      OpenSystemTableRowset 
      CMEDScanBase::Rowset 
      CMEDScan::StartSearch 
      CMEDCatalogOwner::GetOwnerAliasIdFromSid CMEDCatalogOwner::LookupPrimaryIdInCatalog CMEDCacheEntryFactory::GetProxiedCacheEntryByAltKey CMEDCatalogOwner::GetProxyOwnerBySID 
      CMEDProxyDatabase::GetOwnerBySID 
      ISECTmpEntryStore::Get 
      ISECTmpEntryStore::Get
      ISECTmpEntryStore::Get
   </value> 
 </Slot>
```

В предыдущем примере наиболее интересные стеки имеют наибольшее число слотов (35 668 и 8506), то есть фактически число слотов \> 1000.

Следующий вопрос: "что делать с этими сведениями"? В целом, чтобы использовать сведения о стеке вызовов, необходимо иметь глубокие знания о ядре SQL Server, поэтому на этом этапе процесс устранения неполадок перемещается в серую область. В этом конкретном случае, взглянув на стеки вызовов, мы видим, что путь к коду, в котором возникает проблема, связан с безопасностью и поиском метаданных (что очевидно из кадров стека **CMEDCatalogOwner::GetProxyOwnerBySID и CMEDProxyDatabase::GetOwnerBySID)** .

Сами по себе эти сведения трудно использовать для устранения проблемы, но это дает нам некоторые идеи, на которых можно сосредоточиться для дополнительных усилий по дальнейшему изолированию проблемы.

Поскольку эта проблема, по-видимому, была связана с путями к коду, который выполняет проверки, связанные с безопасностью, мы решили запустить тест, в котором пользователю приложения, подключающемуся к базе данных, были предоставлены привилегии системного администратора. Хотя этот метод никогда не рекомендуется использовать в рабочей среде, в нашей тестовой среде он оказался полезным этапом на пути устранения неполадок. Если сеансы выполнялись с повышенными привилегиями (sysadmin), то нагрузка ЦП, связанная с конфликтами, исчезала.

## <a name="options-and-workarounds"></a>Варианты и обходные решения

Очевидно, что устранение конфликтов спин-блокировок может оказаться нетривиальной задачей. Не существует "единого наилучшего подхода". Первый шаг в устранении неполадок и устранения проблем с производительностью — определение основной причины. Использование методов и средств, описанных в этой статье, является первым шагом в выполнении анализа, необходимого для понимания конфликтных точек, связанных со спин-блокировками.

По мере разработки новых версий SQL Server ядро продолжает улучшать масштабируемость, реализуя код, который лучше оптимизирован для систем с высоким уровнем параллелизма. В SQL Server появилось много оптимизаций для систем с высоким уровнем параллелизма, одной из которых является экспоненциальная задержка для наиболее распространенных точек конфликтов. Начиная с SQL Server 2012 появились некоторые усовершенствования, которые специально улучшают эту конкретную область, используя алгоритмы экспоненциальных задержек для всех спин-блокировок в ядре.

При проектировании высокопроизводительных приложений, которым требуется высочайшая производительность и масштабируемость, подумайте о том, как обеспечить как можно более короткий необходимый путь к коду в SQL Server. Более короткий путь к коду означает меньшее количество операций, выполняемых ядром СУБД, и, естественно, меньше точек конфликтов. Многие лучшие методики имеют побочный результат в виде уменьшения объема работы, требуемой от ядра, и, следовательно, в оптимизации производительности рабочей нагрузки.

Вот несколько рекомендаций, приведенных ранее в этой статье, в качестве примеров.

* **Полные имена**. Задание полных имен для всех объектов избавит SQL Server от необходимости выполнять пути к коду, необходимому для разрешения имен. Мы наблюдали точки конфликтов в типе спин-блокировки SOS_CACHESTORE, обнаруженные при неиспользовании полных имен в вызовах хранимых процедур. Неполное определение этих имен приводит к необходимости сервером SQL Server поиска схемы по умолчанию для пользователя, что приводит к увеличению пути кода, необходимого для выполнения SQL.

* **Параметризованные запросы**. Другой пример — использование параметризованных запросов и вызовов хранимых процедур для сокращения объема работы, необходимой для создания планов выполнения. Это опять же приводит к сокращению пути к коду для выполнения.

* **Конфликты LOCK_HASH**. В некоторых случаях неизбежны конфликты за некоторые структуры блокировок или коллизии хэш-контейнеров. Несмотря на то, что подсистема SQL Server разделяет большинство структур блокировки, все еще бывают случаи, когда получение блокировки приводит к тому же хэш-контейнеру. Например, приложение, которое обращается к одной и той же строке несколькими потоками одновременно (то есть ссылочные данные). К таким типам проблем можно подходить с помощью методов, которые либо увеличивают масштаб этих ссылочных данных в схеме базы данных, либо используют указания NOLOCK, когда это возможно.

Первой линией защиты при настройке рабочих нагрузок SQL Server всегда являются стандартные методы настройки (например, индексирование, оптимизация запросов, оптимизация ввода-вывода и т. д.). Однако в дополнение к стандартной настройке важно выполнить следующие рекомендации, которые уменьшают объем кода, необходимого для выполнения операций. Даже при соблюдении рекомендаций все равно существует вероятность того, что конфликты спин-блокировок будут происходить в системах с высоким уровнем параллелизма. Использование средств и методов, описанных в этой статье, помогает изолировать или устранить проблемы такого типа и определить, когда необходимо привлечь к решению нужные ресурсы Майкрософт.

Надеемся, что эти методы предоставляют как полезную методику для устранения этого типа неполадок, так и понимание некоторых более сложных методов профилирования производительности, доступных в SQL Server.

## <a name="appendix-automate-memory-dump-capture"></a>Приложение. Автоматизация записи дампа памяти

Приведенный ниже скрипт расширенных событий полезен для автоматизации сбора дампов памяти, когда конфликты спин-блокировок станут существенными. В некоторых случаях дампы памяти потребуются для выполнения полной диагностики проблемы или будут запрошены специалистами службы поддержки Майкрософт для выполнения углубленного анализа. В SQL Server 2008 существует ограничение в 16 кадров в стеках вызовов, захваченных группировщиком, что может быть недостаточно глубоким для точного определения места ядра, из которого был выполнен ввод стека вызовов. В SQL Server 2012 появились улучшения, увеличившие число кадров в стеке вызовов, захваченных группировщиком, до 32-х.

Следующий скрипт SQL можно использовать для автоматизации процесса записи дампов памяти, чтобы помочь анализировать конфликты спин-блокировок.

```sql
/*
This script is provided "AS IS" with no warranties, and confers no rights.

Use:    This procedure will monitor for spinlocks with a high number of backoff events
        over a defined time period which would indicate that there is likely significant
        spin lock contention.
        
        Modify the variables noted below before running.


Requires:
        xp_cmdshell to be enabled
            sp_configure 'xp_cmd', 1
            go 
            reconfigure 
            go
        
*********************************************************************************************************/
use tempdb
go 
if object_id('sp_xevent_dump_on_backoffs') is not null
    drop proc sp_xevent_dump_on_backoffs
go 
create proc sp_xevent_dump_on_backoffs
(
    @sqldumper_path                       nvarchar(max)      = '"c:\Program Files\Microsoft SQL Server\100\Shared\SqlDumper.exe"'
    ,@dump_threshold                      int                = 500           --capture mini dump when the slot count for the top bucket exceeds this
    ,@total_delay_time_seconds            int                = 60            --poll for 60 seconds
    ,@PID                                 int                = 0
    ,@output_path                         nvarchar(max)      = 'c:\'
    ,@dump_captured_flag                  int = 0 OUTPUT
    
)
as
/* 
    --Find the spinlock types
    select map_value, map_key, name from sys.dm_xe_map_values
    where name = 'spinlock_types'
    order by map_value asc

    --Example: Get the type value for any given spinlock type
    select map_value, map_key, name from sys.dm_xe_map_values
    where map_value IN ('SOS_CACHESTORE', 'LOCK_HASH', 'MUTEX')
*/
if exists (select * from sys.dm_xe_session_targets xst
                inner join sys.dm_xe_sessions xs on (xst.event_session_address = xs.address)
                where xs.name = 'spinlock_backoff_with_dump')
    drop event session spinlock_backoff_with_dump on server

create event session spinlock_backoff_with_dump  on server
      add event sqlos.spinlock_backoff (action (package0.callstack)
            where
                type = 61                 --LOCK_HASH
                --or type = 144           --SOS_CACHESTORE
                --or type = 8             --MUTEX
                --or type = 53            --LOGCACHE_ACCESS
                --or type = 41            --LOGFLUSHQ
                --or type = 25            --SQL_MGR
                --or type = 39            --XDESMGR
                )
      add target package0.asynchronous_bucketizer (
            set filtering_event_name='sqlos.spinlock_backoff',
            source_type=1, source='package0.callstack')
      with (MAX_MEMORY=50MB, MEMORY_PARTITION_MODE = PER_NODE)

alter event session spinlock_backoff_with_dump  on server state=start


declare @instance_name            nvarchar(max) = @@SERVICENAME
declare @loop_count               int = 1
declare @xml_result               xml 
declare @slot_count               bigint 
declare @xp_cmdshell              nvarchar(max) = null

--start polling for the backoffs
print 'Polling for: ' + convert(varchar(32), @total_delay_time_seconds) + ' seconds'
while (@loop_count < CAST (@total_delay_time_seconds/1 as int))
begin 
    waitfor delay '00:00:01'

    --get the xml from the bucketizer for the session
    select @xml_result= CAST(target_data as xml)
    from sys.dm_xe_session_targets xst
        inner join sys.dm_xe_sessions xs on (xst.event_session_address = xs.address)
    where xs.name = 'spinlock_backoff_with_dump'
    
    --get the highest slot count from the bucketizer
    select @slot_count = @xml_result.value(N'(//Slot/@count)[1]', 'int')

    --if the slot count is higher than the threshold in the one minute period
    --dump the process and clean up session
    if (@slot_count > @dump_threshold)
    begin 
        print 'exec xp_cmdshell ''' + @sqldumper_path + ' ' + convert(nvarchar(max), @PID) + ' 0 0x800 0 c:\ '''
        select @xp_cmdshell = 'exec xp_cmdshell ''' + @sqldumper_path + ' ' + convert(nvarchar(max), @PID) + ' 0 0x800 0 ' + @output_path + ' '''
        exec sp_executesql @xp_cmdshell
        print 'loop count: ' + convert (varchar(128), @loop_count)
        print 'slot count: ' + convert (varchar(128), @slot_count)
        set @dump_captured_flag = 1
        break
    end 

    --otherwise loop 
    set @loop_count = @loop_count + 1

end

--see what was collected then clean up
DBCC traceon (3656, -1)
select event_session_address, target_name, execution_count, cast (target_data as XML)
from sys.dm_xe_session_targets xst
    inner join sys.dm_xe_sessions xs on (xst.event_session_address = xs.address)
where xs.name = 'spinlock_backoff_with_dump'

alter event session spinlock_backoff_with_dump  on server state=stop
drop event session spinlock_backoff_with_dump  on server
go

/* CAPTURE THE DUMPS 
******************************************************************/
--Example: This will run continuously until a dump is created. 
declare @sqldumper_path                nvarchar(max)        = '"c:\Program Files\Microsoft SQL Server\100\Shared\SqlDumper.exe"'
declare @dump_threshold                int                  = 300            --capture mini dump when the slot count for the top bucket exceeds this
declare @total_delay_time_seconds      int                  = 60             --poll for 60 seconds 
declare @PID                           int                  = 0
declare @flag                          tinyint              = 0
declare @dump_count                    tinyint              = 0
declare @max_dumps                     tinyint              = 3              --stop after collecting this many dumps
declare @output_path                   nvarchar(max)        = 'c:\'          --no spaces in the path please :)


--Get the process id for sql server 
declare @error_log table (LogDate datetime,
    ProcessInfo varchar(255),
    Text varchar(max)
    )
insert into @error_log
    exec ('xp_readerrorlog 0, 1, ''Server Process ID''')
select @PID = convert(int, (REPLACE(REPLACE(Text, 'Server Process ID is ', ''), '.', '')))
    from @error_log where Text like ('Server Process ID is%')
print 'SQL Server PID: ' + convert (varchar(6), @PID)

--Loop to monitor the spinlocks and capture dumps. while (@dump_count < @max_dumps)
begin 

    exec sp_xevent_dump_on_backoffs @sqldumper_path             = @sqldumper_path,
                                    @dump_threshold             = @dump_threshold,
                                    @total_delay_time_seconds   = @total_delay_time_seconds,
                                    @PID                        = @PID,
                                    @output_path                = @output_path,
                                    @dump_captured_flag         = @flag OUTPUT
    if (@flag > 0) 
        set @dump_count=@dump_count + 1
    print 'Dump Count: ' + convert(varchar(2), @dump_count)
    waitfor delay '00:00:02'

end
```

## <a name="appendix-capture-spinlock-statistics-over-time"></a>Приложение. Запись статистики спин-блокировок с течением времени

Следующий скрипт можно использовать для просмотра статистики спин-блокировок за определенный период времени. При каждом запуске он возвращает разницу между текущими и предыдущими собранными значениями.

```sql
/* Snapshot the current spinlock stats and store so that this can be compared over a time period
   Return the statistics between this point in time and the last collection point in time.

   **This data is maintained in tempdb so the connection must persist between each execution**
   **alternatively this could be modified to use a persisted table in tempdb. if that
   is changed code should be included to clean up the table at some point.**
*/

use tempdb
go

declare @current_snap_time    datetime
declare @previous_snap_time   datetime

set @current_snap_time = GETDATE()

if not exists(select name from tempdb.sys.sysobjects where name like '#_spin_waits%')
    create table #_spin_waits
    (
        lock_name    varchar(128)
        ,collisions  bigint
        ,spins       bigint
        ,sleep_time  bigint
        ,backoffs    bigint
        ,snap_time   datetime
    )

--capture the current stats
insert into #_spin_waits
    (
        lock_name
        ,collisions
        ,spins
        ,sleep_time
        ,backoffs
        ,snap_time
        )
        select  name
                ,collisions
                ,spins
                ,sleep_time
                ,backoffs
                ,@current_snap_time
        from sys.dm_os_spinlock_stats

select top 1 @previous_snap_time = snap_time from #_spin_waits
                where snap_time < (select max(snap_time) from #_spin_waits)
                order by snap_time desc

--get delta in the spin locks stats   
select top 10
        spins_current.lock_name
        , (spins_current.collisions - spins_previous.collisions) as collisions
        , (spins_current.spins - spins_previous.spins) as spins
        , (spins_current.sleep_time - spins_previous.sleep_time) as sleep_time
        , (spins_current.backoffs - spins_previous.backoffs) as backoffs
        , spins_previous.snap_time as [start_time]
        , spins_current.snap_time as [end_time]
        , DATEDIFF(ss, @previous_snap_time, @current_snap_time) as [seconds_in_sample]
    from #_spin_waits spins_current
    inner join (
        select * from #_spin_waits
          where snap_time = @previous_snap_time
        ) spins_previous on (spins_previous.lock_name = spins_current.lock_name)
    where
        spins_current.snap_time = @current_snap_time
        and spins_previous.snap_time = @previous_snap_time
        and spins_current.spins > 0
    order by (spins_current.spins - spins_previous.spins) desc

--clean up table
delete from #_spin_waits
where snap_time = @previous_snap_time
```

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о средствах наблюдения за производительностью см. в статье [Средства контроля и настройки производительности](./performance/performance-monitoring-and-tuning-tools.md).
