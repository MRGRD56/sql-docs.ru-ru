---
description: sp_describe_undeclared_parameters (Transact-SQL)
title: sp_describe_undeclared_parameters (Transact-SQL) | Документация Майкрософт
ms.custom: ''
ms.date: 09/24/2018
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: system-objects
ms.topic: language-reference
f1_keywords:
- sp_describe_undeclared_parameters
- sp_describe_undeclared_parameters_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- sp_describe_undeclared_parameters
ms.assetid: 6f016da6-dfee-4228-8b0d-7cd8e7d5a354
author: markingmyname
ms.author: maghan
monikerRange: = azuresqldb-current||= azure-sqldw-latest||>= sql-server-2016||>= sql-server-linux-2017
ms.openlocfilehash: 710265fca96078ef08d54ca503f174a8150aca8e
ms.sourcegitcommit: 1a544cf4dd2720b124c3697d1e62ae7741db757c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2020
ms.locfileid: "97466845"
---
# <a name="sp_describe_undeclared_parameters-transact-sql"></a>sp_describe_undeclared_parameters (Transact-SQL)
[!INCLUDE [sql-asdb-asdbmi-asa](../../includes/applies-to-version/sql-asdb-asdbmi-asa.md)] 

  Возвращает результирующий набор, содержащий метаданные о необъявленных параметрах в [!INCLUDE[tsql](../../includes/tsql-md.md)] пакете. Учитывает каждый параметр, используемый в пакете **\@ tsql** , но не объявленный в **\@ параметрах**. Возвращается результирующий набор, содержащий одну строку для каждого такого параметра со сведениями о предполагаемом типе параметра. Процедура возвращает пустой результирующий набор, если у пакета ввода **\@ tsql** нет параметров, кроме тех, которые объявлены в **\@ параметре params**.  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```sql
  
sp_describe_undeclared_parameters   
    [ @tsql = ] 'Transact-SQL_batch'   
    [ , [ @params = ] N'parameters' data type ] [, ...n]  
```  

> [!Note] 
> Чтобы использовать эту хранимую процедуру в Azure синапсе Analytics в выделенном пуле SQL, задайте уровень совместимости базы данных 20 или выше.   Чтобы отказаться от этого, измените уровень совместимости базы данных на 10.

## <a name="arguments"></a>Аргументы  
`[ \@tsql = ] 'Transact-SQL\_batch'` Одна или несколько [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкций. *Transact-SQL_batch* может иметь тип **nvarchar (**_n_**)** или **nvarchar (max)**.  
  
`[ \@params = ] N'parameters'`\@params предоставляет строку объявления для параметров [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета, аналогично тому, как sp_executesql работает. *Параметры* могут быть **nvarchar (**_n_**)** или **nvarchar (max)**.  
  
 — Одна строка, содержащая определения всех параметров, внедренных в *Transact-SQL_batch*. Строка должна представлять собой константу в Юникоде либо переменную в этом же формате. Определение каждого параметра состоит из имени параметра и типа данных. n — заполнитель, указывающий дополнительные определения параметра. Если инструкция или пакет инструкций Transact-SQL в инструкции не содержит параметров, \@ параметр params не требуется. Этот аргумент по умолчанию принимает значение NULL.  
  
 Datatype  
 Тип данных параметра.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 **sp_describe_undeclared_parameters** всегда возвращает нулевое состояние при успешном выполнении. Если процедура вызывает ошибку, а процедура вызвана как RPC, то состояние возврата заполняется типом ошибки, как описано в столбце error_type sys.dm_exec_describe_first_result_set. Если процедура вызывается из [!INCLUDE[tsql](../../includes/tsql-md.md)], возвращаемое значение всегда равно нулю, даже при наличии ошибок.  
  
## <a name="result-sets"></a>Результирующие наборы  
 **sp_describe_undeclared_parameters** возвращает следующий результирующий набор.  
  
|Имя столбца|Тип данных|Описание|  
|-----------------|---------------|-----------------|  
|**parameter_ordinal**|**int NOT NULL**|Содержит порядковый номер параметра в результирующем наборе. Позиция первого параметра будет указана как 1.|  
|**name**|**sysname не равен NULL**|Содержит имя параметра.|  
|**suggested_system_type_id**|**int NOT NULL**|Содержит **system_type_id** типа данных параметра, как указано в таблице sys. types.<br /><br /> Для типов CLR, несмотря на то, что **system_type_name** столбец будет возвращать значение null, этот столбец вернет 240.|  
|**suggested_system_type_name**|**nvarchar (256) NULL**|Содержит имя типа данных. Включает аргументы (длина, точность, масштаб), заданные для типа данных параметра. Если тип данных является пользовательским псевдонимом, то здесь указывается базовый системный тип данных. Если это определяемый пользователем тип данных CLR, то в этом столбце возвращается значение NULL. Если не удается определить тип параметра, возвращается значение NULL.|  
|**suggested_max_length**|**smallint, не РАВНый NULL**|См. статью sys. Columns. для **max_length** описание столбца.|  
|**suggested_precision**|**TINYINT NOT NULL**|См. статью sys. Columns. содержащий описание столбца precision.|  
|**suggested_scale**|**TINYINT NOT NULL**|См. статью sys. Columns. содержащий описание столбца scale.|  
|**suggested_user_type_id**|**int NULL**|Для типов CLR и псевдонимов содержит user_type_id для типа данных столбца, как указано в sys.types. В противном случае значение равно NULL.|  
|**suggested_user_type_database**|**sysname NULL**|Для типов CLR и псевдонимов содержит имя базы данных, в которой этот тип определен. В противном случае значение равно NULL.|  
|**suggested_user_type_schema**|**sysname NULL**|Для типов CLR и псевдонимов содержит имя схемы, в которой этот тип определен. В противном случае значение равно NULL.|  
|**suggested_user_type_name**|**sysname NULL**|Для типов CLR и псевдонимов содержит имя типа. В противном случае значение равно NULL.|  
|**suggested_assembly_qualified_type_name**|**nvarchar (4000) NULL**|Для типов CLR возвращает имя сборки и класса, определяющего тип. В противном случае значение равно NULL.|  
|**suggested_xml_collection_id**|**int NULL**|Содержит xml_collection_id типа данных параметра, как указано в таблице sys. Columns. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_database**|**sysname NULL**|Содержит базу данных, в которой определена коллекция схем XML, связанная с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_schema**|**sysname NULL**|Содержит схему, в которой определена коллекция схем XML, связанная с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_name**|**sysname NULL**|Содержит имя коллекции схем XML, связанной с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_is_xml_document**|**бит не равен NULL**|Возвращает значение 1, если возвращается тип XML и этот тип гарантированно представляет собой XML-документ. В противном случае возвращается 0.|  
|**suggested_is_case_sensitive**|**бит не равен NULL**|Возвращает значение 1, если столбец относится к строковому типу с учетом регистра, либо значение 0 в противном случае.|  
|**suggested_is_fixed_length_clr_type**|**бит не равен NULL**|Возвращает значение 1, если столбец относится к типу CLR с фиксированной длиной, либо значение 0 в противном случае.|  
|**suggested_is_input**|**бит не равен NULL**|Возвращает значение 1, если параметр используется за пределами левой стороны присваивания. В противном случае возвращается 0.|  
|**suggested_is_output**|**бит не равен NULL**|Возвращает значение 1, если параметр используется в левой стороне присваивания или передается в выходной параметр хранимой процедуры. В противном случае возвращается 0.|  
|**formal_parameter_name**|**sysname NULL**|Если параметр служит аргументом хранимой процедуры или определяемой пользователем функции, здесь возвращается имя соответствующего формального параметра. В противном случае возвращается NULL.|  
|**suggested_tds_type_id**|**int NOT NULL**|Для внутреннего использования.|  
|**suggested_tds_length**|**int NOT NULL**|Для внутреннего использования.|  
  
## <a name="remarks"></a>Комментарии  
 **sp_describe_undeclared_parameters** всегда возвращает состояние возврата, равное нулю.  
  
 Чаще всего она применяется, когда приложению передается инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)], которая может содержать параметры и должна некоторым образом их обрабатывать. Примером является пользовательский интерфейс (такой как ODBCTest или RowsetViewer), где пользователь передает запрос с синтаксисом параметров ODBC. Приложение должно динамически обнаруживать число параметров и запрашивать каждый параметр у пользователя.  
  
 Другим примером служит ситуация, где пользователь не вводит данные, а приложение должно просматривать параметры и получать для них данные из другого расположения (из таблицы и т. п.) В этом случае приложение не должно сразу передавать сведения обо всех параметрах. Вместо этого приложение может получить сведения обо всех параметрах от поставщика, а сами данные получить из таблицы. Код, использующий **sp_describe_undeclared_parameters** , является более универсальным и, скорее всего, требует изменения, если структура данных изменяется позже.  
  
 **sp_describe_undeclared_parameters** возвращает ошибку в любом из следующих случаев.  
  
-   Если входной \@ tsql не является допустимым [!INCLUDE[tsql](../../includes/tsql-md.md)] пакетом. Допустимость определяется путем анализа и анализа [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета. Ошибки, вызванные пакетом во время оптимизации запроса или во время выполнения, не учитываются при определении [!INCLUDE[tsql](../../includes/tsql-md.md)] допустимости пакета.  
  
-   Если \@ params не равно NULL и содержит строку, которая не является синтаксически допустимой строкой объявления для параметров, или если она содержит строку, которая объявляет любой параметр более одного раза.  
  
-   Если входной [!INCLUDE[tsql](../../includes/tsql-md.md)] пакет объявляет локальную переменную с тем же именем, что и параметр, объявленный в \@ params.  
  
- Значение, если инструкция ссылается на временные таблицы.

- В запрос включено создание постоянной таблицы, к которой он будет обращен.
  
 Если \@ в TSQL отсутствуют параметры, отличные от объявленных в \@ params, процедура возвращает пустой результирующий набор.  
  
## <a name="parameter-selection-algorithm"></a>Алгоритм выбора параметров  
 Для запроса с необъявленными параметрами выполняется процесс определения типов данных необъявленных параметров, состоящий из трех шагов.  
  
 **Шаг 1**  
  
 Первым шагом определения типов данных для запроса с необъявленными параметрами является поиск типов данных для всех вложенных выражений, типы данных которых не зависят от необъявленных параметров. Тип можно определить для следующих выражений:  
  
-   столбцы, константы, переменные и объявленные параметры;  
  
-   результаты вызова определяемой пользователем функции;  
  
-   выражение с типами данных, не зависящими от необъявленных параметров для всех входов.  
  
 В качестве примера рассмотрим запрос `SELECT dbo.tbl(@p1) + c1 FROM t1 WHERE c2 = @p2 + 2`. Выражения dbo. tbl ( \@ P1) + C1 и C2 имеют типы данных, а Expression \@ P1 и \@ P2 + 2 — нет.  
  
 Если после этого шага любое выражение (кроме вызова определяемой пользователем функции) содержит два аргумента без типов данных, то определение типов завершается с ошибкой. Например, все следующие инструкции вызывают ошибки:  
  
```sql
SELECT * FROM t1 WHERE @p1 = @p2  
SELECT * FROM t1 WHERE c1 = @p1 + @p2  
SELECT * FROM t1 WHERE @p1 = SUBSTRING(@p2, 2, 3)  
```  
  
 В следующем примере не вызывается ошибка:  
  
```sql
SELECT * FROM t1 WHERE @p1 = dbo.tbl(c1, @p2, @p3)  
```
  
 **Шаг 2**  
  
 Для данного необъявленного параметра \@ p алгоритм выведения типа находит внутреннее выражение E ( \@ p), которое содержит \@ p, и является одним из следующих:  
  
-   аргументом оператора сравнения или присваивания;  
  
-   аргументом определяемой пользователем функции (в том числе определяемой пользователем функции, возвращающей табличное значение), процедуры или метода;  
  
-   Аргумент для предложения **Values** инструкции **INSERT** .  
  
-   Аргумент для **приведения** или **преобразования**.  
  
 Алгоритм удержания типов находит целевой тип данных TT ( \@ p) для E ( \@ p). Далее показаны целевые типы данных для предыдущих примеров:  
  
-   тип данных на другой стороне сравнения или присваивания;  
  
-   объявленный тип данных параметра, в который передается этот аргумент;  
  
-   тип данных столбца, в который вставляется это значение;  
  
-   тип данных, к которому приводится или преобразуется инструкция.  
  
 В качестве примера рассмотрим запрос `SELECT * FROM t WHERE @p1 = dbo.tbl(@p2 + c1)`. Затем E ( \@ P1) = \@ P1, E ( \@ P2) = \@ P2 + C1, TT ( \@ P1) — это объявленный тип возвращаемых данных dbo. tbl, а TT ( \@ P2) — это объявленный тип данных параметра для dbo. tbl.  
  
 Если параметр \@ p не содержится ни в одном выражении, перечисленном в начале шага 2, алгоритм выведения типа определяет, что E ( \@ p) является самым большим скалярным выражением, содержащим \@ p, а алгоритм выведения типа не выполняет вычисление целевого типа данных TT (p) \@ для E ( \@ p). Например, если запрос выбран в поле « `@p + 2` E ( \@ p) = \@ p + 2», то отсутствует TT ( \@ p).  
  
 **Шаг 3**  
  
 Теперь, \@ когда определены E (p) и TT ( \@ p), алгоритм выведения типа выводит тип данных для \@ p одним из следующих двух способов:  
  
-   Простое определение  
  
     Если параметр E ( \@ p) = \@ p и TT ( \@ p) существует, т. е. Если \@ p является прямым аргументом для одного из выражений, перечисленных в начале шага 2, алгоритм выведения типа выводит тип данных \@ p в значение TT ( \@ p). Пример:  
  
    ```sql
    SELECT * FROM t WHERE c1 = @p1 AND @p2 = dbo.tbl(@p3)  
    ```  
  
     Тип данных для \@ P1, \@ P2 и \@ P3 будет иметь тип данных C1, тип возвращаемых данных dbo. tbl и тип данных параметра для dbo. tbl соответственно.  
  
     В качестве особого случая, если \@ p является аргументом \<, > \<=, or > оператора, =, простые правила удержания не применяются. Алгоритм определения типов будет использовать общие правила определения, описанные в следующем разделе. Например, если столбец c1 имеет тип данных char(30), рассмотрим следующие два запроса:  
  
    ```sql
    SELECT * FROM t WHERE c1 = @p  
    SELECT * FROM t WHERE c1 > @p  
    ```  
  
     В первом случае алгоритм выведения типа выводит **символ (30)** в качестве типа данных для \@ правила p согласно правилам, приведенным ранее в этом разделе. Во втором случае алгоритм выведения типа выводит **varchar (8000)** в соответствии с общими правилами удержания в следующем разделе.  
  
-   Общее определение  
  
     Если простое определение не действует, то для необъявленных параметров рассматриваются следующие типы данных.  
  
    -   Целочисленные типы данных (**bit**, **tinyint**, **smallint**, **int**, **bigint**)  
  
    -   Типы данных Money (**smallmoney**, **деньги**)  
  
    -   Типы данных с плавающей запятой (**float**, **Real**)  
  
    -   **numeric (38, 19)** — другие числовые или десятичные типы данных не учитываются.  
  
    -   **varchar (8000)**, **varchar (max)**, **nvarchar (4000)** и **nvarchar (max)** — другие типы строковых данных (например, **Text**, **char (8000)**, **nvarchar (30)** и т. д.) не учитываются.  
  
    -   **varbinary (8000)** и **varbinary (max)** — другие двоичные типы данных не рассматриваются (например, **Image**, **binary (8000)**, **varbinary (30)** и т. д.).  
  
    -   **даты**, **время (7)**, **smalldatetime**, **DateTime**, **datetime2 (7)**, **DateTimeOffset (7)** — другие типы даты и времени, такие как **time (4)**, не учитываются.  
  
    -   **sql_variant**  
  
    -   **xml**  
  
    -   Определяемые системой CLR типы (**hierarchyid**, **Geometry**, **Geography**)  
  
    -   Определяемые пользователем типы CLR  
  
### <a name="selection-criteria"></a>Условия выбора  
 Любой тип данных-кандидат, который нарушает допустимость запроса, отклоняется. Из оставшихся кандидатов алгоритм определения типов выбирает один тип данных по следующим правилам.  
  
1.  Выбран тип данных, который создает наименьшее число неявных преобразований в E ( \@ p). Если определенный тип данных создает тип данных для E ( \@ p), отличный от TT ( \@ p), алгоритм выведения типа считает это дополнительным неявным преобразованием из типа данных E ( \@ p) в TT ( \@ p).  
  
     Пример:  
  
    ```sql
    SELECT * FROM t WHERE Col_Int = Col_Int + @p  
    ```  
  
     В этом случае E ( \@ p) имеет Col_Int + \@ p, а TT ( \@ p) — **int**. **int** выбирается для \@ p, так как не создает неявных преобразований. Любой другой выбор типа данных требует не меньше одного неявного преобразования.  
  
2.  Если несколько типов данных имеют минимальное число преобразований, то используется тип данных с максимальным приоритетом. Например.  
  
    ```sql
    SELECT * FROM t WHERE Col_Int = Col_smallint + @p  
    ```  
  
     В этом случае **int** и **smallint** создают одно преобразование. Для любого другого типа данных требуется несколько преобразований. Поскольку **тип int** имеет приоритет над **smallint**, для p используется **int** \@ . Дополнительные сведения о приоритете типов данных см. в разделе [приоритет типов данных &#40;&#41;Transact-SQL ](../../t-sql/data-types/data-type-precedence-transact-sql.md).  
  
     Это правило применяется, только если существует неявное преобразование между каждым из типов, равнозначных по правилу 1, и типом данных с максимальным приоритетом. Если неявное преобразование отсутствует, то определение типа данных завершается с ошибкой. Например, в запросе выведение `SELECT @p FROM t` типа данных завершается неудачей, так как любой тип данных для p будет так \@ же хорошим. Например, отсутствует неявное преобразование из **типа int** в **XML**.  
  
3.  Если два схожих типа данных применяют правило 1, например **varchar (8000)** и **varchar (max)**, выбирается тип данных меньшего размера (**varchar (8000)**). Тот же принцип применим к типам данных **nvarchar** и **varbinary** .  
  
4.  В рамках правила 1 алгоритм определения типов используют различные приоритеты преобразований. Далее показаны преобразования в порядке убывания приоритета.  

    1.  Преобразование между типами с одним базовым типом, имеющими разную длину.  
  
    2.  Преобразование между версиями с фиксированной длиной и переменной длиной с одинаковыми типами данных (например, **char** в **varchar**).  
  
    3.  Преобразование между **null** и **int**.  
  
    4.  Все прочие преобразования.  
  
 Например, для запроса `SELECT * FROM t WHERE [Col_varchar(30)] > @p` выбрано значение **varchar (8000)** , поскольку лучше использовать преобразование (a). Для запроса тип `SELECT * FROM t WHERE [Col_char(30)] > @p` **varchar (8000)** по-прежнему выбирается, так как он вызывает преобразование типа (b), а другой выбор (например, **varchar (4000)**) приведет к преобразованию типа (d).  
  
 В качестве последнего примера при наличии запроса `SELECT NULL + @p` для p выбирается **int** , \@ так как результатом является преобразование типа (c).  
  
## <a name="permissions"></a>Разрешения  
 Требуется разрешение для выполнения \@ аргумента tsql.  
  
## <a name="examples"></a>Примеры  
 В следующем примере возвращаются такие данные, как ожидаемый тип данных для необъявленных параметров `@id` и `@name`.  
  
```sql
sp_describe_undeclared_parameters @tsql =   
N'SELECT object_id, name, type_desc   
FROM sys.indexes  
WHERE object_id = @id OR name = @name'  
  
```  
  
 Если параметр `@id` передается по ссылке `@params`, то параметр `@id` исключается из результирующего набора и описывается только параметр `@name`.  
  
```sql
sp_describe_undeclared_parameters @tsql =   
N'SELECT object_id, name, type_desc   
FROM sys.indexes  
WHERE object_id = @id OR NAME = @name',  
@params = N'@id int'  
  
```  
  
## <a name="see-also"></a>См. также:  
 [sp_describe_first_result_set &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql.md)   
 [sys.dm_exec_describe_first_result_set &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-transact-sql.md)   
 [sys.dm_exec_describe_first_result_set_for_object &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-for-object-transact-sql.md)
