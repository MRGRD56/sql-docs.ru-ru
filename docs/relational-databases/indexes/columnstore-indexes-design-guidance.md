---
description: Руководство по проектированию индексов columnstore
title: Индексы columnstore. Руководство по проектированию | Документы Майкрософт
ms.custom: ''
ms.date: 12/01/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
ms.assetid: fc3e22c2-3165-4ac9-87e3-bf27219c820f
author: MikeRayMSFT
ms.author: mikeray
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: e4cf6107c1e200620f1ba48f4e774c440ccdcd7a
ms.sourcegitcommit: a5398f107599102af7c8cda815d8e5e9a367ce7e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2020
ms.locfileid: "92006621"
---
# <a name="columnstore-indexes---design-guidance"></a>Руководство по проектированию индексов columnstore
[!INCLUDE[SQL Server Azure SQL Database Synapse Analytics PDW ](../../includes/applies-to-version/sql-asdb-asdbmi-asa-pdw.md)]

Общие рекомендации по проектированию индексов columnstore. Немногие принципы проектирования позволяют добиться такого же высокого уровня сжатия данных и производительности запросов, как индексы columnstore. 

## <a name="prerequisites"></a>Предварительные требования

В этой статье предполагается, что вы уже знакомы с архитектурой и терминологией columnstore. Дополнительные сведения см. в статьях, посвященных [обзору индексов columnstore](../../relational-databases/indexes/columnstore-indexes-overview.md) и [их архитектуре](../../relational-databases/sql-server-index-design-guide.md#columnstore_index).

### <a name="know-your-data-requirements"></a>Определение требований к данным
Перед проектированием индекса columnstore постарайтесь как можно лучше разобраться в требованиях к данным. Например, продумайте ответы на следующие вопросы:

- Каков размер таблицы?
- Выполняют ли мои запросы в большинстве случаев анализ со сканированием больших диапазонов значений?  Индексы columnstore позволяют обрабатывать большие диапазоны значений, а не выполнять поиск определенных значений.
- Выполняется ли в моей рабочей нагрузке множество операций обновления и удаления? Индексы columnstore эффективно работают со стабильными данными. Запросы должны обновлять и удалять менее 10 % строк.
- Имеются ли таблицы фактов и измерений для хранилища данных?
- Требуется ли анализ транзакционной рабочей нагрузки? Если такой анализ требуется, см. руководство по проектированию columnstore для операционной аналитики в режиме реального времени.

Индекс columnstore может не пригодиться. Таблицы rowstore с кучами или кластеризованными индексами лучше всего работают с запросами на поиск данных или определенного значения, а также с запросами небольшого диапазона данных. Используйте индексы rowstore с рабочими нагрузками по транзакциям, так как последние чаще требуют поиска по таблицам, а не сканирования таблиц большого диапазона.  

## <a name="choose-the-best-columnstore-index-for-your-needs"></a>Выбор подходящего индекса columnstore

Индекс columnstore бывает кластеризованным или некластеризованным.  Кластеризованный индекс columnstore может включать один или несколько некластеризованных индексов сбалансированного дерева. Индексы columnstore просты в использовании. При создании таблицы в качестве индекса columnstore ее можно легко преобразовать обратно в таблицу rowstore, удалив индекс columnstore. 

Ниже приведена сводка сценариев использования и рекомендаций. 

| Сценарий использования columnstore | Рекомендации по использованию | Сжатие |
| :----------------- | :------------------- | :---------- |
| Кластеризованный индекс columnstore | Используется для:<br></br>1) традиционной рабочей нагрузки хранилища данных со схемой типа "звезда" или "снежинка";<br></br>2) рабочих нагрузок Интернета вещей, вставляющих большие объемы данных с минимальным числом операций обновления и удаления. | Среднее значение: 10-кратное сжатие |
| Некластеризованный индекс сбалансированного дерева в кластеризованном индексе columnstore | Используется для:<br></br>    1. применения ограничений первичного и внешнего ключа в кластеризованном индексе columnstore;<br></br>    2. ускорения запросов на поиск конкретных значений или небольших диапазонов значений;<br></br>    3. ускорения обновления и удаления определенных строк.| Среднее значение: 10-кратное сжатие. Кроме того, требуется дополнительное место хранения для NCI.|
| Некластеризованный индекс columnstore в куче на основе диска или в индексе сбалансированного дерева | Используется для: <br></br>1. Рабочей нагрузки OLTP с запросами аналитики. Вы можете удалить индексы сбалансированного дерева, созданные для анализа, и заменить их одним некластеризованным индексом columnstore.<br></br>2. Множества традиционных рабочих нагрузок OLTP, выполняющих операции извлечения, преобразования и загрузки (ETL) для перемещения данных в отдельное хранилище данных. Чтобы не выполнять операции извлечения, преобразования и загрузки, а также не использовать отдельное хранилище данных, создайте индекс columnstore в некоторых таблицах OLTP. | NCCI — это дополнительный индекс, требующий в среднем на 10 % больше памяти.|
| Индекс columnstore в таблице в памяти | Те же рекомендации, что и для некластеризованного индекса columnstore в таблице на диске, за исключением того, что базовая таблица представляет собой таблицу в памяти. | Индекс columnstore является дополнительным индексом.|

## <a name="use-a-clustered-columnstore-index-for-large-data-warehouse-tables"></a>Использование кластеризованного индекса columnstore для больших таблиц хранилища данных
Кластеризованный индекс — это не просто индекс, это главное хранилище таблиц. Он позволяет достичь высокого уровня сжатия данных и значительно повысить производительность выполнения запросов в больших хранилищах данных и таблицах измерений. Кластеризованные индексы columnstore лучше всего подходят для запросов аналитики, а не транзакционных запросов, так как запросы аналитики, как правило, выполняют операции с большим диапазоном значений, а не поиск определенных значений. 

Используйте кластеризованный индекс columnstore в таких ситуациях:

- В каждой секции есть по крайней мере миллион строк. В индексах columnstore группы строк есть в каждой секции. Если таблица слишком мала для заполнения группы строк в каждой секции, вы не сможете воспользоваться такими преимуществами индекса columnstore, как сжатие и повышение производительности выполнения запросов.
- Как правило, запросы анализируют диапазоны значений. Например, чтобы найти среднее значение столбца, запросу нужно просканировать все значения этого столбца. Затем значения вычисляются путем суммирования, чтобы получить среднее значение.
- Большинство операций вставки выполняется в больших объемах данных с минимальным количеством операций обновления и удаления. Множество рабочих нагрузок, таких как рабочие нагрузки Интернета вещей, вставляют большие объемы данных с минимальным числом операций обновления и удаления. Для этих рабочих нагрузок пригодятся сжатие и повышение производительности выполнения запросов, что обеспечивается при использовании кластеризованного индекса columnstore.

Не используйте кластеризованный индекс columnstore в следующих ситуациях:

* Столбцу требуется тип данных varchar(max), nvarchar(max) или varbinary(max). Спроектируйте индекс columnstore таким образом, чтобы он не включал эти столбцы.
* Данные таблицы не постоянные. Используйте кучу или временную таблицу для быстрого сохранения и удаления данных.
* В таблице содержится меньше миллиона строк на секцию. 
* Обновления и удаления составляют более 10 % операций в таблице. Большое количество операций обновления и удаления вызывает фрагментацию. Фрагментация влияет на степень сжатия и производительность запроса. Операция реорганизации позволяет передать все данные в индекс columnstore и устраняет фрагментацию. Дополнительные сведения см. в статье [Minimizing index fragmentation in columnstore index](/archive/blogs/sqlserverstorageengine/columnstore-index-defragmentation-using-reorganize-command) (Минимизация фрагментации индекса в индексах columnstore).

Дополнительные сведения см. в статье [Columnstore indexes — data warehousing](../../relational-databases/indexes/columnstore-indexes-data-warehouse.md) (Хранилище данных для индексов columnstore).

## <a name="add-b-tree-nonclustered-indexes-for-efficient-table-seeks"></a>Добавление некластеризованных индексов сбалансированного дерева для эффективного поиска в таблице

Начиная с [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)], вы можете создавать некластеризованные индексы сбалансированного дерева как вторичные индексы кластеризованного индекса columnstore. Некластеризованный индекс сбалансированного дерева обновляется при изменении индекса columnstore. Это мощная функция, которую можно использовать в своих интересах. 

Вторичный индекс сбалансированного дерева позволяет выполнять более эффективный поиск определенных строк без сканирования всех строк.  Кроме того, появляется доступ к другим возможностям. Например, можно принудительно задать ограничение первичного или внешнего ключа, применив уникальное ограничение к индексу сбалансированного дерева. Так как неуникальное значение в индекс сбалансированного дерева не вставляется, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не может вставить значение в columnstore. 

Используйте индекс сбалансированного дерева в индексе columnstore в следующих случаях:
* Выполнение запросов на поиск конкретных значений или небольших диапазонов значений.
* Применение ограничений, таких как ограничения первичного или внешнего ключа.
* Эффективное выполнение операций обновления и удаления. Индекс сбалансированного дерева позволяет быстро находить определенные строки, которые следует обновить или удалить, без сканирования всей таблицы или ее секции.
* У вас есть дополнительное место для хранения индекса сбалансированного дерева.

## <a name="use-a-nonclustered-columnstore-index-for-real-time-analytics"></a>Использование некластеризованного индекса columnstore для операционной аналитики в реальном времени

Начиная с выпуска [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)], вам предоставляется некластеризованный индекс columnstore в таблице rowstore на базе диска или в таблице выполняющейся в памяти OLTP. Таким образом, вы можете выполнять анализ в таблице транзакций в режиме реального времени. Хотя транзакции выполняются в базовой таблице, вы можете выполнять анализ в индексе columnstore. Изменения доступны для индекса rowstore и columnstore в режиме реального времени, так как обоими индексами управляет одна таблица.

Так как индекс columnstore обеспечивает уровень сжатия в 10 раз выше, чем индекс rowstore, ему необходимо небольшое дополнительное пространство. Например, если в сжатую таблицу rowstore передается 20 ГБ данных, индексу columnstore может потребоваться 2 ГБ места дополнительно. Объем дополнительного пространства также зависит от числа столбцов в некластеризованном индексе columnstore. 

 Используйте некластеризованный индекс columnstore в таких ситуациях:

* Выполнения анализа в транзакционной таблице rowstore в режиме реального времени. Вы можете заменить имеющиеся индексы сбалансированного дерева, предназначенные для аналитики, на некластеризованный индекс columnstore. 
  
*   Устранение необходимости использования отдельного хранилища данных. В большинстве случаев в компаниях транзакции выполняются в таблице rowstore и данные загружаются в отдельное хранилище для выполнения анализа. Для многих рабочих нагрузок можно исключить процесс загрузки и устранить необходимость использования отдельного хранилища данных, создав некластеризованный индекс columnstore в транзакционных таблицах.

  В [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] предусмотрено несколько стратегий выполнения этого сценария. Они очень просты, так как вы можете включить некластеризованный индекс columnstore, не изменяя приложение OLTP. 

Чтобы добавить дополнительные вычислительные ресурсы, необходимо выполнить анализ на вторичной реплике для чтения, позволяющей отделить обработку транзакционной и аналитической рабочей нагрузки. 

Дополнительные сведения см. в статье [Get started with columnstore indexes for real-time operational analytics](../../relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics.md) (Начало работы с индексами columnstore для получения операционной аналитики в реальном времени).

Дополнительные сведения о выборе подходящего индекса columnstore см. в записи блога Сунила Агарвала (Sunil Agarwal) [Which columnstore index is right for my workload?](/archive/blogs/sql_server_team/columnstore-index-which-columnstore-index-is-right-for-my-workload) (Какие индексы columnstore подходят для моей рабочей нагрузки?).

## <a name="use-table-partitions-for-data-management-and-query-performance"></a>Использование секционированных таблиц для управления данными и повышения производительности запросов
Индексы columnstore поддерживают секционирование, подходящее для управления данными и их архивирования. Секционирование также повышает производительность выполнения запросов путем ограничения операций одной или несколькими секциями.

### <a name="use-partitions-to-make-the-data-easier-to-manage"></a>Упрощение управления данными с помощью секций
В больших таблицах практичнее всего управлять диапазонами данных с помощью секций. Преимущества использования секций для таблиц rowstore также относятся к индексам columnstore. 

Например, при использовании секций в таблицах rowstore и columnstore можно получить следующие преимущества:

- Управление размером добавочных резервных копий. Вы можете создавать резервные копии секций в разных файловых группах и помечать их как доступные только для чтения. При этом во время архивации файловые группы только для чтения будут пропускаться. 
- Снижение затрат на хранение за счет перемещения старых секций в экономичное хранилище. Например, можно выполнить переключение секций, чтобы переместить секцию в экономичное хранилище.
- Эффективное выполнение операций путем их ограничения одной секцией. Например, для обслуживания индекса вы можете назначить только фрагментированные секции.

Кроме того, при использовании секционирования индекса columnstore можно добиться следующего:

* Экономия 30 % затрат на хранение. Вы можете выполнить сжатие старых секций с помощью параметров сжатия COLUMNSTORE_ARCHIVE. Производительность выполнения запроса к данным снизится, что допустимо, если секция редко запрашивается.

### <a name="use-partitions-to-improve-query-performance"></a>Повышение производительности запросов с помощью секций

Используя секции, можно ограничить запросы, чтобы они сканировали только конкретные секции. При этом число сканируемых строк ограничивается. Например, если индекс секционируется по годам, а запрос выполняет анализ прошлогодних данных, запросу нужно просканировать данные всего в одной секции. 

### <a name="use-fewer-partitions-for-a-columnstore-index"></a>Использование нескольких секций для индекса columnstore

Когда объем данных не слишком большой, индекс columnstore позволяет эффективно работать с меньшим количеством секций, чем обычно используется для индекса rowstore. Если у вас нет хотя бы миллиона строк на секцию, большинство строк могут отправляться в дельта-хранилище, где они не получают преимуществ высокой производительности и сжатия, обеспечиваемых индексом columnstore. Например, если загрузить миллион строк в таблицу с 10 секциями по 100 000 строк на каждую, все строки перейдут в разностные группы строк. 

Пример
* Загрузите 1 000 000 строк в одну секцию или в несекционированную таблицу. Вы получите одну сжатую группу строк с 1 000 000 строк. Это удобно для высокого уровня сжатия данных и высокой производительности запросов.
* Загрузите 1 000 000 строк с равномерным распределением по 10 секциям. Каждая секция получает по 100 000 строк. Это значение ниже минимального порога для сжатия columnstore. В результате индекс columnstore может иметь 10 разностных групп строк с 100 000 строк в каждой. Вы можете принудительно передать разностные группы строк в индекс columnstore. Тем не менее, если это единственные строки в индексе columnstore, сжатые группы строк будут слишком малы для максимального сжатия и максимальной производительности запросов.

Дополнительные сведения о секционировании см. в записи блога Сунила Агарвала (Sunil Agarwal) [Should I partition my columnstore index?](/archive/blogs/sqlserverstorageengine/columnstore-index-should-i-partition-my-columnstore-index) (Следует ли секционировать индекс columnstore?).

## <a name="choose-the-appropriate-data-compression-method"></a>Выбор подходящего метода сжатия
Индекс columnstore предлагает два варианта сжатия данных: сжатие columnstore и сжатие архива. Способ сжатия можно выбрать при создании индекса или изменить его позже с помощью инструкции [ALTER INDEX... REBUILD](../../t-sql/statements/alter-index-transact-sql.md).

### <a name="use-columnstore-compression-for-best-query-performance"></a>Повышение производительности запросов при использовании сжатия columnstore
Уровень сжатия индекса columnstore обычно в 10 раз выше, чем уровень сжатия индекса rowstore. Это стандартный способ сжатия для индексов columnstore, повышающий производительность запросов. 

### <a name="use-archive-compression-for-best-data-compression"></a>Высокий уровень сжатия данных при сжатии архива
Сжатие архива позволяет достичь максимального уровня сжатия, если производительность запросов не так важна. По сравнению со сжатием columnstore здесь обеспечивается более высокая степень сжатия данных. Однако этот способ имеет свои недостатки. Сжатие и распаковка данных занимает больше времени, поэтому вы не сможете увеличить производительность запросов. 

## <a name="use-optimizations-when-you-convert-a-rowstore-table-to-a-columnstore-index"></a>Оптимизация при преобразовании таблицы rowstore в индекс columnstore

Если данные уже находятся в таблице rowstore, можно использовать инструкцию [CREATE COLUMNSTORE INDEX](../../t-sql/statements/create-columnstore-index-transact-sql.md) для преобразования таблицы в кластеризованный индекс columnstore. Вы можете оптимизировать производительность запросов после преобразования таблицы, как описано далее.

### <a name="use-maxdop-to-improve-rowgroup-quality"></a>Повышение качества группы строк с помощью MAXDOP
Вы можете настроить максимальное число процессоров для преобразования кучи или кластеризованного индекса сбалансированного дерева в индекс columnstore. Чтобы настроить процессоры, используйте параметр максимальной степени параллелизма (MAXDOP). 

При наличии больших объемов данных не назначайте инструкции MAXDOP значение 1, так как быстродействие существенно не увеличится.  Лучше всего увеличить значение MAXDOP до 4. Если при этом число строк в нескольких группах строк станет неоптимальным, вы можете выполнить инструкцию [ALTER INDEX REORGANIZE](../../t-sql/statements/alter-index-transact-sql.md), чтобы объединить их в фоновом режиме.

### <a name="keep-the-sorted-order-of-a-b-tree-index"></a>Сохранение порядка сортировки индекса сбалансированного дерева
Так как строки в индексе сбалансированного дерева уже хранятся в порядке сортировки, сохранение этого порядка при сжатии строк в индекс columnstore может повысить производительность запросов.

Индекс columnstore не сортирует данные, но он использует метаданные для отслеживания минимального и максимального значения каждого сегмента столбца в каждой группе строк.  При сканировании диапазона значений индекс быстро определяет группу строк, которую можно пропустить. Если данные упорядочены, он может пропустить несколько групп строк. 

Чтобы сохранить порядок сортировки во время преобразования, сделайте следующее:
* Используйте инструкцию [CREATE COLUMNSTORE INDEX](../../t-sql/statements/create-columnstore-index-transact-sql.md) с предложением DROP_EXISTING. При этом также сохраняется имя индекса. Если у вас есть скрипты, использующие имя индекса rowstore, их не потребуется обновлять. 

    В этом примере кластеризованный индекс rowstore в таблице `MyFactTable` преобразуется в кластеризованный индекс columnstore. Имя индекса, `ClusteredIndex_d473567f7ea04d7aafcac5364c241e09`, не изменяется.

    ```sql
    CREATE CLUSTERED COLUMNSTORE INDEX ClusteredIndex_d473567f7ea04d7aafcac5364c241e09  
    ON MyFactTable  
    WITH (DROP_EXISTING = ON);  
    ```

## <a name="related-tasks"></a>Связанные задачи  
Ниже перечислены задачи для создания и обслуживания индексов columnstore. 
  
|Задача|Справочные разделы|Примечания|  
|----------|----------------------|-----------|  
|Создание таблицы как кластеризованного индекса columnstore|[CREATE TABLE (Transact-SQL)](../../t-sql/statements/create-table-transact-sql.md)|Начиная с версии [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)], таблицы можно создавать как кластеризованный индекс columnstore. Для этого не нужно создавать таблицу rowstore, а затем конвертировать ее в columnstore.|  
|Создание таблицы в памяти с индексом columnstore.|[CREATE TABLE (Transact-SQL)](../../t-sql/statements/create-table-transact-sql.md)|Начиная с версии [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)], таблицы, оптимизированные для памяти, можно создавать с индексом columnstore. Индекс columnstore можно добавить и после создания таблицы, используя синтаксис ALTER TABLE ADD INDEX.|  
|Преобразование таблицы rowstore в таблицу columnstore|[CREATE COLUMNSTORE INDEX (Transact-SQL)](../../t-sql/statements/create-columnstore-index-transact-sql.md)|Преобразуйте существующую кучу или сбалансированное дерево в columnstore. В примерах показано, как обрабатывать существующие индексы, а также имя индекса, которое нужно использовать в процессе преобразования.|  
|Преобразование таблицы columnstore в rowstore|[CREATE CLUSTERED INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/create-columnstore-index-transact-sql.md#d-convert-a-columnstore-table-to-a-rowstore-table-with-a-clustered-index) или [Преобразование таблицы columnstore обратно в кучу rowstore](../../t-sql/statements/create-columnstore-index-transact-sql.md#e-convert-a-columnstore-table-back-to-a-rowstore-heap) |Обычно это преобразование не требуется, но бывают ситуации, когда оно необходимо. В примерах показано, как преобразовать columnstore в кучу или кластеризованный индекс.|   
|Создание индекса columnstore в таблице rowstore|[CREATE COLUMNSTORE INDEX (Transact-SQL)](../../t-sql/statements/create-columnstore-index-transact-sql.md)|Таблица rowstore может включать один индекс columnstore.  Начиная с версии [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)], индекс columnstore может иметь отфильтрованное условие. В примерах показан основной синтаксис.|  
|Создание высокопроизводительных индексов для оперативной аналитики|[Начало работы с Columnstore для получения операционной аналитики в реальном времени](../../relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics.md)|Описывает процесс создания дополнительных индексов columnstore и сбалансированного дерева, которые позволят использовать индексы сбалансированного дерева в запросах OLTP и индексы columnstore в запросах аналитики.|  
|Создание высокопроизводительных индексов сolumnstore для хранилищ данных|[Columnstore indexes — data Warehousing](../../relational-databases/indexes/columnstore-indexes-data-warehouse.md) (Хранилище данных для индексов columnstore)|Описывает использование индексов сбалансированного дерева в таблицах columnstore для создания высокопроизводительных запросов к хранилищу данных.|  
|Использование индекса сбалансированного дерева для принудительного применения ограничения первичного ключа к индексу columnstore.|[Columnstore indexes — data Warehousing](../../relational-databases/indexes/columnstore-indexes-data-warehouse.md) (Хранилище данных для индексов columnstore)|Показано, как объединить индексы сбалансированного дерева и columnstore для принудительного применения ограничений первичного ключа к индексу columnstore.|  
|Удаление индекса columnstore.|[DROP INDEX (Transact-SQL)](../../t-sql/statements/drop-index-transact-sql.md)|Для удаления индекса columnstore используется стандартный синтаксис DROP INDEX, применяемый индексами сбалансированного дерева. При удалении кластеризованного индекса columnstore таблица columnstore преобразуется в кучу.|  
|Удаление строки из индекса columnstore|[DELETE (Transact-SQL)](../../t-sql/statements/delete-transact-sql.md)|Используйте синтаксис [DELETE (Transact-SQL)](../../t-sql/statements/delete-transact-sql.md) для удаления строки.<br /><br /> Строка**columnstore** : [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] помечает строку как логически удаленную, но не возвращает физическое хранилище для строки до тех пор, пока индекс не будет перестроен.<br /><br /> Строка**deltastore** : [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] логически и физически удаляет строку.|  
|Обновление строки в индексе columnstore|[UPDATE (Transact-SQL)](../../t-sql/queries/update-transact-sql.md)|Используйте синтаксис [UPDATE (Transact-SQL)](../../t-sql/queries/update-transact-sql.md) для обновления строки.<br /><br /> Строка**columnstore** :  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] помечает строку как логически удаленную, а затем вставляет обновленную строку в deltastore.<br /><br /> Строка**deltastore** : [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обновляет строку в deltastore.|  
|Принудительное перемещение всех строк из deltastore в columnstore|[ALTER INDEX (Transact-SQL)](../../t-sql/statements/alter-index-transact-sql.md) ... REBUILD<br /><br /> [Реорганизация и перестроение индексов](../../relational-databases/indexes/reorganize-and-rebuild-indexes.md)|Инструкция ALTER INDEX с параметром REBUILD перемещает все строки в columnstore.|  
|Дефрагментация индекса columnstore|[ALTER INDEX (Transact-SQL)](../../t-sql/statements/alter-index-transact-sql.md)|ALTER INDEX ... REORGANIZE дефрагментирует индексы columnstore в оперативном режиме.|  
|Слияние таблиц с индексами columnstore.|[MERGE (Transact-SQL)](../../t-sql/statements/merge-transact-sql.md)|

## <a name="next-steps"></a>Дальнейшие действия
Чтобы создать пустой индекс columnstore для:

* [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] или [!INCLUDE[ssSDS](../../includes/sssds-md.md)] — см. статью [CREATE TABLE (Transact-SQL)](../../t-sql/statements/create-table-transact-sql.md);
* [!INCLUDE[ssSDW](../../includes/sssdw-md.md)] — см. статью [CREATE TABLE (Azure Synapse Analytics)](../../t-sql/statements/create-table-as-select-azure-sql-data-warehouse.md).

Дополнительные сведения о преобразовании имеющейся кучи rowstore или индекса сбалансированного дерева в кластеризованный индекс columnstore или о создании некластеризованного индекса columnstore см. в статье [CREATE COLUMNSTORE INDEX (Transact-SQL)](../../t-sql/statements/create-columnstore-index-transact-sql.md).