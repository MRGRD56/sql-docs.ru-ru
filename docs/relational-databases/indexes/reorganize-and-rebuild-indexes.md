---
title: Обнаружение и разрешение фрагментированных индексов | Документация Майкрософт
description: В этой статье описывается, как происходит фрагментация индекса, определяется объем фрагментации и рассказывается, как лучше всего разрешить фрагментацию индекса с помощью T-SQL и SQL Server Management Studio.
ms.custom: ''
ms.date: 03/19/2020
ms.prod: sql
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.technology: table-view-index
ms.topic: conceptual
f1_keywords:
- sql13.swb.index.rebuild.f1
- sql13.swb.indexproperties.fragmentation.f1
- sql13.swb.index.reorg.f1
helpviewer_keywords:
- large object defragmenting
- indexes [SQL Server], reorganizing
- index reorganization [SQL Server]
- reorganizing indexes
- defragmenting large object data types
- index fragmentation [SQL Server]
- index rebuilding [SQL Server]
- rebuilding indexes
- indexes [SQL Server], rebuilding
- defragmenting indexes
- nonclustered indexes [SQL Server], defragmenting
- fragmentation [SQL Server]
- index defragmenting [SQL Server]
- LOB data [SQL Server], defragmenting
- clustered indexes, defragmenting
ms.assetid: a28c684a-c4e9-4b24-a7ae-e248808b31e9
author: pmasl
ms.author: mikeray
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: ba0eb3c9907acfe02939c49ea253869adbfc992b
ms.sourcegitcommit: 4d370399f6f142e25075b3714e5c2ce056b1bfd0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2020
ms.locfileid: "91867345"
---
# <a name="resolve-index-fragmentation-by-reorganizing-or-rebuilding-indexes"></a>Разрешение фрагментации индекса путем реорганизации или перестроения индекса

[!INCLUDE[SQL Server Azure SQL Database Synapse Analytics PDW ](../../includes/applies-to-version/sql-asdb-asdbmi-asa-pdw.md)]

В этой статье описывается, как происходит дефрагментация индекса, и обсуждается ее влияние на производительность запросов. Определив [объем фрагментации, существующий для индекса](#detecting-the-amount-of-fragmentation), можно выполнить дефрагментацию индекса, [реорганизовав индекс](#reorganize-an-index) или [перестроив индекс](#rebuild-an-index) с помощью команд Transact-SQL в выбранном вами средстве или с помощью SQL Server Management Studio.

## <a name="index-fragmentation-overview"></a>Общие сведения о фрагментации индексов

Что такое фрагментация индексов и зачем она нужна?

- Фрагментация имеет место в тех случаях, когда в индексах содержатся страницы, для которых логический порядок, основанный на значении ключа, не совпадает с физическим порядком на страницах индексов.
- [!INCLUDE[ssde_md](../../includes/ssde_md.md)] автоматически изменяет индексы при вставке, обновлении или удалении базовых данных. Например, добавление строк в таблицу может привести к разбиению существующих страниц в индексах rowstore, чтобы освободить место для вставки новых значений ключей. Со временем эти изменения могут привести к тому, что данные в индексе окажутся разбросанными по базе данных (фрагментированными). Фрагментация имеет место в тех случаях, когда в индексах содержатся страницы, для которых логический порядок, основанный на значении ключа, не совпадает с физическим порядком в файле данных.
- Значительно фрагментированные индексы могут снизить производительность запросов, так как для поиска данных, на которые указывает индекс, требуются дополнительные операции ввода-вывода. Дополнительные операции ввода-вывода приводят к медленному реагированию приложения, особенно если задействованы операции сканирования.

## <a name="detecting-the-amount-of-fragmentation"></a>Определение объема фрагментации

Первым шагом в определении того, какой метод дефрагментации индекса следует использовать, будет анализ индекса на предмет степени фрагментации. Фрагментация в индексах rowstore и columnstore определяется по-разному.

> [!NOTE]
> Особенно важно проверить фрагментацию индекса или кучи после удаления больших объемов данных. При большой частоте обновления для куч может также потребоваться проверить фрагментацию, чтобы избежать распространения пересылаемых записей. Дополнительные сведения о кучах см. в разделе [Кучи (таблицы без кластеризованных индексов)](../../relational-databases/indexes/heaps-tables-without-clustered-indexes.md#heap-structures). 

### <a name="detecting-fragmentation-of-rowstore-indexes"></a>Выявление фрагментации индексов rowstore

Функция [sys.dm_db_index_physical_stats](../../relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql.md) позволяет выявить фрагментацию конкретного индекса, всех индексов в таблице или индексированном представлении, всех индексов в базе данных или всех индексов во всех базах данных. Для секционированных индексов **sys.dm_db_index_physical_stats** также предоставляет сведения о фрагментации каждой секции.

Результирующий набор, возвращаемый функцией **sys.dm_db_index_physical_stats**, включает следующие столбцы.

|Столбец|Описание|
|------------|-----------------|
|**avg_fragmentation_in_percent**|Процентная доля логической фрагментации (неупорядоченные страницы в индексе).|
|**fragment_count**|Число фрагментов (физически последовательные конечные страницы) в индексе.|
|**avg_fragment_size_in_pages**|Среднее число страниц в одном фрагменте индекса.|

Выяснив степень фрагментации, используйте нижеследующую таблицу для определения наиболее подходящего метода устранения фрагментации: [INDEX REORGANIZE](#reorganize-an-index) или [INDEX](#rebuild-an-index).

|Значение**avg_fragmentation_in_percent**|Корректирующая инструкция|
|-----------------------------------------------|--------------------------|
|> 5 % и < = 30 % <sup>1</sup>|ALTER INDEX REORGANIZE|
|> 30 % <sup>1</sup>|ALTER INDEX REBUILD WITH (ONLINE = ON) <sup>2</sup>|

<sup>1</sup> Эти значения дают примерное представление об определении точки, в которой необходимо переключаться между `ALTER INDEX REORGANIZE` и `ALTER INDEX REBUILD`. Однако фактические значения могут различаться в каждом конкретном случае. Важно определить наилучшее пороговое значение для используемой среды экспериментальным путем.      

> [!TIP] 
> Например, если индекс используется преимущественно для операций сканирования, устранение фрагментации позволяет повысить производительность при их выполнении. Выигрыш в производительности может быть незаметен в случае с индексами, которые используются в первую очередь для операций поиска.    
Аналогичным образом устранение фрагментации в куче (таблице без кластеризованного индекса) особенно полезно для операций сканирования некластеризованного индекса, но мало влияет на операции поиска.

<sup>2</sup> Индекс может быть перестроен как в режиме "в сети", так и в режиме "вне сети". Реорганизация индекса всегда выполняется в режиме "в сети". Чтобы добиться доступности, подобной варианту с реорганизацией, следует перестраивать индексы в режиме "в сети". Дополнительные сведения см. в статье [INDEX](#rebuild-an-index) и [Выполнение операции с индексами в сети](../../relational-databases/indexes/perform-index-operations-online.md).

Индексы с фрагментацией менее 5 % не нуждаются в дефрагментации, так как выгода от дефрагментации столь низкого уровня почти всегда в достаточной степени компенсируется ЦП за счет реорганизации или перестроения индекса. Кроме того, перестроение или реорганизация малых индексов rowstore обычно не приводит к понижению фактического уровня фрагментации. До версии [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] включительно [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] выделяет пространство с помощью смешанных экстентов. Поэтому страницы индексов малого размера иногда хранятся в смешанных экстентах. Смешанные экстенты могут находиться в общем пользовании у восьми объектов, поэтому фрагментацию в малом индексе нельзя уменьшить путем его реорганизации или перестроения. См. также [Вопросы, связанные с перестроением индексов columnstore](#considerations-specific-to-rebuilding-rowstore-indexes). Дополнительные сведения об экстентах см. в разделе [Руководство по архитектуре страниц и экстентов](../../relational-databases/pages-and-extents-architecture-guide.md#extents).

### <a name="detecting-fragmentation-of-columnstore-indexes"></a>Выявление фрагментации индексов columnstore

С помощью функции [sys.dm_db_column_store_row_group_physical_stats](../../relational-databases/system-dynamic-management-views/sys-dm-db-column-store-row-group-physical-stats-transact-sql.md) можно определить процент удаленных строк в индексе, что служит приемлемым показателем фрагментации в группе строк в индексе columnstore. С помощью этих сведений можно вычислить фрагментацию в определенном индексе, всех индексах в таблице, всех индексах в базе данных или всех индексах во всех базах данных.

Результирующий набор, возвращаемый функцией **sys.dm_db_column_store_row_group_physical_stats**, включает следующие столбцы.

|Столбец|Описание|
|------------|-----------------|
|**total_rows**|Количество строк, которые физически хранятся в группе строк. Для сжатых групп строк учитываются строки, помеченные как удаленные.|
|**deleted_rows**|Количество строк, физически хранящихся в сжатой группе строк и помеченных для удаления. Для групп строк, которые находятся в разностном хранилище, значение равно 0.|

Используйте эти сведения для вычисления фрагментации индексов с помощью следующей формулы:

```
100*(ISNULL(deleted_rows,0))/NULLIF(total_rows,0)
```

Выяснив степень фрагментации индексов, используйте нижеследующую таблицу для определения наиболее подходящего метода устранения фрагментации: [INDEX REORGANIZE](#reorganize-an-index) или [INDEX](#rebuild-an-index).

|Значение **вычисленной фрагментации в процентах**|Применимо к версии|Корректирующая инструкция|
|-----------------------------------------------|--------------------------|--------------------------|
|> = 20 %|[!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] и [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)]|ALTER INDEX REBUILD|
|> = 20 %|Начиная с [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)]|ALTER INDEX REORGANIZE|

### <a name="to-check-the-fragmentation-of-a-rowstore-index-using-tsql"></a>Проверка фрагментации индекса rowstore с помощью [!INCLUDE[tsql](../../includes/tsql-md.md)]

В приведенном ниже примере рассчитывается средний процент фрагментации всех индексов в таблице `HumanResources.Employee` базы данных `AdventureWorks2016`.

```sql
SELECT a.object_id, object_name(a.object_id) AS TableName,
    a.index_id, name AS IndedxName, avg_fragmentation_in_percent
FROM sys.dm_db_index_physical_stats
    (DB_ID (N'AdventureWorks2016_EXT')
        , OBJECT_ID(N'HumanResources.Employee')
        , NULL
        , NULL
        , NULL) AS a
INNER JOIN sys.indexes AS b
    ON a.object_id = b.object_id
    AND a.index_id = b.index_id;
GO
```

Предыдущая инструкция возвращает результирующий набор, как показано ниже.

```
object_id   TableName    index_id    IndexName                                             avg_fragmentation_in_percent
----------- ------------ ----------- ----------------------------------------------------- ------------------------------
1557580587  Employee     1           PK_Employee_BusinessEntityID                          0
1557580587  Employee     2           IX_Employee_OrganizationalNode                        0
1557580587  Employee     3           IX_Employee_OrganizationalLevel_OrganizationalNode    0
1557580587  Employee     5           AK_Employee_LoginID                                   66.6666666666667
1557580587  Employee     6           AK_Employee_NationalIDNumber                          50
1557580587  Employee     7           AK_Employee_rowguid                                   0

(6 row(s) affected)
```

Подробные сведения см. в статье [sys.dm_db_index_physical_stats (Transact-SQL)](../../relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql.md).

### <a name="to-check-the-fragmentation-of-a-columnstore-index-using-tsql"></a>Проверка фрагментации индекса columnstore с помощью [!INCLUDE[tsql](../../includes/tsql-md.md)]

В приведенном ниже примере рассчитывается средний процент фрагментации всех индексов в таблице `dbo.FactResellerSalesXL_CCI` базы данных `AdventureWorksDW2016`.

```sql
SELECT i.object_id,
    object_name(i.object_id) AS TableName,
    i.index_id,
    i.name AS IndexName,
    100*(ISNULL(SUM(CSRowGroups.deleted_rows),0))/NULLIF(SUM(CSRowGroups.total_rows),0) AS 'Fragmentation'
FROM sys.indexes AS i  
INNER JOIN sys.dm_db_column_store_row_group_physical_stats AS CSRowGroups
    ON i.object_id = CSRowGroups.object_id
    AND i.index_id = CSRowGroups.index_id
WHERE object_name(i.object_id) = 'FactResellerSalesXL_CCI'
GROUP BY i.object_id, i.index_id, i.name
ORDER BY object_name(i.object_id), i.name;
```

Предыдущая инструкция возвращает результирующий набор, как показано ниже.

```
object_id   TableName                   index_id    IndexName                       Fragmentation
----------- --------------------------- ----------- ------------------------------- ---------------
114099447   FactResellerSalesXL_CCI     1           IndFactResellerSalesXL_CCI      0

(1 row(s) affected)
```

### <a name="check-index-fragmentation-using-sql-server-management-studio"></a>Проверка фрагментации индекса с помощью среды SQL Server Management Studio

> [!NOTE]
> [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)] не может использоваться для расчета фрагментации индексов columnstore в SQL Server и не может использоваться для расчета фрагментации любых индексов в базе данных SQL Azure. Используйте предыдущий [!INCLUDE[tsql](../../includes/tsql-md.md)] [пример](#to-check-the-fragmentation-of-a-columnstore-index-using-) в этих сценариях.

1. В обозревателе объектов разверните базу данных, содержащую таблицу, в которой необходимо проверить фрагментацию индекса.
2. Разверните папку **Таблицы**.
3. Разверните таблицу, в которой нужно проверить фрагментацию индекса.
4. Разверните папку **Индексы**.
5. Щелкните правой кнопкой мыши индекс, для которого нужно проверить фрагментацию, и выберите пункт **Свойства**.
6. В разделе **Выбор страницы**выберите пункт **Фрагментация**.

На странице **Фрагментация** доступны следующие сведения.

|Значение|Описание|
|---|---|
|**Заполненность страниц**|Отображает среднее заполнение страниц индекса, в процентах. 100 % означает, что страницы индекса полностью заполнены. 50 % означает, что каждая страница индекса заполнена в среднем наполовину.|
|**Общая фрагментация**|Процент логической фрагментации. Отображает количество страниц индекса, хранимых не в порядке.|
|**Средний размер строки**|Средний размер строки конечного уровня.|
|**Глубина**|Количество уровней индекса, включая конечный уровень.|
|**Перенаправленные записи**|Количество записей в куче, содержащих указатели на данные в других местах. (Такое состояние возникает во время обновления, когда не хватает места для сохранения новой строки в исходном расположении.)|
|**Фантомные строки**|Количество строк, помеченных как удаленных, но еще фактически не удаленных. Эти строки будут удалены потоком очистки, когда сервер будет не загружен. Это значение не включает в себя строки, сохраняемые из-за ожидающей выполнения транзакции изоляции моментальных снимков.|
|**Тип индекса**|Тип индекса. Возможными значениями являются **Кластеризованный индекс**, **Некластеризованный индекс**и **Первичный XML**. Таблицы могут также сохраняться в виде кучи (без индексов), однако после этого данная страница «Свойства индекса» не может быть открыта.|
|**Строки конечного уровня**|Количество строк конечного уровня.|
|**Максимальный размер строки**|Максимальный размер строки конечного уровня.|
|**Минимальный размер строки**|Минимальный размер строки конечного уровня.|
|**Страницы**|Общее число страниц данных.|
|**Partition ID**|Идентификатор секции сбалансированного дерева, содержащего индекс.|
|**Фантомные строки версии**|Количество фантомных записей, которые сохраняются в памяти из-за незавершенной транзакции изоляции моментального снимка.|

## <a name="defragmenting-indexes-by-rebuilding-or-reorganizing-the-index"></a>Дефрагментация индексов путем перестроения или реорганизации индекса

Вы дефрагментировали фрагментированный индекс одним из следующих способов:

- Реорганизация индекса
- Перестроение индекса

> [!NOTE]
> Для секционированных индексов, построенных на основе схемы секционирования, можно использовать любой из следующих методов для всего индекса или отдельной его секции.

### <a name="reorganize-an-index"></a>Реорганизация индекса

При реорганизации индекса используется минимальный объем системных ресурсов. Эта операция выполняется в оперативном режиме. Это означает, что долгосрочные блокировки таблицы не удерживаются и запросы или обновления базовой таблицы могут продолжаться во время выполнения транзакции `ALTER INDEX REORGANIZE`.

- Для [индексов rowstore](clustered-and-nonclustered-indexes-described.md) [!INCLUDE[ssde_md](../../includes/ssde_md.md)] дефрагментирует конечный уровень кластеризованных и некластеризованных индексов в таблицах и представлениях путем физической реорганизации страниц конечного уровня. В результате они выстраиваются в соответствии с логическим порядком конечных объектов (слева направо). При реорганизации страницы индекса также сжимаются на основе значения коэффициента заполнения индекса. Увидеть коэффициент заполнения можно в таблице [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md). Примеры синтаксиса см. в разделе [Примеры. Реорганизация rowstore](../../t-sql/statements/alter-index-transact-sql.md#examples-rowstore-indexes).

- При использовании [индексов columnstore](columnstore-indexes-overview.md) в разностном хранилище может иметься несколько небольших групп строк после вставки, обновления и удаления данных с течением времени. При реорганизации индекса columnstore все группы строк принудительно отправляются в columnstore, а затем объединяются в меньшее число групп строк с большим количеством строк внутри. Операция реорганизации также приведет к удалению строк, которые были удалены из columnstore. Реорганизация изначально потребует дополнительных ресурсов ЦП для сжатия данных, что может снизить общую производительность системы. Однако после сжатия данных производительность запросов возрастает. Примеры синтаксиса см. в разделе [Примеры. Реорганизация columnstore](../../t-sql/statements/alter-index-transact-sql.md#examples-columnstore-indexes).

### <a name="rebuild-an-index"></a>Перестроение индекса

При перестроении старый индекс удаляется, и создается новый. В зависимости от типа индекса и версии [!INCLUDE[ssde_md](../../includes/ssde_md.md)] операция перестроения может выполняться в оперативном или автономном режиме. Синтаксис T-SQL см. в разделе [ALTER INDEX REBUILD](../../t-sql/statements/alter-index-transact-sql.md#rebuilding-indexes)

- Для [индексов rowstore](clustered-and-nonclustered-indexes-described.md) при перестроении устраняется фрагментация, восстанавливается место на диске путем сжатия страниц с учетом указанного или существующего коэффициента заполнения и переупорядочиваются индексные строки в последовательных страницах. Если `ALL` указано, то все индексы в таблице удаляются и перестраиваются в ходе одной транзакции. Ограничения FOREIGN KEY не обязательно отменять заранее. Если перестраиваются индексы с 128 или большим числом экстентов, то компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] откладывает процедуры освобождения страниц и связанные с ними блокировки до фиксации транзакции. Примеры синтаксиса см. в разделе [Примеры. Реорганизация rowstore](../../t-sql/statements/alter-index-transact-sql.md#examples-rowstore-indexes).

- Для [индексов columnstore](columnstore-indexes-overview.md) при перестроении устраняется фрагментация, все строки перемещаются в columnstore и освобождается место на диске за счет физического удаления строк, которые логически удалены из таблицы. 
  
  > [!TIP]
  > Начиная с [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] перестраивать индекс columnstore обычно не требуется, так как инструкция `REORGANIZE` выполняет необходимые для перестройки действия в фоновом и оперативном режиме. 
  
  Примеры синтаксиса см. в разделе [Примеры. Перестройка ColumnStore](../../t-sql/statements/alter-index-transact-sql.md#examples-columnstore-indexes).

### <a name="permissions"></a><a name="Permissions"></a> Permissions

Необходимо разрешение `ALTER` для таблицы или представления. Пользователь должен входить хотя бы в одну из следующих ролей:

- роль базы данных **db_ddladmin**<sup>1</sup>;
- роль базы данных **db_owner**;
- роль сервера **sysadmin**;

<sup>1</sup>Роль базы данных **db_ddladmin** — [наименее привилегированная](/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models).

### <a name="remove-fragmentation-using-ssmanstudiofull"></a><a name="SSMSProcedureReorg"></a> Устранение фрагментации с помощью [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]

#### <a name="to-reorganize-or-rebuild-an-index"></a>Реорганизация или перестроение индекса

1. В обозревателе объектов разверните базу данных, содержащую таблицу, в которой необходимо реорганизовать индекс.
2. Разверните папку **Таблицы**.
3. Разверните таблицу, в которой нужно реорганизовать индекс.
4. Разверните папку **Индексы**.
5. Щелкните правой кнопкой мыши индекс, который требуется реорганизовать, и выберите пункт **Реорганизовать**.
6. В диалоговом окне **Реорганизация индексов** убедитесь, что нужный индекс приведен в сетке **Индексы для реорганизации** , и нажмите кнопку **ОК**.
7. Установите флажок **Сжать данные в столбцах больших объектов** , чтобы указать, что также сжимаются все страницы, содержащие данные больших объектов.
8. Нажмите кнопку **ОК.**

#### <a name="to-reorganize-all-indexes-in-a-table"></a>Реорганизация всех индексов в таблице

1. В обозревателе объектов разверните базу данных, содержащую таблицу, в которой необходимо реорганизовать индексы.
2. Разверните папку **Таблицы**.
3. Разверните таблицу, в которой нужно реорганизовать индексы.
4. Щелкните правой кнопкой мыши папку **Индексы** и выберите команду **Реорганизовать все**.
5. В диалоговом окне **Реорганизация индексов** убедитесь, что нужные индексы приведены в сетке **Индексы для реорганизации**. Для удаления индекса из сетки **Индексы для реорганизации** выделите индекс и нажмите клавишу DELETE.
6. Установите флажок **Сжать данные в столбцах больших объектов** , чтобы указать, что также сжимаются все страницы, содержащие данные больших объектов.
7. Нажмите кнопку **ОК.**

#### <a name="to-rebuild-an-index"></a>Перестроение индекса

1. В обозревателе объектов разверните базу данных, содержащую таблицу, в которой необходимо реорганизовать индекс.
2. Разверните папку **Таблицы**.
3. Разверните таблицу, в которой нужно реорганизовать индекс.
4. Разверните папку **Индексы**.
5. Щелкните правой кнопкой мыши индекс, который требуется реорганизовать, и выберите команду **Перестроить**.
6. В диалоговом окне **Перестроение индексов** убедитесь, что нужный индекс приведен в сетке **Индексы для перестроения**, и нажмите кнопку **ОК**.
7. Установите флажок **Сжать данные в столбцах больших объектов** , чтобы указать, что также сжимаются все страницы, содержащие данные больших объектов.
8. Нажмите кнопку **ОК.**

### <a name="remove-fragmentation-using-tsql"></a><a name="TsqlProcedureReorg"></a> Устранение фрагментации с помощью [!INCLUDE[tsql](../../includes/tsql-md.md)]

> [!NOTE]
> Дополнительные примеры использования [!INCLUDE[tsql](../../includes/tsql-md.md)] для перестроения или реорганизации индексов см. в разделе [Примеры: индексы columnstore](../../t-sql/statements/alter-index-transact-sql.md#examples-columnstore-indexes) и [Примеры: индексы rowstore](../../t-sql/statements/alter-index-transact-sql.md#examples-rowstore-indexes).

#### <a name="to-reorganize-a-fragmented-index"></a>Реорганизация фрагментированного индекса

В приведенном ниже примере показано, как реорганизовать индекс `IX_Employee_OrganizationalLevel_OrganizationalNode` в таблице `HumanResources.Employee` базы данных `AdventureWorks2016`.

```sql
ALTER INDEX IX_Employee_OrganizationalLevel_OrganizationalNode
    ON HumanResources.Employee
    REORGANIZE;
```

В приведенном ниже примере показано, как реорганизовать индекс columnstore `IndFactResellerSalesXL_CCI` в таблице `dbo.FactResellerSalesXL_CCI` базы данных `AdventureWorksDW2016`.

```sql
-- This command will force all CLOSED and OPEN rowgroups into the columnstore.
ALTER INDEX IndFactResellerSalesXL_CCI
    ON FactResellerSalesXL_CCI
    REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON);
```

#### <a name="to-reorganize-all-indexes-in-a-table"></a>Реорганизация всех индексов в таблице

В приведенном ниже примере показано, как реорганизовать все индексы в таблице `HumanResources.Employee` базы данных `AdventureWorks2016`.

```sql
ALTER INDEX ALL ON HumanResources.Employee
   REORGANIZE;
```

#### <a name="to-rebuild-a-fragmented-index"></a>Перестройка фрагментированного индекса

В следующем примере показано, как перестроить единственный индекс на таблице `Employee` базы данных `AdventureWorks2016`.

[!code-sql[IndexDDL#AlterIndex1](../../relational-databases/indexes/codesnippet/tsql/reorganize-and-rebuild-i_1.sql)]

#### <a name="to-rebuild-all-indexes-in-a-table"></a>Перестроение всех индексов в таблице

В приведенном ниже примере показано, как перестроить все индексы, связанные с таблицей базы данных `AdventureWorks2016`, используя ключевое слово `ALL`. Указываются три параметра.

[!code-sql[IndexDDL#AlterIndex2](../../relational-databases/indexes/codesnippet/tsql/reorganize-and-rebuild-i_2.sql)]

Дополнительные сведения см. в разделе [ALTER INDEX (Transact-SQL)](../../t-sql/statements/alter-index-transact-sql.md).

#### <a name="automatic-index-and-statistics-management"></a>Автоматическое управление индексами и статистикой

Используйте такие решения, как [Адаптивная дефрагментация индексов](https://github.com/Microsoft/tigertoolbox/tree/master/AdaptiveIndexDefrag), чтобы автоматически управлять дефрагментацией индексов и обновлениями статистики для одной базы данных или нескольких. Эта процедура автоматически выбирает, следует ли перестроить или реорганизовать индекс, сверяясь с уровнем фрагментации и другими параметрами, и обновляет статистику на основе линейных пороговых значений.

## <a name="considerations-specific-to-rebuilding-rowstore-indexes"></a>Вопросы, связанные с перестроением индексов columnstore

Перестроение кластеризованного индекса автоматически приводит к перестроению всех некластеризованных индексов, на которые ссылается ключ кластеризации, если физические или логические идентификаторы в записях некластеризованного индекса должны изменяться.

Автоматическое перестроение всех некластеризованных индексов rowstore в таблице происходит в следующих случаях:

- создание кластеризованного индекса для таблицы;
- удаление кластеризованного индекса, в результате которого таблица сохраняется как куча;
- включение столбцов в ключ кластеризации или исключение столбцов из него.

Автоматическое перестроение всех некластеризованных индексов rowstore в таблице не требуется в следующих случаях:

- перестроение уникального кластеризованного индекса;
- перестроение не уникального кластеризованного индекса;
- изменение схемы индекса, например применение схемы секционирования к кластеризованному индексу или перемещение кластеризованного индекса в другую файловую группу.

> [!IMPORTANT]
> Индекс нельзя реорганизовать или перестроить, если файловая группа, в которой он расположен, находится в автономном режиме или предназначена только для чтения. Если указывается ключевое слово ALL, а один или несколько индексов размещены в файловой группе, которая находится в автономном режиме или предназначена только для чтения, то выполнить инструкцию не удастся.
>
> При перестроении индекса на физическом носителе должно быть достаточно места для хранения двух копий индекса. По завершении перестроения [!INCLUDE[ssde_md](../../includes/ssde_md.md)] удаляет исходный индекс.

Если указано ключевое слово `ALL` с инструкцией `ALTER INDEX`, реорганизуются реляционные кластеризованные и некластеризованные индексы и XML-индексы для таблицы.

## <a name="considerations-specific-to-rebuilding-a-columnstore-index"></a>Вопросы, связанные с перестроением индекса columnstore

При перестроении индекса columnstore [!INCLUDE[ssde_md](../../includes/ssde_md.md)] считывает все данные из исходного индекса columnstore, включая разностное хранилище. Объединяет данные в новые группы строк и сжимает columnstore в группы строк. [!INCLUDE[ssde_md](../../includes/ssde_md.md)] дефрагментирует таблицу columnstore, физически удаляя строки, которые были логически удалены из таблиц. Удаленные байты освобождают место на диске.

> [!NOTE]
> Реорганизация индекса columnstore с помощью [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)] приведет к объединению групп строк COMPRESSED, но не сжатию всех групп строк в columnstore. Группы строк CLOSED будут сжаты в columnstore в отличие от групп строк OPEN. Чтобы принудительно сжать все группы строк, см. [пример с [!INCLUDE[tsql](../../includes/tsql-md.md)]](#TsqlProcedureReorg).

> [!NOTE]
> Начиная с [!INCLUDE[sql-server-2019](../../includes/sssqlv15-md.md)], задача переноса кортежей выполняется вместе с задачей фонового объединения. Последняя автоматически сжимает небольшие разностные группы строк с состоянием OPEN, которые существовали некоторое время в соответствии с внутренним пороговым значением, или объединяет группы строк с состоянием COMPRESSED, из которых было удалено большое количество строк. Это со временем повышает качество индекса columnstore.    
> См. сведения в статье [Общие сведения об индексах columnstore](../../relational-databases/indexes/columnstore-indexes-overview.md).

### <a name="rebuild-a-partition-instead-of-the-entire-table"></a>Перестраивайте секцию, а не всю таблицу

- Если индекс большой, то перестроение всей таблицы занимает много времени и на диске должно хватать места для сохранения дополнительной копии во время перестроения. Обычно бывает необходимо перестроить только недавно использованную секцию.
- Для секционированных таблиц нет необходимости перестраивать весь индекс columnstore, поскольку фрагментация вероятна только в секциях, которые были недавно изменены. Таблицы фактов и большие таблицы измерений обычно бывают секционированы для выполнения операций резервного копирования и управления с фрагментами данных таблицы.

### <a name="rebuild-a-partition-after-heavy-dml-operations"></a>Перестраивайте секцию после масштабных операций DML

Перестроение секции дефрагментирует ее и уменьшит занимаемое место на диске. При перестройке из columnstore будут удалены все строки, помеченные для удаления, а все группы строк будут перемещены из разностного хранилища в columnstore. В разностном хранилище может быть несколько групп строк, каждая из которых может содержать менее миллиона строк.

### <a name="rebuild-a-partition-after-loading-data"></a>Перестраивайте секцию после загрузки данных

Перестраивайте секцию после загрузки данных для проверки того, что все данные хранятся в columnstore. Если при каждом параллельном процессе одновременно загружается менее 100 000 строк в одну и ту же секцию, в итоге в секции может оказаться несколько разностных хранилищ. При перестроении все строки перемещаются из разностного хранилища в columnstore.

## <a name="considerations-specific-to-reorganizing-a-columnstore-index"></a>Вопросы, связанные с реорганизацией индекса columnstore

При реорганизации индекса columnstore [!INCLUDE[ssde_md](../../includes/ssde_md.md)] сжимает каждую разностную группу строк CLOSED в columnstore в виде сжатой группы строк. Начиная с [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] и в решении [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)] с помощью команды `REORGANIZE` в оперативном режиме выполняются следующие дополнительные действия по дефрагментационной оптимизации:

- Физически удаляет строки из группы строк, если были логически удалено 10 % или более строк. Удаленные байты освобождают место на физическом носителе. Например, если в сжатой группе из одного миллиона строк удалено 100 тысяч строк, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] удалит эти строки и выполнит повторное сжатие группы с 900 тысяч строк. Группа будет сохранена в хранилище за счет удаления удаленных строк.

- Объединяет одну или несколько сжатых групп строк для увеличения числа строк для каждой группы до максимального значения, составляющего 1 048 576 строк. Например, при массовом импорте 5 пакетов с 102 400 строками вы получите 5 сжатых групп строк. При выполнении команды REORGANIZE эти групп строк будут объединены в 1 сжатую группу строк, содержащую 512 000 строк. Предполагается отсутствие ограничений на размер словаря или объем памяти.

- [!INCLUDE[ssde_md](../../includes/ssde_md.md)] пытается объединить группу строк, в которой 10 % строк или больше были логически удалены, с одной или несколькими группами строк. Например, группа строк 1 сжимается с 500 000 строками, а группа строк 21 сжимается с максимум 1 048 576 строками. В группе строк 21 удалено 60 % строк и осталось 409 830 строк. [!INCLUDE[ssde_md](../../includes/ssde_md.md)] объединяет эти две группы строк для сжатия новой группы строк, содержащей 909 830 строк.

После загрузки данных в разностном хранилище может находиться несколько небольших групп строк. С помощью инструкции `ALTER INDEX REORGANIZE` можно принудительно отправить все группы строк в columnstore, а затем объединить их в меньшее число групп строк с большим количеством строк внутри. Операция реорганизации также приведет к удалению строк, которые были удалены из columnstore.

## <a name="limitations-and-restrictions"></a><a name="Restrictions"></a> Ограничения

Перестроение индексов rowstore с более чем 128 экстентами осуществляется в два этапа — это логическое и физическое перестроение. На этапе логического перестроения существующие единицы распределения, используемые индексом, помечаются для освобождения, строки данных копируются и сортируются, а затем перемещаются в новые единицы распределения, созданные для хранения перестроенного индекса. На этапе физического перестроения единицы распределения, ранее помеченные для освобождения, физически удаляются посредством выполняемых в фоновом режиме коротких транзакций, и многочисленные блокировки для этого не требуются. Дополнительные сведения об экстентах см. в разделе [Руководство по архитектуре страниц и экстентов](../../relational-databases/pages-and-extents-architecture-guide.md).

Инструкция `ALTER INDEX REORGANIZE` требует, чтобы в файле данных, где содержится индекс, было свободное пространство, потому что операция может выделять временные рабочие страницы только в том же файле (а не в другом файле файловой группы, к примеру). Поэтому у пользователя все равно может возникнуть ошибка 1105, даже если в файловой группе есть свободные страницы: `Could not allocate space for object '###' in database '###' because the '###' filegroup is full. Create disk space by deleting unneeded files, dropping objects in the filegroup, adding additional files to the filegroup, or setting autogrowth on for existing files in the filegroup.`

> [!WARNING]
> Создание и перестройка невыровненных индексов для таблицы, количество секций в которой превышает 1000, возможны, но не поддерживаются. Это может привести к снижению производительности или чрезмерному потреблению памяти во время таких операций. Если количество секций превышает 1000, рекомендуется использовать только [выровненные индексы](../partitions/partitioned-tables-and-indexes.md#aligned-index).

Индекс нельзя реорганизовать или перестроить, если файловая группа, в которой он находится, размещена **вне сети** или настроена **только для чтения**. Если указывается ключевое слово `ALL`, а один индекс или несколько расположены в файловой группе, которая находится в автономном режиме или предназначена только для чтения, то выполнить инструкцию не удастся.

Статистика:

- При **создании** или **перестроении** индекса статистика создается или обновляется путем сканирования всех строк таблицы. Однако начиная с выпуска [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] статистические данные не создаются и не обновляются путем сканирования всех строк таблицы при создании или перестроении секционированного индекса. Вместо этого оптимизатор запросов использует для создания статистики алгоритм выборки по умолчанию. Для получения статистики по секционированным индексам путем сканирования всех строк таблицы используйте инструкции [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md) или [UPDATE STATISTICS](../../t-sql/statements/update-statistics-transact-sql.md) с предложением `FULLSCAN`.

- Когда индекс **реорганизуется**, статистика не обновляется.

Индекс нельзя реорганизовать, если для `ALLOW_PAGE_LOCKS` задано состояние OFF.

В версиях, предшествующих [!INCLUDE[ssSQL17](../../includes/sssql17-md.md)], перестроение кластеризованного индекса columnstore выполняется в автономном режиме. Ядро СУБД должно получить монопольную блокировку в таблице или секции на время выполнения перестроения. Данные находятся в автономном режиме и недоступны во время перестроения даже при использовании `NOLOCK`, изоляции моментальных снимков с уровнем READ COMMITED (RCSI) или обычной изоляции моментальных снимков.
Начиная с [!INCLUDE[sql-server-2019](../../includes/sssqlv15-md.md)] кластеризованный индекс columnstore можно перестраивать с помощью параметра `ONLINE = ON`.

Для таблицы Azure Synapse Analytics (ранее — [!INCLUDE[ssSDW](../../includes/sssdw-md.md)]) с упорядоченным кластеризованным индексом columnstore `ALTER INDEX REBUILD` будет повторно сортировать данные с помощью TempDB. Отслеживайте базу данных tempdb во время операций перестроения. Если вам необходимо больше места в базе данных tempdb, можно увеличить объем хранилища данных. Масштаб можно вернуть обратно после перестроения индекса.

Для таблицы Azure Synapse Analytics (ранее — [!INCLUDE[ssSDW](../../includes/sssdw-md.md)]) с упорядоченным кластеризованным индексом columnstore `ALTER INDEX REORGANIZE` не будет повторно сортировать данные. Для повторной сортировки данных используйте `ALTER INDEX REBUILD`.

## <a name="using-index-rebuild-to-recover-from-hardware-failures"></a>Использование INDEX REBUILD для восстановления после сбоев оборудования

В предыдущих версиях [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] иногда можно было перестроить некластеризованный индекс rowstore, чтобы исправить несоответствия, вызванные сбоями оборудования.
Начиная с [!INCLUDE[ssKatmai](../../includes/ssKatmai-md.md)] можно также скорректировать такие несоответствия между индексом и кластеризованным индексом, перестроив некластеризованный индекс в автономном режиме. Однако невозможно устранить несоответствия некластеризованного индекса, перестроив индекс в оперативном режиме, потому что механизм перестроения в этом режиме использует существующий некластеризованный индекс в качестве основы для перестроения и тем самым закрепит несоответствие. При автономном перестроении индекса иногда может принудительно запускаться проверка кластеризованного индекса (или кучи), и в результате устраняются несоответствия. Чтобы обеспечить перестроение из кластеризованного индекса, удалите и повторно создайте некластеризованный индекс. Как и в предыдущих версиях, рекомендованным методом устранения несоответствий является восстановление затронутых данных из резервных копий, однако исправить несоответствия индекса можно, перестроив некластеризованный индекс в автономном режиме. Дополнительные сведения см. в разделе [DBCC CHECKDB (Transact-SQL)](../../t-sql/database-console-commands/dbcc-checkdb-transact-sql.md).

## <a name="see-also"></a>См. также раздел

- [Руководство по архитектуре и разработке индексов SQL Server](../../relational-databases/sql-server-index-design-guide.md)
- [Выполнение операций с индексами в оперативном режиме](../../relational-databases/indexes/perform-index-operations-online.md)
- [ALTER INDEX (Transact-SQL)](../../t-sql/statements/alter-index-transact-sql.md)
- [Адаптивная дефрагментация индексов](https://github.com/Microsoft/tigertoolbox/tree/master/AdaptiveIndexDefrag)
- [CREATE STATISTICS (Transact-SQL)](../../t-sql/statements/create-statistics-transact-sql.md)
- [UPDATE STATISTICS (Transact-SQL)](../../t-sql/statements/update-statistics-transact-sql.md)
- [Производительность запросов индексов columnstore](../../relational-databases/indexes/columnstore-indexes-query-performance.md)
- [Начало работы с Columnstore для получения операционной аналитики в реальном времени](../../relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics.md)
- [Индексы сolumnstore для хранилищ данных](../../relational-databases/indexes/columnstore-indexes-data-warehouse.md)
- [Индексы columnstore и политика слияния для групп строк](/archive/blogs/sqlserverstorageengine/columnstore-index-merge-policy-for-reorganize)