---
title: Оценка количества элементов (SQL Server) | Документация Майкрософт
description: Оптимизатор запросов SQL Server выбирает планы запросов с наименьшей оценочной стоимостью обработки, которая определяется на основе обработанных строк и модели затрат.
ms.custom: ''
ms.date: 02/24/2019
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords:
- cardinality estimator
- CE (cardinality estimator)
- estimating cardinality
ms.assetid: baa8a304-5713-4cfe-a699-345e819ce6df
author: julieMSFT
ms.author: jrasnick
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 571d611fe49e590d65f0f9749660844328f6c9c1
ms.sourcegitcommit: c74bb5944994e34b102615b592fdaabe54713047
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/22/2020
ms.locfileid: "90990177"
---
# <a name="cardinality-estimation-sql-server"></a>Оценка количества элементов (SQL Server)

[!INCLUDE [SQL Server Azure SQL Database](../../includes/applies-to-version/sql-asdb.md)]

Оптимизатор запросов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] основан на оценке стоимости. То есть оптимизатор выбирает планы запросов с наименьшей оценочной стоимостью их выполнения. Оптимизатор запросов определяет стоимость выполнения плана запроса исходя из двух основных факторов:

- общего числа строк, обрабатываемых на каждом из уровней плана запроса, известного как количество элементов, или мощность плана;
- модели стоимости алгоритма, которая определяется исходя из операторов, выполняемых в запросе.

Первый фактор, количество элементов, передается в качестве входного параметра второму фактору, модели стоимости. Обработанное таким образом количество элементов точнее определяет стоимость, что, в свою очередь, позволяет выбрать самый быстрый план выполнения запроса.

Оценка кратности (CE) в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] главным образом определяется на основе гистограмм, которые создаются автоматически или вручную после создания индексов или статистик. Иногда для определения количества элементов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] также использует сведения об ограничениях и логической реструктуризации запросов.

Ниже перечислены случаи, когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не в состоянии точно вычислить количество элементов. Это приводит к неточному определению стоимости, что, в свою очередь, может привести к созданию неоптимальных планов запросов. Если избегать применения таких конструкций, можно повысить производительность выполнения запросов. Иногда в таких случаях доступны альтернативные формулировки запросов и другие средства, помогающие решить эту проблему:

- Запросы с предикатами, которые содержат операторы сравнения столбцов одной и той же таблицы.
- Запросы с предикатами, использующими операторы, и выполнение одного из следующих условий:
  - отсутствует статистика для столбца, указанного с любой стороны от оператора;
  - распределение значений в статистике неоднородно, а запрос выполняет поиск весьма ограниченного набора значений. Эта ситуация особенно вероятна, если оператор не является оператором равенства (=);
  - предикат использует оператор неравенства (!=) или логический оператор `NOT`.
- Запросы с любыми встроенными функциями SQL Server или пользовательскими скалярными функциями, которым в качестве аргументов передаются выражения, отличные от констант.
- Запросы, в которые включены столбцы, соединяемые по арифметическим операторам или объединением строк.
- Запросы, которые сравнивают переменные, значения которых в момент компиляции и оптимизации запроса неизвестны.

В этой статье показано, как оценить и выбрать оптимальную конфигурацию CE для вашей системы. В большинстве систем используется последняя версия CE, поскольку она наиболее точна. CE прогнозирует количество строк, которое скорее всего будет возвращено запросом. Прогноз кратности используется оптимизатором запросов для создания оптимального плана запроса. Чем точнее оценки, тем, как правило, оптимальнее план запроса.  
  
В системе приложения, возможно, существовал важный запрос, план обработки которого был изменен на более медленный с учетом изменений в CE в разных версиях. У вас есть методы и средства определения запроса, который выполняется медленнее из-за проблем с CE. И у вас есть несколько способов решения возникших в результате проблем производительности.
  
## <a name="versions-of-the-ce"></a>Версии CE

В 1998 г. основное обновление CE входило в состав [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 7.0. Уровень совместимости компонента был равен 70. Эта версия модели CE основана на четырех допущениях.

-  **Независимость**: предполагается, что данные, распределенные по разным столбцам, независимы друг от друга, если нет доступных или используемых сведений о корреляции.
-  **Единообразие**: отдельные значения равномерно распределены и имеют одинаковую частоту. Говоря точнее, отдельные значения равномерно распределены на каждом шаге [гистограммы](../../relational-databases/statistics/statistics.md#histogram) и все значения имеют одинаковую частоту. 
-  **Автономность (простая)** : пользователи запрашивают существующие данные. Например, в случае соединения по равенству между двумя таблицами учитывайте избирательность предикатов <sup>1</sup> в каждой входной гистограмме перед соединением гистограмм для оценки избирательности соединения. 
-  **Включение**: для предикатов фильтра, где `Column = Constant`, предполагается, что константа фактически существует для связанного столбца. Если соответствующий шаг гистограммы не пуст, предполагается, что одно из конкретных значений шага совпадает со значением из предиката.

  <sup>1</sup> Число строк, удовлетворяющее предикат.

Последующие обновления выпущены вместе с [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] с уровнем совместимости 120 и выше. Обновления CE для уровней 120 и выше включают обновленные допущения и алгоритмы, которые хорошо сочетаются с современными хранилищами данных и рабочими нагрузками OLTP. Из допущений CE 70 были изменены следующие допущения моделей, начиная с CE 120:

-  **Независимость** стала **корреляцией**: комбинация разных значений столбцов, которые необязательно будут независимы. Это может напоминать более реальные запросы данных.
-  **Простая автономность** стала **базовой автономностью**: пользователи могут запрашивать несуществующие данные. Например, в случае соединения по равенству между двумя таблицами используются гистограммы базовых таблиц для оценки избирательности соединений, а затем учитывается избирательность предикатов.
  
**Уровень совместимости**: чтобы убедиться в том, что база данных находится на определенном уровне, используйте следующий код [!INCLUDE[tsql](../../includes/tsql-md.md)] для [COMPATIBILITY_LEVEL](../../t-sql/statements/alter-database-transact-sql-compatibility-level.md).  

```sql  
SELECT ServerProperty('ProductVersion');  
GO  
  
ALTER DATABASE <yourDatabase>  
SET COMPATIBILITY_LEVEL = 130;  
GO  
  
SELECT d.name, d.compatibility_level  
FROM sys.databases AS d  
WHERE d.name = 'yourDatabase';  
GO  
```  
  
В базах данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с уровнем совместимости 120 или выше при активации [флага трассировки 9481](../../t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql.md) система принудительно использует CE версии 70.  
  
**Устаревшая CE**: для базы данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с заданным уровнем совместимости 120 или выше можно активировать CE версии 70 на уровне базы с помощью инструкции [ALTER DATABASE SCOPED CONFIGURATION](../../t-sql/statements/alter-database-scoped-configuration-transact-sql.md).
  
```sql  
ALTER DATABASE SCOPED CONFIGURATION 
SET LEGACY_CARDINALITY_ESTIMATION = ON;  
GO  
  
SELECT name, value  
FROM sys.database_scoped_configurations  
WHERE name = 'LEGACY_CARDINALITY_ESTIMATION';  
GO
```  
 
Или, начиная с [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] с пакетом обновления 1 (SP1), используется [указание запроса](../../t-sql/queries/hints-transact-sql-query.md#use_hint) `USE HINT ('FORCE_LEGACY_CARDINALITY_ESTIMATION')`.
 
 ```sql  
SELECT CustomerId, OrderAddedDate  
FROM OrderTable  
WHERE OrderAddedDate >= '2016-05-01'
OPTION (USE HINT ('FORCE_LEGACY_CARDINALITY_ESTIMATION'));  
```
 
**Хранилище запросов**: появившееся в [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] хранилище запросов является удобным инструментом для анализа производительности запросов. В среде [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)] откройте **обозреватель объектов**. Затем откройте узел вашей базы данных; если хранилище запросов включено, вы увидите узел **Хранилище запросов**.  
  
```sql  
ALTER DATABASE <yourDatabase>  
SET QUERY_STORE = ON;  
GO  
  
SELECT q.actual_state_desc AS [actual_state_desc_of_QueryStore],  
        q.desired_state_desc,  
        q.query_capture_mode_desc  
FROM sys.database_query_store_options AS q;  
GO  
  
ALTER DATABASE <yourDatabase>  
SET QUERY_STORE CLEAR;  
```  
  
> [!TIP] 
> Рекомендуется установить последний выпуск [Management Studio](../../ssms/download-sql-server-management-studio-ssms.md) и регулярно обновлять его.  

> [!IMPORTANT] 
> Убедитесь, что хранилище запросов правильно настроено для вашей базы данных и рабочей нагрузки. Дополнительные сведения см. в статье [Рекомендации по работе с хранилищем запросов](../../relational-databases/performance/best-practice-with-the-query-store.md). 
  
Другой способ отслеживания процесса оценки кратности (CE) подразумевает использование расширенного события с именем **query_optimizer_estimate_cardinality**. Следующий пример кода [!INCLUDE[tsql](../../includes/tsql-md.md)] выполняется в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Он записывает XEL-файл в папку `C:\Temp\` (хотя этот путь можно изменить). При открытии XEL-файла в [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)] отображаются подробные сведения об этом файле.  
  
```sql  
DROP EVENT SESSION Test_the_CE_qoec_1 ON SERVER;  
go  
  
CREATE EVENT SESSION Test_the_CE_qoec_1  
ON SERVER  
ADD EVENT sqlserver.query_optimizer_estimate_cardinality  
    (  
        ACTION (sqlserver.sql_text)  
            WHERE (  
                sql_text LIKE '%yourTable%'  
                and sql_text LIKE '%SUM(%'  
            )  
    )  
ADD TARGET package0.asynchronous_file_target   
        (SET  
            filename = 'c:\temp\xe_qoec_1.xel',  
            metadatafile = 'c:\temp\xe_qoec_1.xem'  
        );  
GO  
  
ALTER EVENT SESSION Test_the_CE_qoec_1  
ON SERVER  
STATE = START;  --STOP;  
GO  
```  
  
Сведения о расширенных событиях, адаптированных для [!INCLUDE[ssSDS](../../includes/sssds-md.md)], см. в разделе [Расширенные события в базе данных SQL](https://azure.microsoft.com/documentation/articles/sql-database-xevent-db-diff-from-svr/).  
  
## <a name="steps-to-assess-the-ce-version"></a>Процедура оценки версии CE  
  
Далее приводятся пошаговые инструкции, позволяющие оценить, не выполняется ли какой-нибудь из важных запросов медленнее с учетом последних данных CE. Для выполнения некоторых шагов нужно выполнить пример кода из предыдущего раздела.  
  
1.  Откройте среду [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)]. Убедитесь, что для базы данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] задан наивысший доступный уровень совместимости.  
  
2.  Выполните следующие подготовительные действия:  
  
    1.  Откройте среду [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)].  
  
    2.  Запустите T-SQL, чтобы убедиться, что для базы данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] задан наивысший доступный уровень совместимости.  
  
    3.  Убедитесь, что для базы данных отключена конфигурация `LEGACY_CARDINALITY_ESTIMATION`.  
  
    4.  Очистите хранилище запросов. Убедитесь, что хранилище запросов включено.  
  
    5.  Выполните инструкцию `SET NOCOUNT OFF;`.  
  
3.  Выполните инструкцию `SET STATISTICS XML ON;`.  
  
4.  Выполните свой важный запрос.  
  
5.  На вкладке **Сообщения** в области результатов обратите внимание на фактическое число затронутых строк.  
  
6.  На вкладке **Результаты** в области результатов дважды щелкните ячейку, которая содержит статистику в формате XML. Отобразится графический план запроса.  
  
7.  Щелкните правой кнопкой мыши первое поле в графическом плане запроса и нажмите **Свойства**.  
  
8.  Для последующего сравнения с другой конфигурацией обратите внимание на значения следующих свойств:  
  
    -   **CardinalityEstimationModelVersion**.  
  
    -   **Предполагаемое количество строк**.  
  
    -   **Предполагаемые затраты на ввод/вывод**и несколько аналогичных *предполагаемых* свойств, которые имеют отношение к фактической производительности, а не прогнозу числа строк.  
  
    -   **Логическая операция** и **Физическая операция**. *Параллелизм* — хорошее значение.  
  
    -   **Фактический режим выполнения**. *Пакет* — хорошее значение (лучше чем *Строка*).  
  
9. Сравните предполагаемое количество строк с фактическим. Значение CE неточно на 1 % (в любом направлении) или на 10 %?  
  
10. Выполните `SET STATISTICS XML OFF;`.  
  
11. Запустите T-SQL, чтобы снизить уровень совместимости вашей базы данных на 1 (например, со 130 до 120).  
  
12. Повторно выполните все шаги, кроме подготовительных.  
  
13. Сравните значения свойства CE в обоих прогонах.  
  
    - Процент точности с новым CE ниже, чем со старым?  
  
14. Наконец, сравните различные значения свойств производительности в обоих прогонах.  
  
    -   Ваш запрос обрабатывался по двум разным планам из-за того, что оценочные значения CE различались?  
  
    -   Ваш запрос выполнялся медленнее с последним CE?  
  
    -   В большинстве случаев следует использовать последний CE. Исключение составляют ситуации, когда при использовании старого CE запрос обрабатывался быстрее и по другому плану.  
  
    -   В этом случае нужно назначить в системе принудительное использование плана более быстрой обработки и игнорирование CE. Так вы сможете использовать новейший CE во всех операциях, а важный запрос будет выполняться быстрее.  
  
## <a name="how-to-activate-the-best-query-plan"></a>Активация оптимального плана запроса  
  
Предположим, что при использовании CE 120 и выше создается менее эффективный план обработки запроса. Ниже дается несколько рекомендаций, позволяющих активировать более эффективный план.  
  
1. Можно установить более низкий уровень совместимости (не самый высокий из доступных) для всей базы данных.  
  
   - Например, при задании уровня совместимости 110 или ниже активируется CE 70, но все запросы подчиняются предыдущей модели CE.  
  
   - Кроме того, на более низком уровне совместимости нет ряда улучшений оптимизатора запросов, которые есть в более поздних версиях.  
  
2. Можно использовать параметр базы данных `LEGACY_CARDINALITY_ESTIMATION`, чтобы задать принудительное использование прежнего значения CE во всей базе данных и при этом реализовать усовершенствования оптимизатора запросов.   

3. Можно использовать указание запроса `LEGACY_CARDINALITY_ESTIMATION`, чтобы один запрос использовал прежнее значение CE, и при этом реализовать усовершенствования оптимизатора запросов.  
  
Для еще более точного контроля можно назначить *принудительное* использование системой плана, составленного с CE 70 во время тестирования. После *закрепления* выбранного плана можно настроить всю базу данных для использования самого высокого уровня совместимости и последнего CE. Далее этот вариант рассматривается более подробно.  
  
### <a name="how-to-force-a-particular-query-plan"></a>Настройка принудительного использования определенного плана запросов  
  
Хранилище запросов предоставляет различные способы для настройки принудительного использования определенного плана запросов в системе:  
  
- Выполните команду **sp_query_store_force_plan**.  
  
- В [!INCLUDE[ssManStudio](../../includes/ssManStudio-md.md)] разверните узел **Хранилище запросов**, щелкните правой кнопкой мыши **Ключевые узлы — потребители ресурсов**, а затем щелкните **Просмотр ключевых узлов — потребителей ресурсов**. На дисплее отображаются кнопки **Принудительное использование плана** и **Отменить принудительное использование плана**.  
  
Дополнительные сведения о хранилище запросов см. в разделе [Мониторинг производительности с использованием хранилища запросов](../../relational-databases/performance/monitoring-performance-by-using-the-query-store.md).  
  
## <a name="examples-of-ce-improvements"></a>Примеры улучшения CE  
  
В этом разделе описываются примеры запросов, которые лучше обрабатываются с использованием преимуществ, реализованных в последних выпусках CE. Это справочная информация, не требующая от вас никаких действий.  
  
### <a name="example-a-ce-understands-maximum-value-might-be-higher-than-when-statistics-were-last-gathered"></a>Пример А. Расчет CE выполняется с тем допущением, что максимальное значение может быть больше, чем на момент сбора статистики  
  
Предположим, последняя статистика для `OrderTable` была собрана `2016-04-30`, когда максимум `OrderAddedDate` был равен `2016-04-30`. CE 120 (и более поздние версии) учитывает, что столбцы в `OrderTable` с данными *по возрастанию* содержали значения, превышающие записанный в статистике максимум. Исходя из этого план обработки запросов для инструкций SELECT [!INCLUDE[tsql](../../includes/tsql-md.md)] оптимизируется следующим образом.  
  
```sql  
SELECT CustomerId, OrderAddedDate  
FROM OrderTable  
WHERE OrderAddedDate >= '2016-05-01';  
```  
  
### <a name="example-b-ce-understands-that-filtered-predicates-on-the-same-table-are-often-correlated"></a>Пример Б. Расчет CE выполняется с допущением, что фильтрованные предикаты в одной и той же таблице часто коррелируют  
  
В следующем примере выполнения инструкции SELECT мы видим фильтрованные предикаты для `Model` и `ModelVariant`. Мы интуитивно понимаем, что если `Model` имеет значение "Xbox", есть вероятность, что `ModelVariant` имеет значение "One", учитывая, что у консоли Xbox была модель One.  
  
Начиная с CE уровня 120, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] учитывает, что может существовать корреляция между двумя столбцами одной и той же таблицы: `Model` и `ModelVariant`. CE более точно оценивает, сколько строк будет возвращено запросом, а [оптимизатор запросов](../../relational-databases/query-processing-architecture-guide.md#optimizing-select-statements) создает оптимизированный план.  
  
```sql  
SELECT Model, Purchase_Price  
FROM dbo.Hardware  
WHERE Model = 'Xbox' AND  
      ModelVariant = 'One';  
```  
  
### <a name="example-c-ce-no-longer-assumes-any-correlation-between-filtered-predicates-from-different-tables"></a>Пример В. При расчете CE мы более не допускаем никаких корреляций между фильтрованными предикатами из разных таблиц 
Если провести новое исследование с актуальными рабочими нагрузками и фактическими бизнес-данными, обнаружится, что фильтры предикатов из разных таблиц, как правило, не коррелируют друг с другом. В следующем запросе при расчете CE предполагается, что между `s.type` и `r.date` нет никакой корреляции. Следовательно, CE оценивает, что число возвращаемых строк будет меньше.  
  
```sql  
SELECT s.ticket, s.customer, r.store  
FROM dbo.Sales AS s  
CROSS JOIN dbo.Returns AS r  
WHERE s.ticket = r.ticket AND  
      s.type = 'toy' AND  
      r.date = '2016-05-11';  
```  
  
## <a name="see-also"></a>См. также:  
 [Наблюдение и настройка производительности](../../relational-databases/performance/monitor-and-tune-for-performance.md)   
 [Оптимизация планов запроса с помощью средства оценки кратности SQL Server 2014](https://msdn.microsoft.com/library/dn673537.aspx)  
 [Указания запросов](../../t-sql/queries/hints-transact-sql-query.md)     
 [Указания запросов USE HINT](../../t-sql/queries/hints-transact-sql-query.md#use_hint)       
 [Обновление баз данных с помощью помощника по настройке запросов](../../relational-databases/performance/upgrade-dbcompat-using-qta.md)           
 [Мониторинг производительности с использованием хранилища запросов](../../relational-databases/performance/monitoring-performance-by-using-the-query-store.md)    
 [Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md)   
