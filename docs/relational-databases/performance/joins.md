---
title: Joins (SQL Server) | Документы Майкрософт
description: Сведения о типах операций соединения, используемых SQL Server. SQL Server поддерживает вертикальное секционирование таблиц или хранилище столбцов за счет операций соединения.
ms.custom: ''
ms.date: 07/19/2019
ms.prod: sql
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords:
- HASH join
- NESTED LOOPS join
- MERGE join
- ADAPTIVE join
- joins [SQL Server], about joins
- join hints [SQL Server]
ms.assetid: bfc97632-c14c-4768-9dc5-a9c512f4b2bd
author: julieMSFT
ms.author: jrasnick
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: c672ae4cf447f60f486eaaca8a50a1d79c3cd4b4
ms.sourcegitcommit: c7f40918dc3ecdb0ed2ef5c237a3996cb4cd268d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/05/2020
ms.locfileid: "91726015"
---
# <a name="joins-sql-server"></a>Joins (SQL Server)
[!INCLUDE[SQL Server Azure SQL Database Synapse Analytics PDW ](../../includes/applies-to-version/sql-asdb-asdbmi-asa-pdw.md)]

[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняет операции сортировки, пересечения, объединения и поиска различий при помощи технологий хэш-соединений и сортировки в оперативной памяти. При использовании плана запросов этого типа [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживает вертикальное секционирование таблиц.   

[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] реализует операции логического объединения в соответствии с синтаксисом [!INCLUDE[tsql](../../includes/tsql-md.md)]:
-   внутреннее соединение,
-   левое внешнее соединение.
-   Правое внешнее соединение
-   Полное внешнее соединение
-   Перекрестное соединение

> [!NOTE]
> Дополнительные сведения о синтаксисе соединения см. в разделе [Предложение FROM и JOIN, APPLY, PIVOT (Transact-SQL)](../../t-sql/queries/from-transact-sql.md).

[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует четыре типа операций физического соединения для выполнения операций логического соединения:    
-   Соединения вложенных циклов     
-   Соединения слиянием.   
-   Хэш-соединения.   
-   Адаптивные соединения (начиная с [!INCLUDE[ssSQL17](../../includes/sssql17-md.md)])

## <a name="join-fundamentals"></a><a name="fundamentals"></a> Основные принципы соединения
С помощью соединения можно получать данные из двух или нескольких таблиц на основе логических связей между ними. Соединения позволяют указать, как в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] должны использоваться данные из одной таблицы для выбора строк из другой таблицы.    

Соединение определяет способ связывания двух таблиц в запросе следующим образом:    
-   для каждой таблицы указываются столбцы, используемые в соединении. В типичном условии соединения указывается внешний ключ из одной таблицы и связанный с ним ключ из другой таблицы;    
-   указывается логический оператор (например, = или <>,) для сравнения значений столбцов.   

Соединения выражаются логически с помощью следующего синтаксиса [!INCLUDE[tsql](../../includes/tsql-md.md)]:
-   INNER JOIN
-   LEFT [ OUTER ] JOIN
-   RIGHT [ OUTER ] JOIN
-   FULL [ OUTER ] JOIN
-   CROSS JOIN

**Внутренние соединения** можно задавать в предложениях `FROM` и `WHERE`. **Внешние соединения** и **перекрестные соединения** можно задавать только в предложении `FROM`. Условия соединения сочетаются с условиями поиска `WHERE` и `HAVING` для управления строками, выбранными из базовых таблиц, на которые ссылается предложение `FROM`.    

То, что условия соединения задаются в предложении `FROM`, помогает отделить их от условий поиска, которые могут быть заданы в предложении `WHERE`. Объединение рекомендуется задавать именно таким способом. Ниже приведен упрощенный синтаксис соединения с использованием предложения `FROM` стандарта ISO:

```
FROM first_table < join_type > second_table [ ON ( join_condition ) ]
```

*join_type* указывает на выполняемый тип соединения: внутреннее, внешнее или перекрестное. *join_condition* определяет предикат, который будет вычисляться для каждой пары соединяемых строк. Ниже приведен пример предложения `FROM` с заданным соединением:

```sql
FROM Purchasing.ProductVendor INNER JOIN Purchasing.Vendor
     ON ( ProductVendor.BusinessEntityID = Vendor.BusinessEntityID )
```

Ниже приведена простая инструкция `SELECT`, использующая это соединение:

```sql
SELECT ProductID, Purchasing.Vendor.BusinessEntityID, Name
FROM Purchasing.ProductVendor INNER JOIN Purchasing.Vendor
    ON (Purchasing.ProductVendor.BusinessEntityID = Purchasing.Vendor.BusinessEntityID)
WHERE StandardPrice > $10
  AND Name LIKE N'F%'
GO
```

Инструкция `SELECT` возвращает наименование продукта и сведения о поставщике для всех сочетаний запчастей, поставляемых компаниями с названиями на букву F и стоимостью продукта более 10 долларов.   

Если один запрос содержит ссылки на несколько таблиц, то все ссылки столбцов должны быть однозначными. В предыдущем примере как таблица `ProductVendor`, так и таблица `Vendor` содержат столбец с именем `BusinessEntityID`. Имена столбцов, совпадающие в двух или более таблицах, на которые ссылается запрос, должны уточняться именем таблицы. Все ссылки на столбец `Vendor` в этом примере являются полными.   

Если имя столбца не дублируется в двух или более таблицах, указанных в запросе, то ссылки на него уточнять именем таблицы не обязательно. Это показано в предыдущем примере. Подобное предложение `SELECT` иногда трудно понять, поскольку в нем нет ничего, что указывало бы на таблицы, из которых берутся столбцы. Запрос гораздо легче читать, если все столбцы указаны с именами соответствующих таблиц. Запрос будет читаться еще легче, если используются псевдонимы таблиц, особенно когда имена таблиц сами должны уточняться именами базы данных и владельца. Ниже приведен тот же пример, но чтобы упростить чтение, используются псевдонимы таблиц, уточняющие названия столбцов.

```sql
SELECT pv.ProductID, v.BusinessEntityID, v.Name
FROM Purchasing.ProductVendor AS pv 
INNER JOIN Purchasing.Vendor AS v
    ON (pv.BusinessEntityID = v.BusinessEntityID)
WHERE StandardPrice > $10
    AND Name LIKE N'F%';
```

В предыдущем примере условие соединения задается в предложении `FROM`, что является рекомендуемым способом. В следующем запросе это же условие соединения указывается в предложении `WHERE`:

```sql
SELECT pv.ProductID, v.BusinessEntityID, v.Name
FROM Purchasing.ProductVendor AS pv, Purchasing.Vendor AS v
WHERE pv.BusinessEntityID=v.BusinessEntityID
    AND StandardPrice > $10
    AND Name LIKE N'F%';
```

Список `SELECT` для соединения может ссылаться на все столбцы в соединяемых таблицах или на любое подмножество этих столбцов. Список `SELECT` не обязательно должен содержать столбцы из каждой таблицы в соединении. Например, в соединении из трех таблиц связующим звеном между одной из таблиц и третьей таблицей может быть только одна таблица, при этом список выборки не обязательно должен ссылаться на столбцы средней таблицы. Это так называемое **антиполусоединение**.  

Хотя обычно в условиях соединения для сравнения используется оператор равенства (=), можно указать другие операторы сравнения или реляционные операторы, равно как другие предикаты. Дополнительные сведения см. в разделах [Операторы сравнения (Transact-SQL)](../../t-sql/language-elements/comparison-operators-transact-sql.md) и [WHERE (Transact-SQL)](../../t-sql/queries/where-transact-sql.md).  

При обработке соединений в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] оптимизатор запросов выбирает наиболее эффективный метод обработки из нескольких возможных. Сюда входит выбор наиболее эффективного типа физического соединения, порядка, в котором будут соединяться таблицы, и даже использование типов операций логического соединения, которые невозможно непосредственно выразить с помощью синтаксиса [!INCLUDE[tsql](../../includes/tsql-md.md)], например **полусоединение** и **антиполусоединение**. При физическом выполнении различных соединений можно использовать много разных оптимизаций, поэтому их нельзя надежно прогнозировать. Дополнительные сведения о полусоединениях и антиполусоединениях см. в [справочнике по логическим и физическим операторам Showplan](../../relational-databases/showplan-logical-and-physical-operators-reference.md).  

Столбцы, используемые в условии соединения, не обязательно должны иметь одинаковые имена или одинаковый тип данных. Однако если типы данных не совпадают, то они должны быть совместимыми или допускать в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] неявное преобразование. Если типы данных не допускают неявное преобразование, то условия соединения должны явно преобразовывать эти типы данных с помощью функции `CAST`. Дополнительные сведения о подразумеваемых и явных преобразованиях см. в статье [Преобразование типов данных (ядро СУБД)](../../t-sql/data-types/data-type-conversion-database-engine.md).    

Большинство запросов, использующих соединение, можно переписать с помощью вложенных запросов и наоборот. Дополнительные сведения о вложенных запросах см. в разделе [Вложенные запросы](../../relational-databases/performance/subqueries.md).   

> [!NOTE]
> Таблицы невозможно соединять непосредственно по столбцам ntext, text или image. Однако соединить таблицы по столбцам ntext, text или image можно косвенно, с помощью `SUBSTRING`.    
> Например, `SELECT * FROM t1 JOIN t2 ON SUBSTRING(t1.textcolumn, 1, 20) = SUBSTRING(t2.textcolumn, 1, 20)` выполняет внутреннее соединение двух таблиц по первым 20 символам текстовых столбцов в таблицах t1 и t2.   
> Другая возможность сравнения столбцов ntext и text из двух таблиц заключается в сравнении длины столбцов с предложением `WHERE`, например: `WHERE DATALENGTH(p1.pr_info) = DATALENGTH(p2.pr_info)`

## <a name="understanding-nested-loops-joins"></a><a name="nested_loops"></a> Основные сведения о соединениях вложенных циклов
Если один вход соединения имеет небольшой размер (менее десяти строк), а другой вход сравнительно большой и индексирован по соединяемым столбцам, индексное соединение вложенных циклов является самой быстрой операцией соединения, так как для нее потребуется наименьшее количество операций сравнения и ввода-вывода. 

Соединение вложенных циклов, называемое также *вложенной итерацией*, использует один ввод соединения в качестве внешней входной таблицы (на графической схеме выполнения она является верхним входом), а второй в качестве внутренней (нижней) входной таблицы. Внешний цикл использует внешнюю входную таблицу построчно. Во внутреннем цикле для каждой внешней строки производится сканирование внутренней входной таблицы и вывод совпадающих строк.   

В простейшем случае во время поиска целиком просматривается таблица или индекс; это называется *упрощенным соединением вложенных циклов*. Если при поиске используется индекс, то такой поиск называется *индексным соединением вложенных циклов*. Если индекс создается в качестве части плана запроса (и уничтожается после завершения запроса), то он называется *временным индексным соединением вложенных циклов*. Все эти варианты учитываются оптимизатором запросов.   

Соединение вложенных циклов является особенно эффективным в случае, когда внешние входные данные сравнительно невелики, а внутренние входные данные велики и заранее индексированы. Во многих небольших транзакциях, работающих с небольшими наборами строк, индексное соединение вложенных циклов превосходит как соединения слиянием, так и хэш-соединения. Однако в больших запросах соединения вложенных циклов часто являются не лучшим вариантом.    

Если для атрибута OPTIMIZED оператора соединения вложенными циклами задано значение **True**, это означает, что оптимизированные соединения вложенными циклами (или пакетная сортировка) используются для уменьшения количества операций ввода-вывода, когда внутренняя таблица имеет большой размер, независимо от того, выполняется ли ее параллельная обработка. Такая оптимизация в этом плане выполнения может быть не слишком очевидна при анализе плана, если сама сортировка выполняется как скрытая операция. Но изучив XML-код плана для атрибута OPTIMIZED, можно обнаружить, что соединение вложенными циклами, возможно, попытается изменить порядок входных строк, чтобы повысить производительность операций ввода-вывода.

## <a name="understanding-merge-joins"></a><a name="merge"></a> Основные сведения о соединениях слиянием
Если два входа соединения достаточно велики, но отсортированы по соединяемым столбцам (например, если они были получены просмотром отсортированных индексов), то наиболее быстрой операцией соединения будет соединение слиянием. Если оба входа соединения велики и имеют сходные размеры, соединение слиянием с предварительной сортировкой и хэш-соединение имеют примерно одинаковую производительность. Однако операции хэш-соединения часто выполняются быстрее, если два входа значительно отличаются по размеру.       

Соединение слиянием требует сортировки обоих наборов входных данных по столбцам слияния, которые определены предложениями равенства (ON) предиката объединения. Оптимизатор запросов обычно просматривает индекс, если для соответствующего набора столбцов такой существует, или устанавливает оператор сортировки под соединением слиянием. В редких случаях может быть несколько предложений равенства, но столбцы слияния берутся только из некоторых доступных предложений равенства.    

Так как каждый набор входных данных сортируется, оператор **Merge Join** получает строку из каждого набора входных данных и сравнивает их. Например, для операций внутреннего соединения строки возвращаются в том случае, если они равны. Если они не равны, строка с меньшим значением не учитывается, и из этого набора входных данных берется другая строка. Этот процесс повторяется, пока не будет выполнена обработка всех строк.    

Операция соединения слиянием может быть как обычной, так и операцией типа «многие ко многим». Соединение слиянием «многие ко многим» использует временную таблицу для хранения строк. При наличии дублирующих значений из каждого набора входных данных один из наборов должен будет сбрасываться на начало дубликатов по мере обработки каждого дубликата из другого набора данных.    

При наличии остаточного предиката все строки, удовлетворяющие предикату слияния, определяют остаточный предикат, и возвращаются только те строки, которые ему соответствуют.   

Соединение слиянием — очень быстрая операция, но она может оказаться ресурсоемкой, если требуется выполнение операций сортировки. Однако если том данных имеет большой объем, и необходимые данные могут быть получены из существующих индексов сбалансированного дерева с выполненной предварительной сортировкой, соединение слиянием является самым быстрым из доступных алгоритмов соединения.    

## <a name="understanding-hash-joins"></a><a name="hash"></a> Основные сведения о хэш-соединениях
Хэш-соединения могут эффективно обрабатывать большие, несортированные и неиндексированные входы. Они полезны для получения промежуточных результатов в сложных запросах из-за следующего.
-   Промежуточные результаты не индексированы (если только они явным образом не сохранены на диске, а затем проиндексированы) и часто отсортированы не так, как требуется для следующей операции в плане запроса.
-   Оптимизаторы запросов оценивают только размеры промежуточных результатов. Так как для сложных запросов оценки могут быть очень неточны, алгоритмы обработки промежуточных результатов должны быть не только эффективными, но и правильно вырождаться, если объем промежуточных результатов оказался гораздо большим, чем ожидалось.   

Хэш-соединение позволяет уменьшить денормализацию. Денормализация обычно используется для получения более высокой производительности при уменьшении количества операций соединения, несмотря на издержки, вызываемые избыточностью данных, например несогласованных обновлений. Хэш-соединения снижают потребность в денормализации и позволяют осуществлять вертикальное секционирование (представляющее группы столбцов, содержащиеся в одной таблице, в отдельных файлах или индексах) в качестве доступной возможности при реализации физической структуры базы данных.     

Хэш-соединение имеет два входа: **конструктивный** и **пробный**. Оптимизатор запросов распределяет роли таким образом, при котором меньшему входу присваивается значение «конструктивный».    

Хэш-соединения используются во многих операциях совпадающих множеств: внутреннее соединение; левое, правое и полное внешнее соединение; левое и правое полусоединение; пересечение; соединение; разность. Дополнительно модификация хэш-соединения применяется для двойного удаления и группирования, например `SUM(salary) GROUP BY department`. В указанной модификации используется общий вход как для конструктивной, так и для пробной ролей.   

В представленных ниже разделах описываются различные типы хэш-соединений: хэш-соединения в памяти, поэтапные и рекурсивные хэш-соединения.    

### <a name="in-memory-hash-join"></a><a name="inmem_hash"></a> Хэш-соединения в памяти
Перед проведением хэш-соединения производится просмотр или вычисление входного конструктивного значения, а затем в памяти создается хэш-таблица. Каждая строка помещается в сегмент хэша согласно значению, вычисленному для хэш-ключа. В случае если конструктивное входное значение имеет размер, меньший объема доступной памяти, то все строки данных могут быть занесены в хэш-таблицу. После описанного конструктивного этапа предпринимается пробный этап. Производится построковое считывание или вычисление пробного входного значения, для каждой строки вычисляется значение хэш-ключа, затем происходит сканирование сегмента хэша и поиск совпадений.    

### <a name="grace-hash-join"></a><a name="grace_hash"></a> Плавное хэш-соединение
Если размер конструктивного входного значения превышает максимально допустимый объем памяти, то хэш-соединение проводится в несколько шагов. Указанный процесс называется плавным хэш-соединением. Каждый шаг состоит из конструктивной и пробной частей. Исходные конструктивные и пробные входные данные разбиваются на несколько файлов (для этого используются хэш-функции ключей). При использовании хэш-функции для хэш-ключей обеспечивается гарантия нахождения соединяемых записей в общей паре файлов. Таким образом, задача соединения двух объемных входных значений разбивается на несколько более мелких задач. Затем хэш-соединение применяется к каждой паре разделенных файлов.    

### <a name="recursive-hash-join"></a><a name="recursive_hash"></a> Рекурсивное хэш-соединение
Если объем информации, поступающей на конструктивный вход, настолько велик, что для использования обычного внешнего слияния требуется несколько уровней, то операцию разбиения необходимо проводить за несколько шагов на нескольких уровнях. Дополнительные шаги разбиения используются только для секций большого объема. Чтобы максимально ускорить проведение всех шагов разбиения, используются емкие асинхронные операции ввода-вывода, в результате чего один поток может занимать сразу несколько жестких дисков.    

> [!NOTE]
> В случае незначительного превышения допустимого объема памяти конструктивными входными данными происходит совмещение элементов хэш-соединения в памяти и поэтапных хэш-соединений в общий этап. В результате получается гибридное хэш-соединение.   

В процессе оптимизации не всегда удается определить тип используемого хэш-соединения. Поэтому в SQL Server в первую очередь используются хэш-соединения в памяти, а затем, в зависимости от объемов входной конструктивной информации, осуществляется переход на поэтапное или рекурсивное хэш-соединение.    

В случае неверного определения конструктивного и пробного входов в оптимизаторе запросов их переключение осуществляется динамически. При использовании хэш-соединения осуществляется контроль использования меньшего файла в качестве конструктивного входа. Данная функция называется "переключением ролей". Переключение ролей происходит внутри хэш-соединения после сброса информации на диск.     

> [!NOTE]
> Переключение ролей происходит независимо от указаний запроса или структуры запроса. Событие «переключение ролей» не отображается в плане запроса, и сообщение о нем выдается пользователю непосредственно после выполнения.

### <a name="hash-bailout"></a><a name="hash_bailout"></a> Аварийная остановка хэша
Термин "аварийная остановка хэша" иногда используется для описания поэтапных и рекурсивных хэш-соединений.    

> [!NOTE]
> Наличие рекурсивных хэш-соединений и аварийных остановок снижает производительность сервера. Если в трассировке содержится много "событий-предупреждений хэша", необходимо произвести обновление статистических данных соединяемых столбцов.    

Дополнительные сведения об аварийных остановках хэша см. в разделе [Класс событий Hash Warning](../../relational-databases/event-classes/hash-warning-event-class.md).    

## <a name="understanding-adaptive-joins"></a><a name="adaptive"></a> Основные сведения об адаптивных соединениях
Адаптивные соединения в [пакетном режиме](../../relational-databases/query-processing-architecture-guide.md#batch-mode-execution) позволяют отложить выбор метода [Хэш-соединение](#hash) или [Соединение вложенными циклами](#nested_loops)**до** завершения сканирования первых входных данных. Оператор адаптивного соединения определяет пороговое значение, по которому принимается решение о переключении на план вложенного цикла. Таким образом, во время выполнения план запроса может динамически переключаться на более эффективную стратегию соединения без перекомпиляции. 

> [!TIP]
> Наиболее полезной эта функция будет для рабочих нагрузок с частыми переключениями между просмотрами входных данных мелких и крупных соединений.

Решение для среды выполнения зависит от следующего:
-  Если число строк во входных данных соединения сборки настолько мало, что соединение вложенными циклами будет эффективнее хэш-соединения, план переключается на алгоритм вложенных циклов.
-  Если число строк во входных данных соединения сборки превышает порог, переключение не выполняется и план продолжает использовать хэш-соединение.

Следующий запрос используется в качестве наглядного примера адаптивного соединения:

```sql
SELECT [fo].[Order Key], [si].[Lead Time Days], [fo].[Quantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Dimension].[Stock Item] AS [si]
       ON [fo].[Stock Item Key] = [si].[Stock Item Key]
WHERE [fo].[Quantity] = 360;
```

Этот запрос возвращает 336 строк. Если включить функцию [Статистика активных запросов](../../relational-databases/performance/live-query-statistics.md), отобразится следующий план:

![Результат запроса: 336 строк](../../relational-databases/performance/media/4_AQPStats336Rows.png)

Обратите внимание на следующие моменты в плане:
1. Просмотр индекса columnstore, используемый с целью предоставления строк для этапа сборки хэш-соединения.
2. Новый оператор адаптивного соединения. Он определяет пороговое значение, по которому принимается решение о переключении на план вложенного цикла. В этом примере порог равен 78 строкам. Если число строк &gt;= 78, будет использоваться хэш-соединение. Если значение меньше порога, будет использоваться соединение вложенными циклами.
3. Так как запрос возвращает 336 строк, порог превышен. Поэтому вторая ветвь представляет пробный этап стандартной операции хэш-соединения. Обратите внимание, что статистика активных запросов показывает строки, передаваемые через операторы — в данном случае это "672 из 672".
4. И последняя ветвь — поиск кластеризованного индекса, используемый соединением вложенными циклами, если порог не был превышен. Обратите внимание, что мы видим число строк "0 из 336" (ветвь не используется).

Теперь давайте сравним план с таким же запросом, но для случая, когда значение *Quantity* будет иметь всего одну строку в таблице:
 
```sql
SELECT [fo].[Order Key], [si].[Lead Time Days], [fo].[Quantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Dimension].[Stock Item] AS [si]
       ON [fo].[Stock Item Key] = [si].[Stock Item Key]
WHERE [fo].[Quantity] = 361;
```
Запрос возвращает одну строку. Если включить функцию "Статистика активных запросов", отобразится следующий план:

![Результатом запроса является одна строка.](../../relational-databases/performance/media/5_AQPStatsOneRow.png)

Обратите внимание на следующие моменты в плане:
- При возврате одной строки видно, что теперь через поиск кластеризованного индекса передаются строки.
- А так как этап сборки хэш-соединения не продолжается, никакие строки через вторую ветвь не передаются.

### <a name="adaptive-join-remarks"></a>Примечания к адаптивным соединениям
Адаптивные соединения предъявляют более высокие требования к памяти, чем эквивалентный план соединения вложенными циклами индекса. Дополнительная память запрашивается так, как если бы вложенный цикл был хэш-соединением. Существуют также издержки на этапе сборки, такие как стартстопная операция и эквивалентное потоковое соединение вложенными циклами. Эти дополнительные затраты обеспечивают гибкость для сценариев, где количество строк во входных данных сборки может меняться.

Адаптивные соединения в пакетном режиме используются для первого выполнения инструкции. После компиляции последовательные выполнения остаются адаптивными с учетом порога скомпилированных адаптивных соединений и строк времени выполнения, передаваемых через этап сборки внешних входных данных.

Если адаптивное соединение переключается на режим вложенного цикла, оно использует строки, уже считанные сборкой хэш-соединения. Этот оператор **не** считывает повторно строки по внешней ссылке.

### <a name="tracking-adaptive-join-activity"></a>Отслеживание операций адаптивного соединения
Оператор адаптивного соединения имеет следующие атрибуты оператора плана:

|Атрибут плана|Описание|
|---|---|
|AdaptiveThresholdRows|Показывает пороговое значение, используемое для переключения с хэш-соединения на соединение вложенными циклами.|
|EstimatedJoinType|К какому типу, вероятнее всего, относится соединение.|
|ActualJoinType|В фактическом плане показывает, какой итоговый алгоритм соединения был выбран на базе порогового значения.|

Предполагаемый план показывает форму плана адаптивного соединения, а также определенное пороговое значение адаптивного соединения и предполагаемый тип соединения.

> [!TIP]
> Хранилище запросов захватывает и может принудительно применить план адаптивного соединения в пакетном режиме.

### <a name="adaptive-join-eligible-statements"></a>Допустимые инструкции адаптивного соединения
Чтобы логическое соединение стало допустимым для адаптивного соединения в пакетном режиме, должны выполняться следующие условия:
- Уровень совместимости базы данных имеет значение 140 или больше.
- Запрос является инструкцией `SELECT` (инструкции для изменения данных сейчас недопустимы).
- Соединение может выполняться посредством как индексированного соединения вложенными циклами, так и физического алгоритма хэш-соединения.
- Хэш-соединение использует пакетный режим, реализуемый за счет того, что во всем запросе присутствует индекс columnstore. Либо на таблицу индекса columnstore ссылается само соединение, либо [пакетный режим используется для функции rowstore](./intelligent-query-processing.md#batch-mode-on-rowstore).
- Созданные альтернативные решения соединения вложенными циклами и хэш-соединения должны иметь одинаковый первый дочерний элемент (внешняя ссылка).

### <a name="adaptive-threshold-rows"></a>Строки адаптивного порогового значения
На приведенной ниже диаграмме показан пример пересечения между показателем затрат хэш-соединения и таким показателем альтернативного ему соединения вложенными циклами. В этой точке пересечения определяется пороговое значение, что, в свою очередь, определяет фактический алгоритм, используемый для операции соединения.

![Пороговое значение соединения](../../relational-databases/performance/media/6_AQPJoinThreshold.png)

### <a name="disabling-adaptive-joins-without-changing-the-compatibility-level"></a>Отключение адаптивных соединений без изменения уровня совместимости
Адаптивные соединения можно отключить в области базы данных или инструкции, сохранив уровень совместимости базы данных 140 или более высокий.  
Чтобы отключить адаптивные соединения для всех запросов, поступающих из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
-- SQL Server 2017
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_BATCH_MODE_ADAPTIVE_JOINS = ON;

-- Azure SQL Database, SQL Server 2019 and higher
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ADAPTIVE_JOINS = OFF;
```

Когда этот параметр включен, он будет иметь соответствующее состояние в представлении [sys.database_scoped_configurations](../../relational-databases/system-catalog-views/sys-database-scoped-configurations-transact-sql.md).
Чтобы снова включить адаптивные соединения для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
-- SQL Server 2017
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_BATCH_MODE_ADAPTIVE_JOINS = OFF;

-- Azure SQL Database, SQL Server 2019 and higher
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ADAPTIVE_JOINS = ON;
```

Вы также можете отключить адаптивные соединения для определенного запроса, назначив `DISABLE_BATCH_MODE_ADAPTIVE_JOINS` в качестве [указания запроса USE HINT](../../t-sql/queries/hints-transact-sql-query.md#use_hint). Пример:

```sql
SELECT s.CustomerID,
       s.CustomerName,
       sc.CustomerCategoryName
FROM Sales.Customers AS s
LEFT OUTER JOIN Sales.CustomerCategories AS sc
       ON s.CustomerCategoryID = sc.CustomerCategoryID
OPTION (USE HINT('DISABLE_BATCH_MODE_ADAPTIVE_JOINS')); 
```

> [!NOTE]
> Указание запроса USE HINT имеет приоритет над конфигурацией, областью действия которой является база данных, или флагом трассировки. 

## <a name="null-values-and-joins"></a><a name="nulls_joins"></a> Значения NULL и соединения
Если в столбцах, по которым производится соединение таблиц, есть значение NULL, значения NULL друг с другом совпадать не будут. Наличие таких значений в столбце одной из соединяемых таблиц возможно только при использовании внешнего соединения (если только предложение `WHERE` не исключает значение NULL).     

Ниже приведены две таблицы, каждая из которых может содержать NULL в столбце, по которому проводится соединение:     

```
table1                          table2
a           b                   c            d
-------     ------              -------      ------
      1        one                 NULL         two
   NULL      three                    4        four
      4      join4
```    

Соединение, сравнивающее значения в столбце a со значениями столбца c, не создает совпадений, если столбцы имеют значение NULL:

```sql
SELECT *
FROM table1 t1 JOIN table2 t2
   ON t1.a = t2.c
ORDER BY t1.a;
GO
```  

Возвращена только одна строка со значением 4 в столбцах a и c:

```
a           b      c           d      
----------- ------ ----------- ------ 
4           join4  4           four   

(1 row(s) affected)
```   

Значения NULL, возвращаемые из базовой таблицы, также сложно отличить от значений NULL, возвращаемых при внешнем соединении. Например, следующая инструкция `SELECT` выполняет левое внешнее соединение этих двух таблиц.   

```sql
SELECT *
FROM table1 t1 LEFT OUTER JOIN table2 t2
   ON t1.a = t2.c
ORDER BY t1.a;
GO
```   

[!INCLUDE[ssResult](../../includes/ssresult-md.md)]   

```
a           b      c           d      
----------- ------ ----------- ------ 
NULL        three  NULL        NULL 
1           one    NULL        NULL 
4           join4  4           four   

(3 row(s) affected)
```   

В результате сложно определить, какие значения NULL получены из данных, а какие означают неуспешное соединение. Если в соединениях данных присутствуют значения NULL, чаще всего желательно исключить их из результатов с помощью обычного соединения.    

## <a name="see-also"></a>См. также:  
[Справочник по логическим и физическим операторам Showplan](../../relational-databases/showplan-logical-and-physical-operators-reference.md)     
[Операторы сравнения (Transact-SQL)](../../t-sql/language-elements/comparison-operators-transact-sql.md)    
[Преобразование типов данных (ядро СУБД)](../../t-sql/data-types/data-type-conversion-database-engine.md)   
[Вложенные запросы](../../relational-databases/performance/subqueries.md)      
[Адаптивное соединение](../../relational-databases/performance/intelligent-query-processing.md#batch-mode-adaptive-joins)    
[Предложение FROM и JOIN, APPLY, PIVOT (Transact-SQL)](../../t-sql/queries/from-transact-sql.md)
