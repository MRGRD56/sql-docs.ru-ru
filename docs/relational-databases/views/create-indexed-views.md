---
description: Создание индексированных представлений
title: Создание индексированных представлений | Документация Майкрософт
ms.custom: ''
ms.date: 11/19/2018
ms.prod: sql
ms.prod_service: table-view-index, sql-database, sql-data-warehouse, pdw
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- indexed views [SQL Server], creating
- clustered indexes, views
- CREATE INDEX statement
- large_value_types_out_of_row option
- indexed views [SQL Server]
- views [SQL Server], indexed views
ms.assetid: f86dd29f-52dd-44a9-91ac-1eb305c1ca8d
author: stevestein
ms.author: sstein
monikerRange: =azuresqldb-current||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 872d40262da465bac6e336472e8beca402482b5f
ms.sourcegitcommit: 1a544cf4dd2720b124c3697d1e62ae7741db757c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2020
ms.locfileid: "97484376"
---
# <a name="create-indexed-views"></a>Создание индексированных представлений

[!INCLUDE [SQL Server SQL Database](../../includes/applies-to-version/sql-asdb.md)]

В этой статье описывается, как создавать индексы в представлении. Первым индексом, создаваемым для представления, должен быть уникальный кластеризованный индекс. После создания уникального кластеризованного индекса могут быть созданы некластеризованные индексы. Создание уникального кластеризованного индекса для представления повышает производительность запросов, т. к. представление хранится в базе данных так же, как и таблица с кластеризованным индексом. Оптимизатор запросов может использовать индексированные представления для ускорения выполнения запросов. Чтобы оптимизатор рассматривал представление для подстановки, это представление не обязательно должно быть указано в запросе.

## <a name="before-you-begin"></a><a name="BeforeYouBegin"></a> Перед началом

Чтобы создать индексированное представление, нужно выполнить следующие шаги. Точность при их выполнении критически важна для успешной реализации индексированного представления.

1. Убедитесь в правильности параметров SET для всех существующих таблиц, на которые ссылается представление.
2. Прежде чем создавать новые таблицы и представление, проверьте параметры SET для сеанса.
3. Проверьте, что определение представления детерминировано.
4. Создайте представление с помощью параметра `WITH SCHEMABINDING`.
5. Создайте уникальный кластеризованный индекс для представления.

> [!IMPORTANT]
> При выполнении DML<sup>1</sup> для таблицы, на которую ссылается большое количество индексированных представлений либо меньшее количество очень сложных индексированных представлений, эти упоминаемые индексированные представления также потребуется обновить. В результате может значительно снизиться производительность запросов DML, а в некоторых случаях может быть невозможно даже создать план запроса.
> В таких ситуациях протестируйте запросы DML перед использованием в рабочей среде, проанализируйте план запроса и настройте или упростите инструкцию DML.
>
> <sup>1</sup> Например, операции UPDATE, DELETE или INSERT.

### <a name="required-set-options-for-indexed-views"></a><a name="Restrictions"></a> Обязательные параметры SET для индексированных представлений

Если при выполнении запроса активны разные параметры SET, выполнение одного и того же выражения может дать разные результаты в [!INCLUDE[ssDE](../../includes/ssde-md.md)] . Например, если параметр SET `CONCAT_NULL_YIELDS_NULL` равен ON, выражение `'abc' + NULL` возвращает значение `NULL`. Однако если параметр `CONCAT_NULL_YIELDS_NULL` равен OFF, то же самое выражение дает результат `'abc'`.

Для правильной поддержки представлений и получения согласованных результатов некоторые параметры SET индексированных представлений должны иметь определенные значения. В приведенных ниже случаях параметрам SET из следующей таблицы нужно присвоить значения, указанные в столбце **Обязательное значение** :

- Будет создано представление с соответствующими индексами в нем.
- Базовые таблицы, на которые ссылается представление в момент создания представления.
- С любой из таблиц, используемых в индексированном представлении, выполняется операция вставки, обновления или удаления. Это требование охватывает такие операции, как массовое копирование, репликация и распределенные запросы.
- Индексированное представление используется оптимизатором запросов для создания плана запроса.

|Параметры SET|Обязательное значение|Значение сервера по умолчанию|По умолчанию<br /><br /> Значение OLE DB и ODBC|По умолчанию<br /><br /> Значение DB-Library|
|-----------------|--------------------|--------------------------|---------------------------------------|-----------------------------------|
|ANSI_NULLS|ON|ON|ON|OFF|
|ANSI_PADDING|ON|ON|ON|OFF|
|ANSI_WARNINGS<sup>1</sup>|ON|ON|ON|OFF|
|ARITHABORT|ON|ON|OFF|OFF|
|CONCAT_NULL_YIELDS_NULL|ON|ON|ON|OFF|
|NUMERIC_ROUNDABORT|OFF|OFF|OFF|OFF|
|QUOTED_IDENTIFIER|ON|ON|ON|OFF|
|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|

<sup>1</sup> Если параметру `ANSI_WARNINGS` присвоить значение ON, то для параметра `ARITHABORT` будет неявно задано значение ON.

Если используется соединение с сервером через интерфейсы OLE DB или ODBC, достаточно изменить параметр `ARITHABORT`. Все значения DB-Library должны быть правильно установлены на уровне сервера с помощью хранимой процедуры **sp_configure** или из приложения с помощью команды SET.

> [!IMPORTANT]
> Настоятельно рекомендуется присвоить пользовательскому параметру `ARITHABORT` значение ON на всем сервере, как только в какой-либо базе данных сервера будет создано первое индексированное представление или индекс на базе вычисляемого столбца.

### <a name="deterministic-views"></a>Детерминированные представления

Определение индексированного представления должно быть детерминированным. Представление детерминировано, если детерминированы все выражения в списке выбора, а также предложения `WHERE` и `GROUP BY`. Детерминированные выражения возвращают одни и те же результаты при каждом вычислении с одним и тем же набором входных значений. Только детерминированные функции могут использоваться в детерминированных выражениях. Например, функция `DATEADD` детерминирована, так как всегда возвращает один и тот же результат для любого заданного набора значений аргументов трех ее параметров. Функция `GETDATE` не детерминирована, так как всегда вызывается с одним и тем же аргументом, но каждый раз возвращает разные значения.

Чтобы определить, является ли столбец представления детерминированным, используйте свойство **IsDeterministic** функции [COLUMNPROPERTY](../../t-sql/functions/columnproperty-transact-sql.md) . Чтобы определить, является ли точным детерминированный столбец в представлении с привязкой к схеме, используйте свойство **IsPrecise** функции `COLUMNPROPERTY`. Функция `COLUMNPROPERTY` возвращает значение 1, если TRUE, 0, если FALSE, и NULL в случае недопустимого входного значения. Это означает, что столбец не является детерминированным или точным.

Даже если выражение детерминировано, если оно содержит выражения с плавающей запятой, результат может зависеть от архитектуры процессора или версии микропрограммы. Для сохранения целостности данных такие выражения могут быть только неключевыми столбцами индексированных представлений. Детерминированные выражения, не содержащие выражений с плавающей запятой, называются точными выражениями. Только точные детерминированные выражения могут содержаться в ключевых столбцах и предложениях `WHERE` или `GROUP BY` индексированных представлений.

### <a name="additional-requirements"></a>Дополнительные требования

Кроме требований, касающихся параметров SET и детерминированных функций, должны выполняться следующие требования.

- Пользователь, выполняющий инструкцию `CREATE INDEX`, должен быть владельцем представления.
- При создании индекса параметр `IGNORE_DUP_KEY` должен быть установлен в OFF (значение по умолчанию).
- Имя таблицы в определении представления должно быть двухкомпонентным: _схема_ **.** _имя_таблицы_ .
- Определяемые пользователем функции, на которые ссылается представление, должны быть созданы с параметром `WITH SCHEMABINDING`.
- Все определяемые пользователем функции, на которые ссылается представление, должны иметь двухкомпонентные имена, _\<schema\>_ **.** _\<function\>_ .
- Свойство доступа к данным пользовательской функции должно быть установлено в значение `NO SQL`, а свойство внешнего доступа — в `NO`.
- Функции среды CLR могут быть указаны в списке выбора представления, но не могут быть частью определения ключа кластеризованного индекса. Функции CLR нельзя указывать в представлении в предложении WHERE и предложении ON операции JOIN.
- Функции и методы CLR определяемого пользователем типа данных, используемые в определении представления, должны иметь свойства, установленные так, как показано в следующей таблице.

   |Свойство|Примечание|
   |--------------|----------|
   |DETERMINISTIC = TRUE|Должно быть объявлено явно в качестве атрибута метода Microsoft .NET Framework.|
   |PRECISE = TRUE|Должно быть объявлено явно в качестве атрибута метода .NET Framework.|
   |DATA ACCESS = NO SQL|Определяется установкой атрибута DataAccess в DataAccessKind.None и атрибута SystemDataAccess в SystemDataAccessKind.None.|
   |EXTERNAL ACCESS = NO|Для процедур CLR значением свойства по умолчанию является NO.|
   |&nbsp;|&nbsp;|

- Представления должны быть созданы с параметром `WITH SCHEMABINDING`.
- В представлении допустимы ссылки только на базовые таблицы той же самой базы данных. Ссылки на другие представления недопустимы.

- Если присутствует предложение `GROUP BY`, определение VIEW должно содержать `COUNT_BIG(*)` и не должно содержать `HAVING`. Эти ограничения для предложения `GROUP BY` относятся только к определению индексированного представления. Запрос может использовать индексированное представление в своем плане выполнения, даже если он не соответствует этим ограничениям для предложения `GROUP BY`.
- Если определение представления содержит предложение `GROUP BY`, ключ уникального кластеризованного индекса может включать только столбцы, указанные в предложении `GROUP BY`.

- Инструкция SELECT в определении представления не должна содержать следующие элементы языка Transact-SQL:

   | Элементы Transact-SQL | (продолжение) | (продолжение) |
   | --------------------- | ----------- | ----------- |
   |`COUNT`|Функции ROWSET (`OPENDATASOURCE`, `OPENQUERY`, `OPENROWSET` И `OPENXML`)|Объединения `OUTER` (`LEFT`, `RIGHT` или `FULL`)|
   |Производная таблица (определяемая путем указания инструкции `SELECT` в предложении `FROM`)|Самосоединения|Указание столбцов с использованием `SELECT *` или `SELECT <table_name>.*`|
   |`DISTINCT`|`STDEV`, `STDEVP`, `VAR`, `VARP` или `AVG`|Обобщенное табличное выражение (CTE)|
   |Столбцы **float**<sup>1</sup>, **text**, **ntext**, **image**, **XML** или **filestream**|Вложенный запрос|Предложение `OVER`, включающее статистические функции или агрегатные оконные функции|
   |Полнотекстовые предикаты (`CONTAINS`, `FREETEXT`)|Функция `SUM`, ссылающаяся на выражение, допускающее значение NULL|`ORDER BY`|
   |Определяемая пользователем агрегатная функция CLR|`TOP`|Операторы `CUBE`, `ROLLUP` или `GROUPING SETS`|
   |`MIN`, `MAX`|Операторы `UNION`, `EXCEPT` или `INTERSECT`|`TABLESAMPLE`|
   |Табличные переменные|`OUTER APPLY` либо `CROSS APPLY`|`PIVOT`, `UNPIVOT`|
   |Наборы разреженных столбцов|Встроенные функции (TVF) или функции с табличным значением с несколькими инструкциями (MSTVF)|`OFFSET`|
   |`CHECKSUM_AGG`|||

   <sup>1</sup> Индексированное представление может содержать столбцы типа **float**, но они не могут включаться в ключ кластеризованного индекса.

   > [!IMPORTANT]
   > Добавление индексированных представлений в темпоральные запросы (запросы, использующие предложение `FOR SYSTEM_TIME`) не поддерживается.

### <a name="recommendations"></a><a name="Recommendations"></a> Рекомендации

При ссылке на строковые литералы **datetime** и **smalldatetime** из индексированных представлений рекомендуется явно преобразовывать литерал к нужному типу даты при помощи детерминированного стиля формата даты. Список детерминированных стилей форматирования даты см. в разделе [Функции CAST и CONVERT (Transact-SQL)](../../t-sql/functions/cast-and-convert-transact-sql.md). Дополнительные сведения о детерминированных и недетерминированных выражениях см. в разделе [Замечания](#nondeterministic).

При выполнении DML (например, `UPDATE`, `DELETE` или `INSERT`) для таблицы, на которую ссылается большое количество индексированных представлений либо меньшее количество очень сложных индексированных представлений, эти индексированные представления также потребуется обновить. В результате может значительно снизиться производительность запросов DML, а в некоторых случаях может быть невозможно даже создать план запроса. В таких ситуациях протестируйте запросы DML перед использованием в рабочей среде, проанализируйте план запроса и настройте или упростите инструкцию DML.

### <a name="considerations"></a><a name="Considerations"></a> Замечания

Значение параметра **large_value_types_out_of_row** столбца в индексированном представлении наследуется от значения соответствующего столбца базовой таблицы. Это значение задается с помощью хранимой процедуры [sp_tableoption](../../relational-databases/system-stored-procedures/sp-tableoption-transact-sql.md). Для столбцов, созданных из выражений, установкой по умолчанию является 0. Это означает, что типы больших значений хранятся в строке.

Индексированные представления могут создаваться на секционированной таблице и сами могут быть секционированными.

Чтобы компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] не использовал индексированные представления, включите в запрос указание `OPTION (EXPAND VIEWS)`. Кроме того, если любой из вышеуказанных параметров установлен неправильно, оптимизатор не сможет использовать индексы представлений. Дополнительные сведения об указании `OPTION (EXPAND VIEWS)` см. в разделе [SELECT (Transact-SQL)](../../t-sql/queries/select-transact-sql.md).

При удалении представления удаляются также и все его индексы. При удалении кластеризованного индекса удаляются все некластеризованные индексы и автоматически созданные для представления статистики. Статистики, созданные пользователем, сохраняются. Некластеризованные индексы могут удаляться по отдельности. При удалении кластеризованного индекса представления удаляется сохраненный результирующий набор, и оптимизатор снова начинает работать с ним, как с обычным представлением.

Индексы таблиц и представлений могут быть отключены. При отключении кластеризованного индекса таблицы индексы представлений, связанных с ней, также отключаются.

<a name="nondeterministic"></a> Выражения, включающие неявные преобразования символьных строк в типы **datetime** или **smalldatetime**, считаются недетерминированными. Дополнительные сведения см. в статье [Недетерминированное преобразование строк дат литералов в значения DATE](../../t-sql/data-types/nondeterministic-convert-date-literals.md).

### <a name="security"></a><a name="Security"></a> безопасность

#### <a name="permissions"></a><a name="Permissions"></a> Permissions

Для выполнения этой инструкции требуется разрешение **CREATE VIEW** в отношении базы данных и разрешение **ALTER** в отношении схемы, в которой создается представление.

## <a name="using-transact-sql"></a><a name="TsqlProcedure"></a> Использование Transact-SQL

### <a name="to-create-an-indexed-view"></a>Создание индексируемого представления

В следующем примере создаются представление и индекс этого представления. Включено два запроса, использующих созданное индексированное представление в базе данных AdventureWorks.

```sql
--Set the options to support indexed views.
SET NUMERIC_ROUNDABORT OFF;
SET ANSI_PADDING, ANSI_WARNINGS, CONCAT_NULL_YIELDS_NULL, ARITHABORT,
   QUOTED_IDENTIFIER, ANSI_NULLS ON;
--Create view with schemabinding.
IF OBJECT_ID ('Sales.vOrders', 'view') IS NOT NULL
   DROP VIEW Sales.vOrders ;
GO
CREATE VIEW Sales.vOrders
   WITH SCHEMABINDING
   AS  
      SELECT SUM(UnitPrice*OrderQty*(1.00-UnitPriceDiscount)) AS Revenue,
         OrderDate, ProductID, COUNT_BIG(*) AS COUNT
      FROM Sales.SalesOrderDetail AS od, Sales.SalesOrderHeader AS o
      WHERE od.SalesOrderID = o.SalesOrderID
      GROUP BY OrderDate, ProductID;
GO
--Create an index on the view.
CREATE UNIQUE CLUSTERED INDEX IDX_V1
   ON Sales.vOrders (OrderDate, ProductID);
GO
--This query can use the indexed view even though the view is
--not specified in the FROM clause.
SELECT SUM(UnitPrice*OrderQty*(1.00-UnitPriceDiscount)) AS Rev,
   OrderDate, ProductID
FROM Sales.SalesOrderDetail AS od
JOIN Sales.SalesOrderHeader AS o
   ON od.SalesOrderID=o.SalesOrderID
      AND ProductID BETWEEN 700 and 800
      AND OrderDate >= CONVERT(datetime,'05/01/2002',101)
   GROUP BY OrderDate, ProductID
   ORDER BY Rev DESC;
GO
--This query can use the above indexed view.
SELECT OrderDate, SUM(UnitPrice*OrderQty*(1.00-UnitPriceDiscount)) AS Rev
FROM Sales.SalesOrderDetail AS od
JOIN Sales.SalesOrderHeader AS o
   ON od.SalesOrderID=o.SalesOrderID
      AND DATEPART(mm,OrderDate)= 3
      AND DATEPART(yy,OrderDate) = 2002
    GROUP BY OrderDate
    ORDER BY OrderDate ASC;
```

Дополнительные сведения см. в статье [CREATE VIEW (Transact-SQL)](../../t-sql/statements/create-view-transact-sql.md).

## <a name="see-also"></a>См. также:

- [CREATE INDEX](../../t-sql/statements/create-index-transact-sql.md)
- [SET ANSI_NULLS](../../t-sql/statements/set-ansi-nulls-transact-sql.md)
- [SET ANSI_PADDING](../../t-sql/statements/set-ansi-padding-transact-sql.md)
- [SET ANSI_WARNINGS](../../t-sql/statements/set-ansi-warnings-transact-sql.md)
- [SET ARITHABORT](../../t-sql/statements/set-arithabort-transact-sql.md)
- [SET CONCAT_NULL_YIELDS_NULL](../../t-sql/statements/set-concat-null-yields-null-transact-sql.md)
- [SET NUMERIC_ROUNDABORT](../../t-sql/statements/set-numeric-roundabort-transact-sql.md)
- [SET QUOTED_IDENTIFIER](../../t-sql/statements/set-quoted-identifier-transact-sql.md)  
