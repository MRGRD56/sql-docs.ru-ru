---
description: Ограничения первичных и внешних ключей
title: Ограничения первичных и внешних ключей | Документация Майкрософт
ms.custom: ''
ms.date: 07/25/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- foreign keys [SQL Server], cascading referential integrity
- FOREIGN KEY constraints
- foreign keys [SQL Server]
- foreign keys [SQL Server], about foreign key constraints
ms.assetid: 31fbcc9f-2dc5-4bf9-aa50-ed70ec7b5bcd
author: stevestein
ms.author: sstein
monikerRange: =azuresqldb-current||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 091ebaf16d46cdde5604e532a80f1dd1177586c6
ms.sourcegitcommit: f29f74e04ba9c4d72b9bcc292490f3c076227f7c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/13/2021
ms.locfileid: "98172466"
---
# <a name="primary-and-foreign-key-constraints"></a>Ограничения первичных и внешних ключей

[!INCLUDE [sqlserver2016-asdb-asdbmi](../../includes/applies-to-version/sqlserver2016-asdb-asdbmi.md)]

  Первичные и внешние ключи представляют собой два типа ограничений, которые могут использоваться для обеспечения целостности данных в таблицах [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Это важные объекты базы данных.  
  
 В этом разделе содержатся следующие подразделы.  
  
 [Ограничения первичного ключа](../../relational-databases/tables/primary-and-foreign-key-constraints.md#PKeys)  
  
 [Foreign Key Constraints](../../relational-databases/tables/primary-and-foreign-key-constraints.md#FKeys)  
  
 [Связанные задачи](../../relational-databases/tables/primary-and-foreign-key-constraints.md#Tasks)  
  
##  <a name="primary-key-constraints"></a><a name="PKeys"></a> Ограничения первичного ключа  
 Обычно в таблице есть столбец или сочетание столбцов, содержащих значения, уникально определяющие каждую строку таблицы. Этот столбец, или столбцы, называются первичным ключом (PK) таблицы и обеспечивает целостность сущности таблицы. Ограничения первичного ключа часто определяются в столбце идентификаторов, поскольку гарантируют уникальность данных.  
  
 При задании ограничения первичного ключа для таблицы компонента [!INCLUDE[ssDE](../../includes/ssde-md.md)] гарантирует уникальность данных путем автоматического создания уникального индекса для первичных ключевых столбцов. Этот индекс также обеспечивает быстрый доступ к данным при использовании первичного ключа в запросах. Если ограничение первичного ключа задано более чем для одного столбца, то значения могут дублироваться в пределах одного столбца, но каждое сочетание значений всех столбцов в определении ограничения первичного ключа должно быть уникальным.  
  
 Как показано на следующем рисунке, столбцы **ProductID** и **VendorID** в таблице **Purchasing.ProductVendor** формируют составное ограничение первичного ключа для данной таблицы. При этом гарантируется, что каждая строка в таблице **ProductVendor** имеет уникальное сочетание значений **ProductID** и **VendorID**. Это предотвращает вставку повторяющихся строк.  
  
 ![Составное ограничение PRIMARY KEY](../../relational-databases/tables/media/fund04.gif "Составное ограничение PRIMARY KEY")  
  
-   В таблице возможно наличие только одного ограничения по первичному ключу.  
  
-   Первичный ключ не может включать больше 16 столбцов, а общая длина ключа не может превышать 900 байт.  
  
-   Индекс, формируемый ограничением первичного ключа, не может повлечь за собой выход количества индексов в таблице за пределы в 999 некластеризованных индексов и 1 кластеризованный.  
  
-   Если для ограничения первичного ключа не указано, является ли индекс кластеризованным или некластеризованным, то создается кластеризованный индекс, если таковой отсутствует в таблице.  
  
-   Все столбцы с ограничением первичного ключа должны быть определены как не допускающие значения NULL. Если допустимость значения NULL не указана, то все столбцы c ограничением первичного ключа устанавливаются как не допускающие значения NULL.  
  
-   Если первичный ключ определен на столбце определяемого пользователем типа данных CLR, реализация этого типа должна поддерживать двоичную сортировку.  
  
##  <a name="foreign-key-constraints"></a><a name="FKeys"></a> Foreign Key Constraints  
 Внешний ключ (FK) — это столбец или сочетание столбцов, которое применяется для принудительного установления связи между данными в двух таблицах с целью контроля данных, которые могут храниться в таблице внешнего ключа. Если один или несколько столбцов, в которых находится первичный ключ для одной таблицы, упоминается в одном или нескольких столбцах другой таблицы, то в ссылке внешнего ключа создается связь между двумя таблицами. Этот столбец становится внешним ключом во второй таблице.  
  
 Например, таблица **Sales.SalesOrderHeader** связана с таблицей **Sales.SalesPerson** с помощью внешнего ключа, так как существует логическая связь между заказами на продажу и менеджерами по продажам. Столбец **SalesPersonID** в таблице **Sales.SalesOrderHeader** соответствует первичному ключевому столбцу в таблице **SalesPerson** . Столбец **SalesPersonID** в таблице **Sales.SalesOrderHeader** является внешним ключом для таблицы **SalesPerson** . С помощью установления данной связи по внешнему ключу значение для **SalesPersonID** не может быть вставлено в таблицу **SalesOrderHeader** , если оно в настоящий момент не содержится в таблице **SalesPerson** .  
  
 Максимальное количество таблиц и столбцов, на которые может ссылаться таблица в качестве внешних ключей (исходящих ссылок), равно 253. [!INCLUDE[ssSQL15](../../includes/sssql16-md.md)] увеличивает ограничение на количество других таблиц и столбцов, которые могут ссылаться на столбцы в одной таблице (входящие ссылки), с 253 до 10 000. (Требуется уровень совместимости не менее 130.) Увеличение имеет следующие ограничения:  
  
-   Превышение 253 ссылок на внешние ключи поддерживается только для операций DML DELETE. Операции UPDATE и MERGE не поддерживаются.  
  
-   Таблица со ссылкой внешнего ключа на саму себя по-прежнему ограничена 253 ссылками на внешние ключи.  
  
-   Превышение 253 ссылок на внешние ключи в настоящее время недоступно для индексов columnstore, оптимизированных для памяти таблиц, базы данных Stretch или секционированных таблиц внешнего ключа.  
  
### <a name="indexes-on-foreign-key-constraints"></a>Индексы в ограничениях внешнего ключа  
 В отличие от ограничений первичного ключа, при создании ограничения внешнего ключа соответствующий индекс автоматически не создается. Тем не менее, часто возникает необходимость создания индекса для внешнего ключа вручную по следующим причинам:  
  
-   Столбцы внешнего ключа часто используются в критериях соединения при совместном применении в запросах данных из связанных таблиц. Это реализуется путем сопоставления столбца или столбцов в ограничении внешнего ключа в одной таблице с одним или несколькими столбцами первичного или уникального ключа в другой таблице. Индекс позволяет компоненту [!INCLUDE[ssDE](../../includes/ssde-md.md)] быстро находить связанные данные в таблице внешних ключей. Впрочем, создание индекса не является обязательным. Данные из двух связанных таблиц можно комбинировать, даже если между таблицами не определены ограничения первичного ключа или внешнего ключа, но связь по внешнему ключу между двумя таблицами показывает, что эти две таблицы оптимизированы для совместного применения в запросе, где ключи используются в качестве критериев.  
  
-   С помощью ограничений внешнего ключа в связанных таблицах проверяются изменения ограничений первичного ключа.  
  
### <a name="referential-integrity"></a>Ссылочная целостность  
 Главная задача ограничения внешнего ключа состоит в управлении данными, которые могут быть сохранены в таблице внешнего ключа, но это ограничение контролирует также изменение данных в таблице первичного ключа. Например, при удалении строки для менеджера по продажам из таблицы **Sales.SalesPerson** , идентификатор которого используется в заказах на продажу в таблице **Sales.SalesOrderHeader** , ссылочная целостность двух таблиц будет нарушена. Заказы на продажу удаленного менеджера в таблице **SalesOrderHeader** станут недействительными без связи с данными в таблице **SalesPerson** .  
  
 Ограничение внешнего ключа предотвращает возникновение этой ситуации. Ограничение обеспечивает целостность ссылок следующим образом: оно запрещает изменение данных в таблице первичного ключа, если такие изменения сделают недопустимой ссылку в таблице внешнего ключа. Если при попытке удалить строку в таблице первичного ключа или изменить значение этого ключа будет обнаружено, что удаленному или измененному значению первичного ключа соответствует определенное значение в ограничении внешнего ключа в другой таблице, то действие выполнено не будет. Для успешного изменения или удаления строки с ограничением внешнего ключа необходимо сначала удалить данные внешнего ключа в таблице внешнего ключа либо изменить в таблице внешнего ключа данные, которые связывают внешний ключ с данными другого первичного ключа.  
  
#### <a name="cascading-referential-integrity"></a>Каскадная ссылочная целостность  
 С помощью каскадных ограничений ссылочной целостности можно определять действия, которые компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] будет предпринимать, когда пользователь попытается удалить или обновить ключ, на который указывают еще существующие внешние ключи. Могут быть определены следующие каскадные действия.  
  
 NO ACTION  
 Компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] формирует ошибку, после чего выполняется откат операции удаления или обновления строки в родительской таблице.  
  
 CASCADE  
 Соответствующие строки обновляются или удаляются из ссылающейся таблицы, если данная строка обновляется или удаляется из родительской таблицы. Значение CASCADE не может быть указано, если столбец типа **timestamp** является частью внешнего или ссылочного ключа. Действие ON DELETE CASCADE не может быть указано в таблице, для которой определен триггер INSTEAD OF DELETE. Предложение ON UPDATE CASCADE не может быть задано применительно к таблицам, для которых определены триггеры INSTEAD OF UPDATE.  
  
 SET NULL  
 Всем значениям, составляющим внешний ключ, присваивается значение NULL, когда обновляется или удаляется соответствующая строка в родительской таблице. Для выполнения этого ограничения внешние ключевые столбцы должны допускать значения NULL. Не может быть задано применительно к таблицам, для которых определены триггеры INSTEAD OF UPDATE.  
  
 SET DEFAULT  
 Все значения, составляющие внешний ключ, при удалении или обновлении соответствующей строки родительской таблицы устанавливаются в значение по умолчанию. Для выполнения этого ограничения все внешние ключевые столбцы должны иметь определения по умолчанию. Если столбец допускает значения NULL и значение по умолчанию явно не определено, значением столбца по умолчанию становится NULL. Не может быть задано применительно к таблицам, для которых определены триггеры INSTEAD OF UPDATE.  
  
 Ключевые слова CASCADE, SET NULL, SET DEFAULT и NO ACTION можно сочетать в таблицах, имеющих взаимные ссылочные связи. Если компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] обнаруживает ключевое слово NO ACTION, оно остановит и произведет откат связанных операций CASCADE, SET NULL и SET DEFAULT. Если инструкция DELETE содержит сочетание ключевых слов CASCADE, SET NULL, SET DEFAULT и NO ACTION, то все операции CASCADE, SET NULL и SET DEFAULT выполняются перед поиском компонентом [!INCLUDE[ssDE](../../includes/ssde-md.md)] операции NO ACTION.  
  
### <a name="triggers-and-cascading-referential-actions"></a>Триггеры и каскадные ссылочные действия  
 Каскадные ссылочные действия запускают триггеры AFTER UPDATE или AFTER DELETE следующим образом:  
  
-   Все каскадные ссылочные действия, прямо вызванные исходными инструкциями DELETE или UPDATE, выполняются первыми.  
  
-   Если есть какие-либо триггеры AFTER, определенные для измененных таблиц, эти триггеры запускаются после выполнения всех каскадных действий. Эти триггеры запускаются в порядке, обратном каскадным действиям. Если для одной таблицы определены несколько триггеров, они запускаются в случайном порядке, если только не указаны выделенные первый и последний триггеры таблицы. Этот порядок определяется процедурой [sp_settriggerorder](../../relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql.md).  
  
-   Если последовательности каскадных действий происходят из таблицы, которая была непосредственной целью действий DELETE или UPDATE, порядок запуска триггеров этими последовательностями действий не определен. Однако одна последовательность действий всегда запускает все свои триггеры до того, как это начнет делать следующая.  
  
-   Триггер AFTER таблицы, являвшейся непосредственной целью действий DELETE или UPDATE, запускается вне зависимости от того, были ли изменены хоть какие-нибудь строки. В этом случае ни на какие другие таблицы каскадирование не влияет.  
  
-   Если один из предыдущих триггеров выполняет операции DELETE или UPDATE над другими таблицами, эти операции могут вызывать собственные последовательности каскадных действий. Эти вторичные последовательности действий обрабатываются для каждой операции DELETE или UPDATE после выполнения всех триггеров первичных последовательностей действий. Этот процесс может рекурсивно повторяться для последующих операций DELETE или UPDATE.  
  
-   Выполнение операций CREATE, ALTER, DELETE или других операций языка DDL внутри триггеров может привести к запуску триггеров DDL. Это может привести к дальнейшим операциям DELETE или UPDATE, которые начнут дополнительные последовательности каскадных действий и запустят свои триггеры.  
  
-   Если в любой конкретной последовательности каскадных ссылочных действий произойдет ошибка, в этой последовательности не будут запущены никакие триггеры AFTER, а для операций DELETE или UPDATE, создаваемых этой последовательностью, будет выполнен откат.  
  
-   У таблицы, для которой определен триггер INSTEAD OF, может также быть предложение REFERENCES, указывающее конкретное каскадное действие. Однако триггер AFTER целевой таблицы каскадного действия может выполнить инструкцию INSERT, UPDATE или DELETE для другой таблицы или представления, которое запустит триггер INSTEAD OF для этого объекта.  
  
##  <a name="related-tasks"></a><a name="Tasks"></a> Связанные задачи  
 В следующей таблице перечислены общие задачи, связанные с ограничениями первичного ключа и внешнего ключа.  
  
|Задача|Раздел|  
|----------|-----------|  
|Описывает, как создать первичный ключ.|[Создание первичных ключей](../../relational-databases/tables/create-primary-keys.md)|  
|Описывает, как удалить первичный ключ.|[Удаление первичных ключей](../../relational-databases/tables/delete-primary-keys.md)|  
|Описывает, как изменить первичный ключ.|[Изменение первичных ключей](../../relational-databases/tables/modify-primary-keys.md)|  
|Описывается создание связей внешнего ключа|[Создание связей по внешнему ключу](../../relational-databases/tables/create-foreign-key-relationships.md)|  
|Описывает, как изменить связи внешнего ключа.|[Изменение связей по внешнему ключу](../../relational-databases/tables/modify-foreign-key-relationships.md)|  
|Описывает, как удалить связи внешнего ключа.|[Удаление связей по внешнему ключу](../../relational-databases/tables/delete-foreign-key-relationships.md)|  
|Описывает, как просматривать свойства внешнего ключа.|[Просмотр свойств внешнего ключа](../../relational-databases/tables/view-foreign-key-properties.md)|  
|Описывает, как отключить ограничения внешнего ключа для репликации.|[Отключение ограничений внешнего ключа для репликации](../../relational-databases/tables/disable-foreign-key-constraints-for-replication.md)|  
|Описывает, как отключить ограничения внешнего ключа на время выполнения инструкций INSERT и UPDATE.|[Отключение ограничений внешнего ключа для инструкций INSERT и UPDATE](../../relational-databases/tables/disable-foreign-key-constraints-with-insert-and-update-statements.md)|  
  
  
