---
title: 'Планирование внедрения выполняющейся в памяти OLTP '
description: Узнайте, как внедрение функций выполняющейся в памяти OLTP в SQL Server влияет на другие аспекты бизнес-системы.
ms.custom: seo-dt-2019
ms.date: 01/28/2019
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 041b428f-781d-4628-9f34-4d697894e61e
author: MightyPen
ms.author: genemi
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 8eabca1300e3937d4b1a1f48531c9cc09b1978dd
ms.sourcegitcommit: 4d370399f6f142e25075b3714e5c2ce056b1bfd0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2020
ms.locfileid: "91867099"
---
# <a name="plan-your-adoption-of-in-memory-oltp-features-in-sql-server"></a>Планирование освоения возможностей выполняющейся в памяти OLTP в SQL Server
[!INCLUDE [SQL Server Azure SQL Database](../../includes/applies-to-version/sql-asdb.md)]


В этой статье описывается, как освоение возможностей технологии обработки в памяти влияет на другие аспекты вашей бизнес-системы.



## <a name="a-adoption-of-in-memory-oltp-features"></a>A. Освоение возможностей выполняющейся в памяти OLTP


В следующих подразделах описываются факторы, которые необходимо учитывать при планировании освоения и реализации возможностей технологии обработки в памяти. Пояснительная информация в значительном объеме доступна в следующей статье:

- [Повышение производительности приложений в Базе данных SQL Azure с помощью выполняющейся в памяти OLTP](/azure/azure-sql/in-memory-oltp-configure)



### <a name="a1-prerequisites"></a>A.1. Предварительные условия

Одним из предварительных требований, связанных с использованием возможностей технологии обработки в памяти, может являться наличие определенного выпуска продукта SQL или уровня SQL-службы. Это и другие предварительные требования описаны в следующих источниках:

- [Требования для использования таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/requirements-for-using-memory-optimized-tables.md)
    - [Выпуски и компоненты SQL Server 2016](../../sql-server/editions-and-components-of-sql-server-2016.md)
    - [Рекомендации по ценовому уровню базы данных SQL](/azure/azure-sql/database/service-tiers-vcore)


### <a name="a2-forecast-the-amount-of-active-memory"></a>A.2. Прогнозирование объема активной памяти

В вашей системе достаточно активной памяти для обеспечения работы новой таблицы, оптимизированной для обработки в памяти?

#### <a name="microsoft-sql-server"></a>Microsoft SQL Server

Оптимизированная для обработки в памяти таблица, которая содержит 200 ГБ данных, требует выделения на ее поддержку более 200 ГБ активной памяти. Прежде чем создавать оптимизированную для обработки в памяти таблицу с большим объемом данных, необходимо спрогнозировать объем дополнительной активной памяти, которую, возможно, потребуется добавить на серверный компьютер. Руководство по оценке см. в следующих статьях:

- [Оценка требований к объему памяти для таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md)

#### <a name="azure-sql-database"></a>База данных SQL Azure

Для базы данных, размещенной в облачной службе базы данных SQL Azure, выбранный уровень службы повлияет на объем активной памяти, которую разрешено потреблять вашей базе данных. Необходимо спланировать мониторинг использования памяти вашей базой данных при помощи предупреждений. Подробная информация доступна в следующих статьях:

- Проверьте ограничения хранилища In-Memory OLTP для вашей [ценовой категории](/azure/sql-database/sql-database-purchase-models).
- [Мониторинг хранилища OLTP в памяти](/azure/azure-sql/in-memory-oltp-monitor-space)

#### <a name="memory-optimized-table-variables"></a>Оптимизированные для памяти табличные переменные

Иногда использовать табличную переменную, которая объявляется как оптимизированная для обработки в памяти, предпочтительнее, чем традиционную переменную #TempTable, расположенную в базе данных **tempdb** . Такие табличные переменные позволяют существенно повысить производительность, не расходуя большие объемы активной памяти.

### <a name="a3-table-must-be-offline-to-convert-to-memory-optimized"></a>A.3. Таблицу можно преобразовать в оптимизированную для обработки в памяти, только если она не используется

Некоторые функциональные возможности инструкции ALTER TABLE доступны для таблиц, оптимизированных для обработки в памяти. Однако инструкцию ALTER TABLE не получится использовать, чтобы преобразовать дисковую таблицу в таблицу, оптимизированную для обработки в памяти. Вместо этого необходимо выполнить несколько неавтоматизированных действий. Ниже описано несколько способов преобразования дисковой таблицы в оптимизированную для обработки в памяти.

#### <a name="manual-scripting"></a>Написание скриптов вручную

Один из способов преобразования дисковой таблицы в таблицу, оптимизированную для обработки в памяти, заключается в самостоятельном создании кода для необходимых действий Transact-SQL.


1. Приостановите работу приложения.

2. Создайте полную резервную копию.

3. Переименуйте дисковую таблицу.

4. Выполните инструкцию CREATE TABLE для создания новой оптимизированной для обработки в памяти таблицы.

5. Вставьте (INSERT INTO) в свою оптимизированную для обработки в памяти таблицу данные из дисковой таблицы (с использованием вложенного SELECT).

6. Удалите (DROP) дисковую таблицу.

7. Создайте еще одну полную резервную копию.

8. Возобновите работу приложения.


#### <a name="memory-optimization-advisor"></a>Помощник по оптимизации памяти

Помощник по оптимизации памяти позволяет создавать скрипт преобразования дисковой таблицы в оптимизированную для обработки в памяти таблицу. Он устанавливается в составе SQL Server Data Tools (SSDT).

- [Помощник по оптимизации памяти](../../relational-databases/in-memory-oltp/memory-optimization-advisor.md)
- [Скачать SQL Server Data Tools (SSDT)](../../ssdt/download-sql-server-data-tools-ssdt.md)


#### <a name="dacpac-file"></a>DACPAC-файл

Воспользовавшись DACPAC-файлом, которым управляют SSDT, можно обновить базу данных "на месте". В SSDT можно задать изменения схемы, которые кодируются в DACPAC-файл.

Работа с DACPAC-файлами выполняется в контексте проекта Visual Studio типа *База данных*.

- [Приложения уровня данных](../../relational-databases/data-tier-applications/data-tier-applications.md) и DACPAC-файлы



### <a name="a4-guidance-for-whether-in-memory-oltp-features-are-right-for-your-application"></a>A.4. Руководство по определению того, подходит ли выполняющаяся в памяти OLTP вашему приложению

Руководство по определению того, могут ли возможности технологии обработки в памяти OLTP повысить производительность конкретного приложения, см. в следующей статье:

- [In-Memory OLTP (оптимизация в памяти)](../../relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization.md)



## <a name="b-unsupported-features"></a>Б. Неподдерживаемые функции

Возможности, которые не поддерживаются в определенных сценариях использования технологии обработки в памяти OLTP, описаны в следующей статье:

- [Неподдерживаемые функции SQL Server для выполняющейся в памяти OLTP](../../relational-databases/in-memory-oltp/unsupported-sql-server-features-for-in-memory-oltp.md)


В следующих подразделах рассматривается ряд весьма важных неподдерживаемых возможностей.


### <a name="b1-snapshot-of-a-database"></a>Б.1. Снимок (SNAPSHOT) базы данных

После создания первой оптимизированной для обработки в памяти таблицы или модуля в конкретной базе данных сделать [снимок](../../relational-databases/databases/database-snapshots-sql-server.md) этой базы данных становится невозможно. Причина в следующем:

- первый элемент, оптимизированный для обработки в памяти, делает невозможным удаление последнего файла из оптимизированной для обработки в памяти файловой группы (FILEGROUP); и
- ни одна база данных с файлом в оптимизированной для обработки в памяти файловой группе не поддерживает снимки.

Как правило, SNAPSHOT удобно использовать в быстрых итерациях тестирования.


### <a name="b2-cross-database-queries"></a>Б.2. Межбазовые запросы

Оптимизированные для обработки в памяти таблицы не поддерживают [межбазовые](../../relational-databases/in-memory-oltp/cross-database-queries.md) транзакции. Нельзя получить доступ к другой базе данных из той же транзакции или того же запроса, которые также получают доступ к оптимизированной для памяти таблицы.

Табличные переменные не является транзакционными. Следовательно, [переменные оптимизированных для обработки в памяти таблиц](../../relational-databases/in-memory-oltp/faster-temp-table-and-table-variable-by-using-memory-optimization.md) можно использовать в межбазовых запросах.


### <a name="b3-readpast-table-hint"></a>Б.3. Табличное указание READPAST

Не существует запроса, способного применить [табличное указание](../../t-sql/queries/hints-transact-sql-table.md) READPAST к какой-либо оптимизированной для обработки в памяти таблице.

Указание READPAST полезно в случаях, в которых несколько сеансов обращаются к одному и тому же небольшому набору строк и вносят в эти строки изменения, например при обработке очереди.


### <a name="b4-rowversion-sequence"></a>Б.4. RowVersion, объект Sequence

- Не существует столбца, который можно пометить как [RowVersion](../../t-sql/data-types/rowversion-transact-sql.md) в оптимизированной для обработки в памяти таблице.


- Объект [SEQUENCE](../../t-sql/statements/create-sequence-transact-sql.md) невозможно использовать в оптимизированной для обработки в памяти таблице с ограничением. Например, нельзя создать ограничение DEFAULT с предложением NEXT VALUE FOR. SEQUENCE можно использовать с операторами INSERT и UPDATE.


## <a name="c-administrative-maintenance"></a>В. Обслуживание в рамках администрирования


В этом разделе описываются различия в администрировании баз данных, в которых используются оптимизированные для обработки в памяти таблицы.


### <a name="c1-identity-seed-reset-increment--1"></a>В.1. Сброс начального значения идентификаторов, приращение >1

Инструкция[DBCC CHECKIDENT](../../t-sql/database-console-commands/dbcc-checkident-transact-sql.md)не может использоваться для повторного заполнения столбца IDENTITY начальными значениями в оптимизированной для обработки в памяти таблице.

Значение приращения столбца IDENTITY ограничено единицей (1) в таблице, оптимизированной для обработки в памяти.


### <a name="c2-dbcc-checkdb-cannot-validate-memory-optimized-tables"></a>В.2. Инструкция DBCC CHECKDB не может проверять оптимизированные для обработки в памяти таблицы

Если целевым объектом инструкции [DBCC CHECKDB](../../t-sql/database-console-commands/dbcc-checkdb-transact-sql.md) является оптимизированная для обработки в памяти таблица, никакие действия не выполняются. Обходное решение:


1. [Резервное копирование журнала транзакций](../../relational-databases/backup-restore/back-up-a-transaction-log-sql-server.md).

2. Выполните резервное копирование файлов в оптимизированной для обработки в памяти файловой группе на NULL-устройство. Процесс резервного копирования вызывает проверку контрольных сумм.

    При обнаружении повреждений перейдите к следующим шагам.

3. Скопируйте данные из оптимизированных для обработки в памяти таблиц в дисковые таблицы на временное хранение.

4. Восстановите файлы оптимизированной для обработки в памяти файловой группы.

5. Вставьте (INSERT INTO) в оптимизированные для обработки в памяти таблицы данные, которые временно сохранены в дисковых таблицах.

6. Удалите (DROP) дисковые таблицы, в которых были временно сохранены данные.



## <a name="d-performance"></a>Г. Производительность

В этом разделе описываются ситуации, в которых определенные обстоятельства могут мешать отличным показателям в сфере производительности оптимизированных для обработки в памяти таблиц проявиться в полной мере.


### <a name="d1-index-considerations"></a>Г.1. Несколько замечаний об индексах

Все индексы в оптимизированной для обработки в памяти таблице создаются и управляются при помощи табличных инструкций, CREATE TABLE и ALTER TABLE. Невозможно работать с оптимизированной для обработки в памяти таблицей через инструкцию CREATE INDEX.

Зачастую целесообразно и удобно использовать при первоначальной реализации оптимизированной для обработки в памяти таблицы традиционный некластеризованный индекс сбалансированного дерева. Впоследствии, проанализировав работу приложения, можно перейти на индекс другого типа.

Два специальных типа индексов требуют дополнительного обсуждения в контексте оптимизированных для памяти таблиц: хэш-индексы и индексы columnstore.

Обзорную информацию об индексах в оптимизированных для обработки в памяти таблицах см. в следующих источниках:

- [Индексы для оптимизированных для памяти таблиц](../../relational-databases/in-memory-oltp/indexes-for-memory-optimized-tables.md)


#### <a name="hash-indexes"></a>Хэш-индексы

Иногда хэш-индексы — это самый быстрый способ получить доступ к конкретной строке, указав точное значение первичного ключа в операторе **=** .

- Неточные операторы, такие как **!=** , **>** или **BETWEEN**, могут снизить производительность при использовании совместно с хэш-индексом.

- Возможно, хэш-индекс не лучший выбор, если скорость дублирования значений ключа становится слишком высокой.

- Опасно недооценивать число *контейнеров* , которое может потребоваться хэш-индексу, это может привести к длинным цепочкам в отдельных контейнерах, чего следует избегать. Подробная информация доступна в следующих статьях:
    - [Хэш-индексы для оптимизированных для памяти таблиц](../../relational-databases/in-memory-oltp/hash-indexes-for-memory-optimized-tables.md)


#### <a name="nonclustered-columnstore-indexes"></a>Некластеризованные индексы columnstore

Оптимизированные для обработки в памяти таблицы обеспечивают высокую скорость обработки типичных транзакционных бизнес-данных, что в парадигме называется *обработкой транзакций в режиме реального времени* (или *OLTP*). Индексы Columnstore обеспечивают высокую скорость обработки агрегирования и других аналогичных операций обработки данных, которые мы называем *аналитикой*. В прошлом для удовлетворения потребностей OLTP и обработки аналитических операций считалось оптимальным наличие отдельных таблиц с активным перемещением данных и определенной степенью дублирования. Сегодня доступно более простое **гибридное решение** : индекс columnstore в оптимизированной для обработки в памяти таблице.


- [Индекс columnstore](../../relational-databases/indexes/columnstore-indexes-overview.md) может быть создан на основе дисковой таблицы и даже в форме кластеризованного индекса. Однако в таблице, оптимизированной для обработки в памяти, индекс columnstore не может быть кластеризован.


- Столбцы LOB или внестрочные столбцы в оптимизированной для обработки в памяти таблице не позволяют создавать в таблице индекс columnstore.


- Инструкции ALTER TABLE не могут выполняться в отношении таблицы, оптимизированной для обработки в памяти, при наличии в последней индекса columnstore.
    - С августа 2016 года корпорация Майкрософт активно работает над повышением эффективности повторного создания индекса columnstore.



### <a name="d2-lob-and-off-row-columns"></a>Г.2. Столбцы LOB и внестрочные столбцы

Большие объекты (LOB) — это столбцы таких типов, как varchar (**max**). Наличие пары столбцов LOB в таблице, оптимизированной для обработки в памяти, наверное, не окажет сколько-нибудь ощутимого отрицательного влияния на производительность. Однако старайтесь не создавать лишние столбцы LOB. То же самое касается внестрочных столбцов. Не присваивайте столбцу тип nvarchar(3072), если достаточно varchar(512).


Чуть более подробные сведения о столбцах LOB и внестрочных столбцах доступны в следующих источниках:

- [Размер строк и таблицы для таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/table-and-row-size-in-memory-optimized-tables.md)
- [Поддерживаемые типы данных для выполняющейся в памяти OLTP](../../relational-databases/in-memory-oltp/supported-data-types-for-in-memory-oltp.md)



## <a name="e-limitations-of-native-procs"></a>Д. Ограничения, связанные со скомпилированными в машинный код процедурами


Определенные элементы Transact-SQL не поддерживаются в скомпилированных в машинный код модулях T-SQL, включая хранимые процедуры. Дополнительные сведения о поддерживаемых компонентах см.:

- [Поддерживаемые функции для модулей, скомпилированных в собственном коде T-SQL](../../relational-databases/in-memory-oltp/supported-features-for-natively-compiled-t-sql-modules.md)

Рекомендации по миграции модулей Transact-SQL, в которых используются неподдерживаемые компоненты, в скомпилированные в собственном коде модули см.:

- [Проблемы миграции, связанные с хранимыми процедурами, скомпилированными в собственном коде](./a-guide-to-query-processing-for-memory-optimized-tables.md)

Помимо ограничений на определенные элементы Transact-SQL, также накладываются некоторые ограничения на операторы запросов, поддерживаемые в скомпилированных в собственном коде модулях T-SQL. Из-за этих ограничений скомпилированные в собственном коде хранимые процедуры не подходят для аналитических запросов, которые обрабатывают большие наборы данных.

#### <a name="no-parallel-processing-in-a-native-proc"></a>В скомпилированных в машинный код процедурах отсутствует параллельная обработка

Параллельная обработка не может быть частью какого бы то ни было плана запросов для скомпилированной в машинный код процедуры. Скомпилированные в машинный код процедуры всегда однопоточны.


#### <a name="join-types"></a>Типы соединений


Ни хэш-соединение, ни соединение слиянием не может быть частью плана запросов для скомпилированной в машинный код процедуры. Используются соединения вложенных циклов.


#### <a name="no-hash-aggregation"></a>Агрегирование хэшей отсутствует

Если план запросов для скомпилированной в машинный код процедуры требует этапа агрегирования, доступно только агрегирование потоков. Хэш-агрегирование не поддерживается в плане запросов для скомпилированных в машинный код процедур.

- Хэш-агрегирование больше подходит для ситуаций, когда необходимо агрегировать данные из большого числа строк.



## <a name="f-application-design-transactions-and-retry-logic"></a>Е. Проектирование приложений: транзакции и логика повторных попыток

Транзакция, связанная с оптимизированной для обработки в памяти таблицей, может стать зависимой от другой транзакции, в которой используется та же таблица. Если число зависимых транзакций превысит допустимый максимум, все зависимые транзакции завершатся сбоем.

В SQL Server 2016:

- допустимый предел — 8 зависимых транзакций. 8 — это также предельное число транзакций, от которых может зависеть любая транзакция.
- Номер ошибки — 41839. (В SQL Server 2014 номер ошибки — 41301.)


Скрипты Transact-SQL можно сделать более устойчивыми к ошибкам, связанным с транзакциями, добавив в скрипты *логику повторных попыток* . Логика повторных попыток окажется полезной, если вызовы UPDATE и DELETE выполняются часто или если на оптимизированную для обработки в памяти таблицу ссылается внешний ключ другой таблицы. Подробная информация доступна в следующих статьях:

- [Transactions with Memory-Optimized Tables](../../relational-databases/in-memory-oltp/transactions-with-memory-optimized-tables.md)
- [Transaction dependency limits with memory optimized tables — Error 41839](/archive/blogs/sqlcat/transaction-dependency-limits-with-memory-optimized-tables-error-41839) (Ограничения, связанные с зависимостями транзакций в оптимизированных для обработки в памяти таблицах, — ошибка 41839)



## <a name="related-links"></a>Связанные ссылки

- [In-Memory OLTP (оптимизация в памяти)](../../relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization.md)