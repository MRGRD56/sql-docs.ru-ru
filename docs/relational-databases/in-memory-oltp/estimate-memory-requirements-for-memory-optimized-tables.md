---
title: Требования к памяти — оптимизированные для памяти таблицы
description: Узнайте об использовании памяти и сценариях управления для таблиц, оптимизированных для памяти, в SQL Server, которым требуется достаточный объем памяти для всех строк и индексов.
ms.custom: seo-dt-2019
ms.date: 12/02/2016
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 5c5cc1fc-1fdf-4562-9443-272ad9ab5ba8
author: markingmyname
ms.author: maghan
monikerRange: =azuresqldb-current||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: c40cb726e20f015a46cd808200ebbe67d9c1dc10
ms.sourcegitcommit: f29f74e04ba9c4d72b9bcc292490f3c076227f7c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/13/2021
ms.locfileid: "98168464"
---
# <a name="estimate-memory-requirements-for-memory-optimized-tables"></a>Оценка требований к объему памяти для таблиц, оптимизированных для памяти
[!INCLUDE [SQL Server Azure SQL Database](../../includes/applies-to-version/sql-asdb.md)]

Оптимизированные для памяти таблицы требуют наличия достаточного объема памяти для хранения всех строк и индексов в памяти. Поскольку память является ограниченным ресурсом, важно понимать принципы управления загруженностью памяти в системе. Темы в этом разделе описывают распространенные сценарии использования и управления памятью.

При создании новой, оптимизированной для памяти таблицы или переносе существующей на диске таблицы в таблицу [!INCLUDE[hek_2](../../includes/hek-2-md.md)], оптимизированную для памяти, важно иметь оценку требований к памяти для каждой таблицы, чтобы подготовить сервер с достаточным объемом памяти. В этом разделе описывается, как определить объем памяти, необходимый для хранения данных в таблице, оптимизированной для памяти.  
  
Если вы рассматриваете переход от дисковых таблиц к таблицам, оптимизированным для памяти, то перед продолжением чтения посмотрите в разделе [Определение, должна ли таблица или хранимая процедура быть перенесена в In-Memory OLTP](../../relational-databases/in-memory-oltp/determining-if-a-table-or-stored-procedure-should-be-ported-to-in-memory-oltp.md) сведения о том, какие таблицы лучше всего подходят для миграции. Все разделы статьи [Миграция в In-Memory OLTP](./plan-your-adoption-of-in-memory-oltp-features-in-sql-server.md) содержат руководство по миграции дисковых таблиц в оптимизированные для памяти. 
  
## <a name="basic-guidance-for-estimating-memory-requirements"></a>Основные инструкции по оценке требований к памяти

Начиная с [!INCLUDE[ssSQL15](../../includes/sssql16-md.md)], не существует ограничений на размер таблиц, оптимизированных для памяти, хотя таблицы должны умещаться в памяти.  В [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] размер поддерживаемой данных — 256 ГБ для таблиц SCHEMA_AND_DATA.

Размер оптимизированной для памяти таблицы соответствует размеру данных плюс определенный объем для размещения заголовков строк. При переносе дисковой таблицы в таблицу, оптимизированную для памяти, размер оптимизированной для памяти таблицы будет примерно соответствовать размеру кластеризованного индекса или кучи исходной дисковой таблицы.

Индексы в таблицах, оптимизированных для памяти, как правило, меньше, чем некластеризованные индексы в дисковых таблицах. Размер некластеризованных индексов равен порядка `[primary key size] * [row count]`. Размер хэш-индексов — `[bucket count] * 8 bytes`. 

Если имеется активная рабочая нагрузка, дополнительная память требуется для управления версиями строк и различных операций. Объем необходимой памяти на практике зависит от рабочей нагрузки, однако для надежности рекомендуется начинать с объема памяти, в два раза превышающего ожидаемый размер оптимизированных для памяти таблиц и индексов и наблюдать, каковы потребности в памяти на самом деле. Объем дополнительных затрат ресурсов на управление версиями строк всегда зависит от характеристик рабочей нагрузки. Так, длительные транзакции увеличивают нагрузку на память особенно сильно. Для большинства рабочих нагрузок, использующих более крупные базы данных (например, более 100 ГБ), расход ресурсов ограничен (25 % и менее).

  
## <a name="detailed-computation-of-memory-requirements"></a>Вычисление точных требований к памяти 
  
- [Пример оптимизированной для памяти таблицы](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_ExampleTable)  
  
- [Память для таблицы](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_MemoryForTable)  
  
- [Память для индексов](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_IndexMeemory)  
  
- [Память для управления версиями строк](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_MemoryForRowVersions)  
  
- [Память для табличных переменных](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_TableVariables)  
  
- [Память под будущее увеличение](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_MemoryForGrowth)  
  
###  <a name="example-memory-optimized-table"></a><a name="bkmk_ExampleTable"></a> Пример оптимизированной для памяти таблицы  

Рассмотрим следующую схему таблицы, оптимизированной для памяти:
  
```sql  
CREATE TABLE t_hk
(  
  col1 int NOT NULL  PRIMARY KEY NONCLUSTERED,  

  col2 int NOT NULL  INDEX t1c2_index   
      HASH WITH (bucket_count = 5000000),  

  col3 int NOT NULL  INDEX t1c3_index   
      HASH WITH (bucket_count = 5000000),  

  col4 int NOT NULL  INDEX t1c4_index   
      HASH WITH (bucket_count = 5000000),  

  col5 int NOT NULL  INDEX t1c5_index NONCLUSTERED,  

  col6 char (50) NOT NULL,  
  col7 char (50) NOT NULL,   
  col8 char (30) NOT NULL,   
  col9 char (50) NOT NULL  

)   WITH (memory_optimized = on)  ;
GO  
```  

С помощью этой схемы мы определим минимальный объем памяти, необходимый для оптимизированной для памяти таблицы.  
  
###  <a name="memory-for-the-table"></a><a name="bkmk_MemoryForTable"></a> Память для таблицы  

Строка оптимизированной для памяти таблицы состоит из 3 частей:
  
- **Метки времени**   
    Заголовок строки или метки времени = 24 байта.  
  
- **Указатели индекса**   
    Для каждого хэш-индекса в таблице каждая строка содержит 8-байтный адресный указатель на следующую строку в индексе.  Поскольку имеются 4 индекса, каждая строка выделит 32 байта для указателей индекса (указатель для каждого индекса занимает 8 байт).  
  
- **Данные**   
    Размер данных в строке определяется путем суммирования размера типа данных для каждого столбца данных.  В нашей таблице имеется пять 4-байтных целых чисел, три 50-байтных символьных столбцов и один 30-байтный символьный столбец.  Поэтому часть данных в каждой строке — это 4 + 4 + 4 + 4 + 4 + 50 + 50 + 30 + 50 или 200 байт.  
  
Далее приведено вычисление размера для 5 миллионов строк в таблице, оптимизированной для памяти. Общий объем памяти, используемой строками данных, вычисляется следующим образом:  
  
#### <a name="memory-for-the-tables-rows"></a>Память для строк таблицы  
  
Из вышеуказанных вычислений, размер каждой строки в таблице, оптимизированной для памяти, будет 24 + 32 + 200 или 256 байт.  Поскольку мы имеем 5 миллионов строк, таблица использует 5 000 000 * 256 байт или 1 280 000 000 байт — примерно 1,28 ГБ.  
  
###  <a name="memory-for-indexes"></a><a name="bkmk_IndexMeemory"></a> Память для индексов  

#### <a name="memory-for-each-hash-index"></a>Объем памяти для каждого хэш-индекса  
  
Каждый хэш-индекс — это хэш-массив, состоящий из 8-байтных указателей адреса.  Размер массива лучше всего определяется количеством уникальных значений индекса в нем, то есть количество уникальных значений Col2 будет хорошей отправной точкой для подсчета размера массива t1c2_index. Слишком большой хэш-массив занимает много памяти.  Слишком маленький хэш-массив снижает производительность, поскольку будет слишком много конфликтов индексных значений, которые хэшируются в один и тот же индекс.  
  
В хэш-индексах скорость поиска совпадений очень высока:  
  
```sql  
SELECT * FROM t_hk  
   WHERE Col2 = 3;
```  
  
Некластеризованные индексы будут быстрее при поиске диапазона, например:  
  
```sql  
SELECT * FROM t_hk  
   WHERE Col2 >= 3;
```  
  
При переносе дисковой таблицы можно использовать следующий критерий для определения количества уникальных значений в индексе t1c2_index.  
  
```sql
SELECT COUNT(DISTINCT [Col2])  
  FROM t_hk;
```  
  
При создании новой таблицы необходимо оценить размер массива или собрать данные путем теста еще до развертывания.  
  
Сведения о принципах работы хэш-индексов в оптимизированных для памяти таблицах [!INCLUDE[hek_2](../../includes/hek-2-md.md)] см. в разделе [Хэш-индексы](/previous-versions/sql/sql-server-2016/dn133190(v=sql.130)).  
  
#### <a name="setting-the-hash-index-array-size"></a>Задание размера массива хэш-индекса  
  
Размер хэш-массива задается `(bucket_count= value)` , где `value` — это целочисленное значение больше нуля. Если `value` не является степенью 2, то фактическое значение bucket_count округляется вверх до следующего значения, являющегося степенью 2.  В нашем примере таблицы bucket_count = 5 000 000. Так как 5 000 000 не является степенью 2, фактическое число контейнеров округляется в сторону увеличения до 8 388 608 (2^23).  Необходимо использовать это число, а не 5 000 000, при вычислении объема памяти, необходимого для хэш-массива.  
  
Таким образом, в нашем примере для хэш-массива потребуется памяти:  
  
8 388 608 * 8 = 2^23 \* 8 = 2^23 \* 2^3 = 2^26 = 67 108 864 или ок. 64 МБ.  
  
Поскольку мы имеем 3 хэш-индекса, память, требуемая для хэш-индексов, — 64 МБ * 3 = 192 МБ.  
  
#### <a name="memory-for-nonclustered-indexes"></a>Память для некластеризованных индексов  
  
Некластеризованные индексы реализуются в виде B-деревьев, внутренние узлы которых содержат значения индекса и указатели на последующие узлы.  Листовые узлы содержат значение индекса и указатель на строку таблицы в памяти.  
  
В отличие от хэш-индексов некластеризованные индексы не имеют фиксированного размера контейнера. Индекс динамически увеличивается и уменьшается вместе с данными.  
  
Объем памяти, требуемый для некластеризованных индексов, можно вычислить следующим образом.  
  
- **Память, выделенная для неконечных узлов**   
    В стандартной конфигурации объем памяти, выделенный для неконечных узлов, составляет небольшой процент от общей памяти, занятой индексом. Это слишком мало, поэтому этот объем можно спокойно опустить.  
  
- **Память для конечных узлов**   
    Конечные узлы содержат по одной строке для каждого уникального ключа в таблице, и она указывает на строки данных с этим уникальным ключом.  При наличии нескольких строк с одинаковым ключом (т. е. имеется неуникальный некластеризованный индекс) будет только одна строка в конечном узле индекса, указывающая на одну из строк, а другие строки будут связаны между собой.  Таким образом, общую память можно примерно вычислить следующим образом:
  - memoryForNonClusteredIndex = (pointerSize + sum(keyColumnDataTypeSizes)) * rowsWithUniqueKeys  
  
 Некластеризованные индексы лучше всего подходят для поиска по диапазону, как показано в следующем примере запроса:  
  
```sql  
SELECT * FROM t_hk  
   WHERE c2 > 5;  
```  
  
###  <a name="memory-for-row-versioning"></a><a name="bkmk_MemoryForRowVersions"></a> Память для управления версиями строк

Чтобы избежать блокировок, модуль In-Memory OLTP использует оптимистический параллелизм при обновлении или удалении строк. Это означает, что при обновлении строки создается ее дополнительная версия. Кроме того, операции удаления являются логическими — существующая строка помечается как удаленная, но не удаляется немедленно. Система хранит старые версии строк (включая удаленные строки), пока все транзакции, которые теоретически могут использовать одну из версий, не завершатся. 
  
Поскольку в любой момент в памяти может находиться некоторое количество дополнительных строк, ожидающих цикла сборки мусора для освобождения памяти, необходимо иметь достаточный объем памяти, чтобы учесть эти дополнительные строки.  
  
Число дополнительных строк может быть получено путем подсчета пикового количества обновлений и удалений строк в секунду, которое затем умножается на число секунд, которое занимает самая длинная транзакция (минимум 1 секунда).  
  
Затем это значение умножается на размер строки, что дает число байтов, необходимых для управления версиями строк.  
  
`rowVersions = durationOfLongestTransctoinInSeconds * peakNumberOfRowUpdatesOrDeletesPerSecond`  
  
Затем вычисляется нужный объем памяти для старых строк путем умножения количества старых строк на размер строки в таблице, оптимизированной для памяти (см. раздел [Память для таблицы](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md#bkmk_MemoryForTable) выше).  
  
`memoryForRowVersions = rowVersions * rowSize`  
  
###  <a name="memory-for-table-variables"></a><a name="bkmk_TableVariables"></a> Память для табличных переменных
  
Память, отведенная для табличных переменных, освобождается только в тех случаях, когда табличная переменная покидает область действия. Удаленные строки, включая строки, удаленные как часть обновления, из табличной переменной, не подвергаются сборке мусора. Ресурсы памяти не освобождаются до того момента, пока существует область табличных переменных.  
  
Табличные переменные, определенные в большом пакете SQL, в отличие от области действия процедур, используемых в нескольких транзакциях, могут потреблять большой объем памяти. Так как для них не применяется сборка мусора, удаленные строки в табличной переменной могут занимать большой объем памяти и, следовательно, могут снизить производительность, т. к. операции считывания должны сканировать эти удаленные строки.  
  
###  <a name="memory-for-growth"></a><a name="bkmk_MemoryForGrowth"></a> Память под будущее увеличение

Указанные выше вычисления дают оценку потребного объема памяти для таблицы в том виде, в котором она существует в данный момент. В дополнение к этому объему памяти необходимо оценить увеличение размера таблицы и предоставить достаточно памяти для ее будущего роста.  Например, если предполагается рост размера в 10 %, то следует умножить полученные ранее результаты на 1,1. Это и даст общую оценку объема памяти для таблицы.  
  
## <a name="see-also"></a>См. также:

[Миграция в In-Memory OLTP](./plan-your-adoption-of-in-memory-oltp-features-in-sql-server.md)