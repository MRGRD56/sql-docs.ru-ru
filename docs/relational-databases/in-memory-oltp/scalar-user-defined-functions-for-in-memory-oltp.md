---
title: Скалярные пользовательские функции для выполняющейся в памяти OLTP | Документация Майкрософт
description: Узнайте, как создавать и удалять скомпилированные в собственном виде скалярные определяемые пользователем функции для выполняющейся в памяти OLTP в SQL Server. Компиляция в собственном режиме повышает производительность.
ms.custom: ''
ms.date: 03/20/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: d2546e40-fdfc-414b-8196-76ed1f124bf5
author: MightyPen
ms.author: genemi
monikerRange: =azuresqldb-current||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 9fd391acc854c4ae337789149955c331ac9543eb
ms.sourcegitcommit: f29f74e04ba9c4d72b9bcc292490f3c076227f7c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/13/2021
ms.locfileid: "98172036"
---
# <a name="scalar-user-defined-functions-for-in-memory-oltp"></a>Скалярные определяемые пользователем функции для выполняющейся в памяти OLTP
[!INCLUDE [SQL Server Azure SQL Database](../../includes/applies-to-version/sql-asdb.md)]

  В [!INCLUDE[ssSQL15](../../includes/sssql16-md.md)]можно создавать и удалять скомпилированные в собственном коде определяемые пользователем скалярные функции. Их также можно изменять. Компиляция в собственном коде повышает производительность вычисления определяемых пользователем функций в Transact-SQL.  
  
 Если изменить скомпилированную в собственном коде скалярную определяемую пользователем функцию, приложение остается доступным при выполнении операции и компилируется новая версия функции.  
  
 Сведения о поддерживаемых конструкциях T-SQL см. в статье [Поддерживаемые функции для модулей, скомпилированных в собственном коде T-SQL](../../relational-databases/in-memory-oltp/supported-features-for-natively-compiled-t-sql-modules.md).  
  
## <a name="creating-dropping-and-altering-user-defined-functions"></a>Создание, удаление и изменение определяемых пользователем функций  
 Для создания, удаления и изменения определяемых пользователем скомпилированных в собственном коде скалярных функций используются инструкции CREATE FUNCTION, DROP FUNCTION и ALTER FUNCTION соответственно. Инструкция BEGIN ATOMIC WITH требуется для определяемых пользователем функций.  
  
 Сведения о поддерживаемом синтаксисе и ограничениях см. в следующих статьях.  
  
-   [CREATE FUNCTION (Transact-SQL)](../../t-sql/statements/create-function-transact-sql.md)  
  
-   [ALTER FUNCTION (Transact-SQL)](../../t-sql/statements/alter-function-transact-sql.md)  
  
-   [DROP FUNCTION (Transact-SQL)](../../t-sql/statements/drop-function-transact-sql.md)  
  
     Синтаксис инструкции DROP FUNCTION для скомпилированных в собственном коде скалярных определяемых пользователем функций аналогичен синтаксису для интерпретируемых определяемых пользователем функций.  
  
-   [EXECUTE (Transact-SQL)](../../t-sql/language-elements/execute-transact-sql.md)  
  
 Хранимую процедуру [sp_recompile (Transact-SQL)](../../relational-databases/system-stored-procedures/sp-recompile-transact-sql.md) можно использовать со скомпилированными в собственном коде определяемыми пользователем скалярными функциями. При этом произойдет повторная компиляция функции с использованием определения в метаданных.  
  
 Ниже приведен пример скалярной определяемой пользователем функции из примера базы данных [AdventureWorks2016CTP3](https://github.com/microsoft/sql-server-samples/releases/tag/adventureworks) .  
  
```sql  
CREATE FUNCTION [dbo].[ufnLeadingZeros_native](@Value int)   
RETURNS varchar(8)   
WITH NATIVE_COMPILATION, SCHEMABINDING  
AS   
BEGIN ATOMIC WITH (TRANSACTION ISOLATION LEVEL = SNAPSHOT, LANGUAGE = N'English')  
  
    DECLARE @ReturnValue varchar(8);  
    SET @ReturnValue = CONVERT(varchar(8), @Value);  
       DECLARE @i int = 0, @count int = 8 - LEN(@ReturnValue)  
  
    WHILE @i < @count  
       BEGIN  
            SET @ReturnValue = '0' + @ReturnValue;  
            SET @i += 1  
       END  
  
    RETURN (@ReturnValue);  
  
END  
```  
  
## <a name="calling-user-defined-functions"></a>Вызов пользовательских функций  
 Скомпилированные в собственном коде скалярные определяемые пользователем функции можно использовать в выражениях там же, где и встроенные скалярные функции, и интерпретируемые скалярные определяемые пользователем функции. Скомпилированные в собственном коде скалярные определяемые пользователем функции можно также использовать с инструкцией EXECUTE, в инструкции Transact-SQL и в скомпилированной в собственном коде хранимой процедуре.  
  
 Эти скалярные определяемые пользователем функции можно использовать в скомпилированных в собственном коде хранимых процедурах и скомпилированных в собственном коде определяемых пользователем функциях, а также везде, где можно использовать встроенные функции. Кроме того, скомпилированные в собственном коде скалярные определяемые пользователем функции можно использовать в традиционных модулях Transact-SQL.  
  
 Эти функции можно использовать в режиме взаимодействия при условии поддержки интерпретируемых скалярных определяемых пользователем функций. В этом случае есть ограничения для транзакций между контейнерами, как описано в разделе **Поддерживаемые уровни изоляции для транзакций между контейнерами** статьи [Операции с таблицами, оптимизированными для памяти](../../relational-databases/in-memory-oltp/transactions-with-memory-optimized-tables.md). Дополнительные сведения о режиме взаимодействия см. в статье [Доступ к таблицам, оптимизированным для памяти, с помощью интерпретируемых инструкций Transact-SQL](../../relational-databases/in-memory-oltp/accessing-memory-optimized-tables-using-interpreted-transact-sql.md).  
  
 Скомпилированным в собственном коде скалярным определяемым пользователем функциям требуется явно выраженный контекст выполнения. Дополнительные сведения см. в разделе [Предложение EXECUTE AS (Transact-SQL)](../../t-sql/statements/execute-as-clause-transact-sql.md). Инструкция EXECUTE AS CALLER не поддерживается. Дополнительные сведения см. в разделе [EXECUTE (Transact-SQL)](../../t-sql/language-elements/execute-transact-sql.md).  
  
 Сведения о поддерживаемом синтаксисе инструкций EXECUTE Transact-SQL для скомпилированных в собственном коде определяемых пользователем скалярных функций см. в статье [EXECUTE (Transact-SQL)](../../t-sql/language-elements/execute-transact-sql.md). Сведения о поддерживаемом синтаксисе для выполнения определяемых пользователем функций в скомпилированной в собственном коде хранимой процедуре см. в статье [Поддерживаемые функции для модулей, скомпилированных в собственном коде T-SQL](../../relational-databases/in-memory-oltp/supported-features-for-natively-compiled-t-sql-modules.md).  
  
## <a name="hints-and-parameters"></a>Указания и параметры  
 Поддержка указаний таблиц, соединений и запросов в скомпилированных в собственном коде скалярных определяемых пользователем функциях осуществляется так же, как и в скомпилированных хранимых процедурах. Как и в случае с интерпретируемыми скалярными определяемыми пользователем функциями, указания запросов в Transact-SQL, которые ссылаются на скомпилированные в собственном коде скалярные определяемые пользователем функции, не влияют на план запроса для этой определяемой пользователем функции.  
  
 Скомпилированные в собственном коде скалярные определяемые пользователем функции поддерживают те же параметры, что и скомпилированные в собственном коде хранимые процедуры, при условии, что эти параметры можно использовать в скалярных определяемых пользователем функциях. Пример поддерживаемого параметра — параметр с табличным значением.  
  
## <a name="schema-bound"></a>Привязка к схеме  
 Следующие сведения касаются скомпилированных в собственном коде скалярных определяемых пользователем функций.  
  
-   Функции нужно привязать к схеме, использовав аргумент WITH SCHEMABINDING в инструкции CREATE FUNCTION и ALTER FUNCTION.  
  
-   Функцию нельзя удалить или изменить, если на нее ссылается хранимая процедура с привязкой к схеме или определяемая пользователем функция.  
  
## <a name="showplan_xml"></a>SHOWPLAN_XML  
 Скомпилированные в собственном коде скалярные определяемые пользователем функции поддерживают инструкцию SHOWPLAN_XML. Она соответствует общей схеме SHOWPLAN_XML, как и в случае со скомпилированными в собственном коде хранимыми процедурами. Базовый элемент определяемых пользователем функций — это `<UDF>`.  
  
 Скомпилированные в собственном коде скалярные определяемые пользователем функции не поддерживают STATISTICS XML. При выполнении запроса со ссылкой на определяемую пользователем функцию с заданной инструкцией STATISTICS XML содержимое XML возвращается без части, отвечающей за определяемую пользователем функцию.  
  
## <a name="permissions"></a>Разрешения  
 Как и в случае со скомпилированными в собственном коде хранимыми процедурами, разрешения для объектов, указанных в скомпилированной в собственном коде скалярной определяемой пользователем функции, проверяются при создании функции. CREATE FUNCTION завершается сбоем, если у воплощаемого пользователя нет необходимых разрешений. Если во время изменения разрешений воплощаемый пользователь теряет соответствующие разрешения, последующее выполнение определяемой пользователем функции также завершается сбоем.  
  
 При использовании скомпилированной в собственном коде скалярной определяемой пользователем функции в скомпилированной в собственном коде хранимой процедуре разрешения на выполнение определяемой пользователем функции проверяются при создании внешней процедуры. Если у пользователя, олицетворенного внешней процедурой, нет разрешений EXEC для определяемой пользователем функции, происходит сбой создания хранимой процедуры. Если во время изменения разрешений пользователь теряет разрешения EXEC, происходит сбой выполнения внешней процедуры.  
  
## <a name="see-also"></a>См. также:  
 [Встроенные функции (Transact-SQL)](~/t-sql/functions/functions.md)   
 [Сохранение плана выполнения в формате XML](../../relational-databases/performance/save-an-execution-plan-in-xml-format.md)  
  
  
