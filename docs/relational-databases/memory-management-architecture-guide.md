---
title: Руководство по архитектуре управления памятью | Документация Майкрософт
description: Узнайте об архитектуре управления памятью в SQL Server, включая изменения в управлении памятью, появившиеся в предыдущих версиях.
ms.custom: ''
ms.date: 01/09/2019
ms.prod: sql
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.reviewer: ''
ms.technology: supportability
ms.topic: conceptual
helpviewer_keywords:
- guide, memory management architecture
- memory management architecture guide
- PMO
- Partitioned Memory Objects
- cmemthread
- AWE
- SPA, Single Page Allocator
- MPA, Multi Page Allocator
- memory allocation, SQL Server
- memory pressure, SQL Server
- stack size, SQL Server
- buffer manager, SQL Server
- buffer pool, SQL Server
- resource monitor, SQL Server
ms.assetid: 7b0d0988-a3d8-4c25-a276-c1bdba80d6d5
author: rothja
ms.author: jroth
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: a8165d82fa5db393b3f2f66737910ba4de9d11a8
ms.sourcegitcommit: 1a544cf4dd2720b124c3697d1e62ae7741db757c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2020
ms.locfileid: "97473885"
---
# <a name="memory-management-architecture-guide"></a>руководство по архитектуре управления памятью

[!INCLUDE[SQL Server Azure SQL Database Synapse Analytics PDW ](../includes/applies-to-version/sql-asdb-asdbmi-asa-pdw.md)]

## <a name="windows-virtual-memory-manager"></a>Диспетчер виртуальной памяти Windows  
Определенные области адресного пространства сопоставляются с физической памятью диспетчером виртуальной памяти Windows (VMM).  
  
Дополнительные сведения об объеме физической памяти, поддерживаемой различными операционными системами, см. в разделе [Предельный объем памяти для выпусков Windows](/windows/desktop/Memory/memory-limits-for-windows-releases) в документации Windows.  
  
Система виртуальной памяти позволяет превышать объем физической памяти, при этом соотношение виртуальной памяти к физической может быть больше 1:1. В результате чего на компьютерах с разными конфигурациями физической памяти могут работать большие программы. Тем не менее, если объем используемой виртуальной памяти значительно превышает общий объем рабочих множеств всех процессов, производительность может ухудшиться. 

## <a name="sql-server-memory-architecture"></a>Архитектура памяти SQL Server

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] по мере необходимости динамически получает и освобождает оперативную память. Обычно администратору не требуется указывать, сколько памяти необходимо выделить для [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], хотя эта возможность по-прежнему существует и в некоторых случаях необходима.

Одна из главных задач проектирования любой программной системы для баз данных — минимизация операций дискового ввода-вывода, так как чтение и запись на диск являются наиболее ресурсоемкими операциями. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] создает в памяти буферный пул для сохранения страниц, считываемых из базы данных. Большой объем кода [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] предназначен для минимизации числа физических операций чтения-записи между диском и буферным пулом. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет балансировку для решения двух задач:

* предотвращения роста буферного пула до размера, при котором вся система будет испытывать нехватку оперативной памяти;
* минимизации числа физических операций ввода-вывода в базе данных путем увеличения размера буферного пула.

> [!NOTE]
> В сильно загруженной системе некоторые масштабные запросы, для выполнения которых требуется большой объем оперативной памяти, не могут получить минимально необходимого им объема и в результате завершаются ошибкой, когда истекает время ожидания ресурса памяти. Для решения этой проблемы следует увеличить значение параметра [query wait](../database-engine/configure-windows/configure-the-query-wait-server-configuration-option.md). При параллельных запросах можно попробовать уменьшить значение параметра [max degree of parallelism](../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md).
 
> [!NOTE]
> В сильно загруженной системе с ограниченными ресурсами памяти запросы, содержащие соединение слиянием, сортировку и построение битовой карты в плане запроса, могут удалить битовую карту, если запрос не получил минимально необходимого для ее сохранения объема оперативной памяти. Это может повлиять на производительность запроса, и, если процесс сортировки не помещается в памяти, приводит к повышению интенсивности использования рабочих таблиц в базе данных tempdb, вызывая тем самым ее рост. Для решения этой проблемы необходимо увеличить объем физической памяти или настроить запросы так, чтобы они использовали другие, более быстрые планы запроса.
 
### <a name="providing-the-maximum-amount-of-memory-to-ssnoversion"></a>Выделение максимального объема памяти для [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]

Используя AWE и право на закрепление страниц в памяти, вы можете выделять следующие объемы памяти в ядре СУБД [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . 

> [!NOTE]
> Следующая таблица содержит столбец для 32-разрядных версий, которые более не доступны.

|Политика памяти|32-разрядная версия <sup>1</sup> |64-разрядная|
|-------|-------|-------| 
|Обычная память |Все выпуски [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . до достижения предела обработки виртуального адресного пространства — <br>— 2 ГБ<br>— 3 ГБ с параметром загрузки /3gb <sup>2</sup> <br>— 4 ГБ на WOW64 <sup>3</sup> |Все выпуски [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . до достижения предела обработки виртуального адресного пространства — <br>— 7 ТБ с архитектурой IA64 (IA64 не поддерживается в версии [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] и более поздней)<br>— Максимум, поддерживаемый операционной системой при использовании архитектуры x64 <sup>4</sup>
|Механизм AWE (позволяет [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выходить за пределы обработки виртуального адресного пространства на 32-разрядной платформе). |Выпуски [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Standard, Enterprise и Developer: буферный пул, достаточный для доступа к 64 ГБ памяти.|Неприменимо <sup>5</sup> |
|Привилегия операционной системы на блокировку страниц в памяти (позволяет блокировать физическую память, препятствует вытеснению блокированной памяти). <sup>6</sup> |Выпуски [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Standard, Enterprise и Developer: требуется для процесса [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] для использования механизма AWE. Память, распределенная с использованием механизма AWE, не может быть выгружена. <br> Предоставление данного разрешения без включения AWE не оказывает влияния на сервер. | Используется, только если это необходимо, то есть при наличии признаков того, что процесс sqlservr вытесняется из памяти. В этом случае в журнале ошибок появится ошибка 17890, как в следующем примере: `A significant part of sql server process memory has been paged out. This may result in a performance degradation. Duration: #### seconds. Working set (KB): ####, committed (KB): ####, memory utilization: ##%.`|

<sup>1</sup> 32-разрядные версии недоступны, начиная с [!INCLUDE[ssSQL14](../includes/sssql14-md.md)].  
<sup>2</sup> /3gb — это параметр загрузки операционной системы.  
<sup>3</sup> WOW64 (Windows on Windows 64) — режим, в котором 32-разрядная версия [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] запускается в 64-разрядной операционной системе.  
<sup>4</sup> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Standard Edition поддерживает до 128 ГБ. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Enterprise Edition поддерживает максимум, заданный для операционной системы.  
<sup>5</sup> Обратите внимание, что параметр awe enabled функции sp_configure в 64-разрядной системе [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]присутствует, но не учитывается.    
<sup>6</sup> При выдаче разрешения на закрепление страниц в памяти (либо в 32-разрядной системе для поддержки AWE-памяти, либо в 64-разрядной системе) рекомендуем выделить максимальный объем серверной памяти. Дополнительные сведения об LPIM см. в статье [Параметры конфигурации сервера Server Memory](../database-engine/configure-windows/server-memory-server-configuration-options.md#lock-pages-in-memory-lpim).

> [!NOTE]
> Более старые версии [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] можно запустить в 32-разрядной операционной системе. Чтобы охватить свыше 4 ГБ памяти в 32-разрядной операционной системе, требуется использовать расширения AWE для управления памятью. Это необязательно, если [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняется в 64-разрядных операционных системах. Дополнительные сведения о расширениях AWE см. в документации [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)]: [Адресное пространство процесса](/previous-versions/sql/sql-server-2008-r2/ms189334(v=sql.105)) и [Управление памятью для больших баз данных](/previous-versions/sql/sql-server-2008-r2/ms191481(v=sql.105)).   

<a name="changes-to-memory-management-starting-2012-11x-gm"></a>

## <a name="changes-to-memory-management-starting-with-sssql11"></a>Изменения управления памятью, начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]

В более ранних версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ([!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)] и [!INCLUDE[ssKilimanjaro](../includes/ssKilimanjaro-md.md)]) память выделялась с помощью пяти разных механизмов.
-  **Одностраничный распределитель (SPA)** , к которому относится только выделение памяти объемом не больше 8 КБ в процессе [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Пределы физической памяти, используемой SPA, определяют параметры конфигурации *Макс. памяти сервера (МБ)* и *Мин. памяти сервера (МБ)* . Буферный пул был одновременно механизмом для SPA и самым крупным потребителем одностраничных выделений.
-  **Многостраничный распределитель (MPA)** для выделения памяти в объемах больше 8 КБ.
-  **Распределитель CLR**, в том числе кучи SQL CLR и глобального выделения памяти во время инициализации CLR.
-  Выделение памяти для **[стеков потоков](../relational-databases/memory-management-architecture-guide.md#stacksizes)** в процессе [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].
-  **Прямое выделение памяти Windows (DWA)** для запросов на выделение памяти, отправленных напрямую в Windows. Они включают использование кучи Windows и прямое виртуальное выделение от модулей, которые загружаются в процесс [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Примеры таких запросов на выделение включают выделение в библиотеках DLL с расширенными хранимыми процедурами, объекты, созданные с помощью процедур автоматизации (вызовов sp_OA), и выделение со стороны связанных поставщиков сервера.

Начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], одностраничное, многостраничное выделение и выделение CLR будут объединены в **распределителе страниц "Любой размер"** и будут учитываться в пределах для памяти, управляемых параметрами конфигурации *Макс. памяти сервера (МБ)* и *Мин. памяти сервера (МБ)* . Это изменение позволяет более точно измерять размер для всех требований к памяти, которые проходят через диспетчер памяти [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. 

> [!IMPORTANT]
> Внимательно ознакомьтесь с текущими параметрами конфигурации *Макс. памяти сервера (МБ)* и *Мин. памяти сервера (МБ)* после обновления до [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] с помощью [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. Начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], такие параметры конфигурации теперь включают и учитывают больше видов выделения памяти по сравнению с более ранними версиями. Эти изменения применяются к 32-разрядной и 64-разрядной версиям [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] и [!INCLUDE[ssSQL14](../includes/sssql14-md.md)], а также 64-разрядным версиям [!INCLUDE[ssSQL15](../includes/sssql15-md.md)] через [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].

В следующей таблице указано, управляется ли определенный тип выделения памяти параметрами конфигурации *Макс. памяти сервера (МБ)* и *Мин. памяти сервера (МБ)* .

|Тип выделения памяти| [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)]и [!INCLUDE[ssKilimanjaro](../includes/ssKilimanjaro-md.md)]| Начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]|
|-------|-------|-------|
|Одностраничные выделения|Да|Да, объединяются в выделения страниц "Любой размер"|
|Многостраничные выделения|Нет|Да, объединяются в выделения страниц "Любой размер"|
|Выделения CLR|нет|Да|
|Память стеков потоков|Нет|Нет|
|Прямые выделения из Windows|Нет|Нет|

Начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может выделять больше памяти, чем указано в значении "Макс. памяти сервера". Это поведение может возникать, если значение **_Общая память сервера (КБ)_** уже достигло параметра **_Целевая память сервера (КБ)_** (как указано в параметре "Макс. память сервера"). Если из-за фрагментации памяти недостаточно смежных областей свободной памяти для соответствия требованиям многостраничных запросов памяти (больше 8 КБ), [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может превысить объем вместо отклонения запроса памяти. 

Сразу после выделения фоновая задача *Монитор ресурсов* даст сигнал всем потребителям памяти освободить выделенную память и попытается снизить значение *Общая память сервера (КБ)* до параметра *Целевая память сервера (КБ)* . Следовательно, использование памяти [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может ненадолго превысить параметр "Макс. памяти сервера". В этом случае число запросов на чтение счетчика производительности *Общая память сервера (КБ)* превысит параметры "Макс. памяти сервера" и *Целевая память сервера (КБ)* .

Это поведение обычно возникает в следующих операциях. 
-  Крупные запросы индекса сolumnstore.
-  Сборки индекса сolumnstore (в том числе повторные), которые используют большие объемы памяти для хэширования и сортировки.
-  Архивация, которая требует крупных буферов памяти.
-  Операции трассировки, которые должны хранить параметры ввода большого объема.

<a name="#changes-to-memory-management-starting-with-includesssql11includessssql11-mdmd"></a>
## <a name="changes-to-memory_to_reserve-starting-with-sssql11"></a>Изменения memory_to_reserve, начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]
В более ранних версиях SQL Server ([!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)] и [!INCLUDE[ssKilimanjaro](../includes/ssKilimanjaro-md.md)]) диспетчер памяти [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] отводил часть виртуального адресного пространства процесса для использования **многостраничным распределителем (MPA)** , **распределителем CLR**, выделением памяти для **стеков потоков** в процессе SQL Server и **прямым выделением Windows (DWA)** . Эта часть виртуального адресного пространства также называется регионом оставляемой памяти или буферным пулом.

Виртуальное адресное пространство, зарезервированное для этих выделений, определяется параметром конфигурации _**memory\_to\_reserve**_. Значение по умолчанию, которое использует [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], — 256 МБ. Чтобы переопределить значение по умолчанию, используйте параметр запуска [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] *-g*. Сведения о параметре запуска *-g* см. на странице документации [Параметры запуска службы ядра СУБД](../database-engine/configure-windows/database-engine-service-startup-options.md).

Так как, начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], новый распределитель страниц "Любой размер" также обрабатывает выделения размером больше 8 КБ, значение *memory_to_reserve* не включает многостраничные выделения. Все остальное в отношении этого параметра конфигурации остается без изменений.

В следующей таблице указано, попадает ли конкретный тип выделения памяти в регион *memory_to_reserve* виртуального адресного пространства для процесса [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].

|Тип выделения памяти| [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)]и [!INCLUDE[ssKilimanjaro](../includes/ssKilimanjaro-md.md)]| Начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]|
|-------|-------|-------|
|Одностраничные выделения|Нет|Нет, объединяется в выделения страниц "Любой размер"|
|Многостраничные выделения|Да|Нет, объединяется в выделения страниц "Любой размер"|
|Выделения CLR|Да|Да|
|Память стеков потоков|Да|Да|
|Прямые выделения из Windows|Да|Да|

## <a name="dynamic-memory-management"></a><a name="dynamic-memory-management"></a> Динамическое управление памятью
Поведение управления памятью в компоненте [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] по умолчанию заключается в использовании памяти по мере необходимости, но в таком объеме, чтобы исключить нехватку памяти в системе. Компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] осуществляет это при помощи API уведомления памяти в Microsoft Windows.

Когда [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует память динамически, он периодически опрашивает систему, чтобы определить объем свободной памяти. Поддержание достаточного объема свободной памяти позволяет избежать подкачки в операционной системе (ОС). Если свободно меньше памяти, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] высвобождает память для ОС. Если свободно больше памяти, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может выделить дополнительный объем памяти. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] добавляет память, только если она требуется для рабочей нагрузки; во время простоя сервера размер виртуального адресного пространства не увеличивается.  
  
**[Максимальная память сервера](../database-engine/configure-windows/server-memory-server-configuration-options.md)** управляет выделением памяти [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], памятью компиляции, всеми кэшами (включая буферный пул), [временно предоставляемыми буферами памяти для выполнения запросов](#effects-of-min-memory-per-query), [памятью диспетчера блокировки](#memory-used-by-sql-server-objects-specifications) и памятью CLR <sup>1</sup> (фактически любым клерком памяти, находящимся в **[sys.dm_os_memory_clerks](../relational-databases/system-dynamic-management-views/sys-dm-os-memory-clerks-transact-sql.md)** ). 

<sup>1</sup> Память CLR управляется в рамках выделения по max_server_memory, начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)].

Следующий запрос возвращает информацию о текущей выделенной памяти.  
  
```sql  
SELECT 
  physical_memory_in_use_kb/1024 AS sql_physical_memory_in_use_MB, 
    large_page_allocations_kb/1024 AS sql_large_page_allocations_MB, 
    locked_page_allocations_kb/1024 AS sql_locked_page_allocations_MB,
    virtual_address_space_reserved_kb/1024 AS sql_VAS_reserved_MB, 
    virtual_address_space_committed_kb/1024 AS sql_VAS_committed_MB, 
    virtual_address_space_available_kb/1024 AS sql_VAS_available_MB,
    page_fault_count AS sql_page_fault_count,
    memory_utilization_percentage AS sql_memory_utilization_percentage, 
    process_physical_memory_low AS sql_process_physical_memory_low, 
    process_virtual_memory_low AS sql_process_virtual_memory_low
FROM sys.dm_os_process_memory;  
```  
 
<a name="stacksizes"></a> Параметр "Макс. памяти сервера" **не** контролирует память для стеков потоков <sup>1</sup>, CLR <sup>2</sup>, DLL–файлов расширенных процедур, поставщиков OLE DB, на которые ссылаются распределенные запросы, объектов автоматизации, на которые ссылаются операторы [!INCLUDE[tsql](../includes/tsql-md.md)], и память, выделяемую библиотеками DLL, не относящимися к [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].

<sup>1</sup> Сведения о вычисляемых рабочих потоках по умолчанию для указанного числа родственных ЦП на текущем узле см. в разделе [Настройка параметра конфигурации сервера "Максимальное число рабочих потоков"](../database-engine/configure-windows/configure-the-max-worker-threads-server-configuration-option.md). Размеры стеков [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] имеют следующие значения.

|Архитектура SQL Server|Архитектура ОС|Размер стека|  
|--------------------|----------------------|----------------------|
|x86 (32-разрядная версия)|x86 (32-разрядная версия)|512 КБ|
|x86 (32-разрядная версия)|x64 (64-разрядная версия)|768 КБ| 
|x64 (64-разрядная версия)|x64 (64-разрядная версия)|2048 КБ|
|IA64 (Itanium)|IA64 (Itanium)|4096 КБ|

<sup>2</sup> Память CLR управляется в рамках выделений max_server_memory, начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)].

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] определяет, когда диспетчер памяти [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может выделить и освободить память, с помощью API уведомлений памяти **QueryMemoryResourceNotification**.  

При запуске [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вычисляется размер виртуального адресного пространства для буферного пула на основании числа параметров, таких как объем физической памяти в системе, число потоков сервера и различные параметры запуска. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] резервирует вычисляемый объем виртуального адресного пространства процесса для буферного пула, но занимает (фиксирует) только необходимый объем физической памяти для текущей нагрузки.

После этого экземпляр продолжает занимать память по мере необходимости для поддержания рабочей нагрузки. По мере того как больше пользователей подключается и выполняет запросы, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] занимает дополнительную физическую память. Экземпляр [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] продолжает занимать физическую память до тех пор, пока заполнение памяти сервера не достигнет максимальных пределов, или до тех пор, пока ОС не сообщит о том, что свободной памяти не осталось. Он освобождает память, если она занята больше, чем указано в параметре min server memory, а ОС сообщает о том, что свободной памяти не хватает. 

По мере того как на компьютере, где запущен экземпляр [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], запускаются другие приложения, они используют память, и объем свободной физической памяти падает ниже цели [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . Экземпляр [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] корректирует использование памяти. При остановке какого-либо приложения ресурсы освобождаются, и экземпляр [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] увеличивает объем выделяемой памяти. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ежесекундно может освобождать и занимать несколько мегабайт памяти, что позволяет быстро регулировать ее выделение.

## <a name="effects-of-min-and-max-server-memory"></a>Параметры настройки min server memory и max server memory
Параметры конфигурации *Мин. памяти сервера* и *Макс. памяти сервера* устанавливают верхний и нижний пределы объема памяти, занятого буферным пулом и другими кэшами ядра СУБД [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Буферный пул не сразу выделяет объем памяти, определенный минимальным значением. Он начинает расти от объема, необходимого для инициализации. По мере увеличения рабочей нагрузки на компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] выделение памяти продолжается. Буферный пул не освободит занятую память, пока не достигнет размера, определенного минимальным значением. Как только это значение будет достигнуто, буферный пул применит стандартный алгоритм выделения и освобождения памяти по мере необходимости. Единственное отличие заключается в том, что буферный пул никогда не освобождает объем памяти ниже предела, определяемого параметром "Минимальная память сервера", — и никогда не занимает объем больше предела, определяемого параметром "Максимальная память сервера".

> [!NOTE]
> Сам[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] как процесс занимает больше памяти, чем указано в параметре max server memory. И внутренние, и внешние компоненты могут занимать память за пределами буферного пула, что также входит в ее общий расход, однако буферный пул все еще составляет наибольшую часть общего объема памяти, потребляемого [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].

Объем памяти, занимаемой компонентом [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)], напрямую зависит от рабочей нагрузки на экземпляр. Экземпляр [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] , обрабатывающий не слишком много запросов, может и не достигнуть предела, указываемого параметром min server memory.

Если и для параметра "Мин. памяти сервера", и для параметра "Макс. памяти сервера" указано одно и то же значение, то как только выделенная для [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] память достигает этого значения, [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] прекращает динамическое выделение и освобождение памяти для буферного пула.

Если экземпляр [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] работает на компьютере, на котором часто запускаются и останавливаются другие приложения, выделение и освобождение памяти экземпляром [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может замедлить запуск других приложений. Кроме того, если [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] является одним из нескольких серверных приложений, выполняющихся на компьютере, системным администраторам может понадобиться возможность контроля памяти, выделяемой для [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. В таких случаях параметры min server memory и max server memory помогут управлять объемами памяти, потребляемой [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . Значения параметров **Мин. памяти сервера** и **Макс. памяти сервера** указываются в мегабайтах. Дополнительные сведения см. в статье [Параметры конфигурации сервера Server Memory](../database-engine/configure-windows/server-memory-server-configuration-options.md).

## <a name="memory-used-by-sql-server-objects-specifications"></a>Требования к объему памяти для хранения объектов SQL Server
Следующий список содержит обобщенные сведения об объеме памяти, потребляемой разными объектами [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Эти значения являются оценочными и могут отличаться в зависимости от среды и способов создания объектов.

* Блокировка (поддерживается диспетчером блокировки): 64 байта + 32 байта на владельца   
* Подключение пользователя: приблизительно (3 \* размер_сетевого_пакета + 94 КБ)    

**Размер сетевого пакета** — это размер пакетов схемы табличных данных, которые используются для обмена данными между приложениями и ядром СУБД [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. По умолчанию размер пакета равен 4 КБ, а его настройка осуществляется с помощью параметра конфигурации network packet size.

Если включено использование режима MARS, подключение пользователя занимает примерно (3+3 \*число_логических_соединений)\* размер_сетевого_пакета + 94 КБ.

## <a name="effects-of-min-memory-per-query"></a>Влияние параметра min memory per query
Параметр конфигурации *min memory per query* определяет минимальный объем памяти (в килобайтах), выделяемый для выполнения запроса. Он также называется минимальным временно предоставляемым буфером памяти. Все запросы должны ожидать выполнения до момента освобождения необходимого объема памяти либо истечения времени ожидания, указанного в параметре конфигурации сервера query wait. Типом ожидания в этом сценарии является RESOURCE_SEMAPHORE.

> [!IMPORTANT]
> Не следует задавать слишком большое значение для параметра конфигурации сервера min memory per query, особенно в случае высоконагруженных систем, так как это может иметь следующие последствия:         
> - усиление состязаний за ресурсы памяти;         
> - снижение уровня параллелизма из-за увеличения объема памяти, выделяемого для каждого запроса, даже если требуемый объем памяти во время выполнения меньше значения этого параметра.    
>    
> Рекомендации по использованию этого параметра см. в статье [Настройка параметра конфигурации сервера min memory per query](../database-engine/configure-windows/configure-the-min-memory-per-query-server-configuration-option.md#Recommendations).

### <a name="memory-grant-considerations"></a><a name="memory-grant-considerations"></a>Рекомендации, касающиеся временно предоставляемого буфера памяти
В **построчном режиме выполнения** начальный временно предоставляемый буфер памяти не должен превышаться ни при каких условиях. Если для выполнения операций **хэширования** или **сортировки** требуется больше памяти, чем имеется в начальном буфере, операции будут переноситься на диск. Переносимая операция хэширования поддерживается рабочим файлом в TempDB, а переносимая операция сортировки поддерживается [рабочей таблицей](../relational-databases/query-processing-architecture-guide.md#worktables).   

Перенос, происходящий во время операции сортировки, называется [предупреждением сортировки](../relational-databases/event-classes/sort-warnings-event-class.md). Предупреждения сортировки указывают на то, что операциям сортировки не хватает памяти. Сюда не входят операции сортировки, предполагающие создание индексов, а входят только операции сортировки в запросе (например предложение `ORDER BY`, используемое в инструкции `SELECT`).

Перенос, происходящий во время операции хэширования, называется [предупреждением хэширования](../relational-databases/event-classes/hash-warning-event-class.md). Такие предупреждения происходят при возникновении рекурсии во время операции хэширования или при прекращении хеширования (достигнут верхний предел хэширования).
-  Рекурсия хэша возникает, когда входные данные не помещаются в доступную память, что приводит к разбиению их на несколько отдельно обрабатываемых секций. Если какая-либо из этих секций все же не помещается в доступную память, она разбивается на подсекции, которые также обрабатываются отдельно. Процесс разбиения продолжается, либо пока все секции не будут помещаться в доступную память, либо пока не будет достигнут максимальный уровень рекурсии.
-  Аварийное хэширование происходит, когда операция хэширования достигает максимального уровня рекурсии и переходит к альтернативному плану обработки оставшихся секционированных данных. Эти события могут снизить производительность сервера.

В **пакетном режиме выполнения** начальный временно предоставляемый буфер памяти может динамически увеличиваться до некоторого порогового значения, заданного в системе по умолчанию. Этот механизм динамического предоставления временного буфера памяти призван обеспечить выполнение резидентных операций **хэширования** или **сортировки** в пакетном режиме. Если этим операциям все же не хватает памяти, они переносятся на диск.

Дополнительные сведения о режимах выполнения см. в статье [Руководство по архитектуре обработки запросов](../relational-databases/query-processing-architecture-guide.md#execution-modes).

## <a name="buffer-management"></a>Управление буферами
Главное назначение базы данных [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] — хранение и поиск данных, поэтому интенсивное использование операций дискового ввода-вывода — это основное свойство компонента Database Engine. А так как дисковые операции ввода-вывода могут потреблять много ресурсов и требовать относительно длительного времени для выполнения, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] обращает огромное внимание на рациональное использование операций ввода-вывода. Управление буфером — это ключевой компонент в достижении этой рациональности. Компонент управления буферами состоит из двух механизмов: **диспетчера буферов** для доступа к страницам баз данных и их обновления и **буферного кэша** (также называемого **буферным пулом**) для сокращения числа операций ввода-вывода файла базы данных. 

### <a name="how-buffer-management-works"></a>Принцип работы управления буфером
Буфер — это страница размером 8 КБ в памяти, того же размера, что и страница данных или индекса. Буферный кэш делится на страницы размером 8 КБ. Диспетчер буферов содержит функции чтения страниц данных или индекса из файлов базы данных на диске в буферный кэш и записывает измененные страницы обратно на диск. Страница остается в буферном кэше, пока диспетчеру буферов требуется область буфера для чтения дополнительных данных. Данные записываются обратно на диск, только если они были изменены. Данные в буферном кэше могут измениться несколько раз, прежде чем будут сохранены обратно на диске. Дополнительные сведения см. в статьях [Считывание страниц](../relational-databases/reading-pages.md) и [Запись страниц](../relational-databases/writing-pages.md).

При запуске [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вычисляется размер виртуального адресного пространства для буферного кэша на основе таких параметров, как объем физической памяти в системе, указанное максимальное число потоков сервера и разных параметров запуска. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] резервирует вычисляемый объем виртуального адресного пространства процесса (называемого целевой памятью) для буферного кэша, но занимает (фиксирует) только необходимый объем физической памяти для текущей нагрузки. Можно запросить столбцы **bpool_commit_target** и **bpool_committed** в представлении каталога [sys.dm_os_sys_info](../relational-databases/system-dynamic-management-views/sys-dm-os-sys-info-transact-sql.md) , чтобы получить число зарезервированных страниц в качестве указателя памяти и число зафиксированных страниц в буферном кэше соответственно.

Интервал между запуском [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и получением буфером кэша указателя памяти называется линейным нарастанием. В течение этого времени читаемые запросы заполняют буфер по мере заполнения. Например, запрос чтения одной страницы размером 8 КБ заполняет одну страницу буфера. Это означает, что линейное нарастание зависит от числа и типа запросов клиента. Линейное нарастание ускоряется благодаря преобразованию запросов чтения одной страницы в запросы, одновременно работающие с восемью страницами (что дает один экстент). Это позволяет линейному нарастанию завершить операцию намного быстрее, особенно на машинах с большим объемом памяти. Дополнительные сведения о страницах и экстентах см. в разделе [Руководство по архитектуре страниц и экстентов](../relational-databases/pages-and-extents-architecture-guide.md#pages-and-extents).

Поскольку диспетчер буферов использует большой объем памяти в процессе [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] , он взаимодействует с диспетчером памяти, чтобы дать возможность другим компонентам использовать его буфер. Диспетчер буферов взаимодействует прежде всего со следующими компонентами.

* Диспетчер ресурсов управляет полным использованием памяти и использованием адресного пространства на 32-разрядных платформах.  
* Диспетчер базы данных и операционная система [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] (SQLOS) для низкоуровневых операций файлового ввода-вывода.  
* Диспетчер журнала для упреждающего ведения журнала.  

### <a name="supported-features"></a>Поддерживаемые функции
Диспетчер буферов поддерживает следующие возможности:

* Он учитывает **неоднородный доступ к памяти (NUMA)** . Страницы буферного кэша распределены между узлами оборудования NUMA, которые позволяют потоку обращаться к странице буфера, расположенной на локальном узле NUMA, а не во внешней памяти. 
* Диспетчер буферов поддерживает технологию **памяти с горячей заменой**, которая позволяет пользователям добавлять физическую память, не перезапуская сервер. 
* Диспетчер буферов поддерживает **большие страницы** на 64-разрядных платформах. Размер страницы зависит от версии Windows.

  > [!NOTE]
  > До [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] включение больших страниц в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] требует [флаг трассировки 834](../t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql.md).  

* Диспетчер буферов обеспечивает дополнительную диагностику, выполняемую с помощью динамических административных представлений. Можно использовать эти представления, чтобы контролировать различные ресурсы операционной системы, характерные для [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Например, можно использовать представление [sys.dm_os_buffer_descriptors](../relational-databases/system-dynamic-management-views/sys-dm-os-buffer-descriptors-transact-sql.md), чтобы отслеживать страницы в буферном кэше.   

### <a name="disk-io"></a>Операции дискового ввода-вывода
Диспетчер буферов выполняет только чтение и запись в базу данных. Другие операции над файлами и базами данных, такие как открытие, закрытие, расширение и сжатие, выполняются диспетчером базы данных и компонентами диспетчера файлов. 

Дисковые операции ввода-вывода, выполняемые диспетчером буферов, имеют следующие характеристики.

* Все операции ввода-вывода выполняются асинхронно, что позволяет вызывающему потоку продолжать обработку во время выполнения операции ввода-вывода в фоновом режиме.
* Все операции ввода-вывода происходят в вызывающих потоках, если не используется параметр affinity I/O. Параметр «affinity I/O mask» привязывает операцию дискового ввода-вывода [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] к определенному подмножеству ЦП. В средах [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] высокоскоростной обработки транзакций (OLTP) данное расширение может улучшать производительность потоков [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] , выдающих вводы-выводы.
* Операции ввода-вывода нескольких страниц выполняются с операциями ввода-вывода с разбросом, что позволяет передавать данные из прерывающихся областей памяти. Это означает, что [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может быстро заполнить или записать на диск буферный кэш, предотвращая множество физических запросов операций ввода-вывода. 

#### <a name="long-io-requests"></a>Длительные запросы операций ввода-вывода  
Диспетчер буферов сообщает о любых запросах операций ввода-вывода, которые не были выполнены в течение 15 секунд. Это помогает системному администратору различать ошибки [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и ошибки подсистемы ввода-вывода. Появляется сообщение об ошибке 833, и в журнал ошибок [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] записывается следующее:

`SQL Server has encountered ## occurrence(s) of I/O requests taking longer than 15 seconds to complete on file [##] in database [##] (#). The OS file handle is 0x00000. The offset of the latest long I/O is: 0x00000.` 

Длительная операция ввода-вывода может быть чтением или записью; в настоящий момент это не указывается в сообщении. Сообщение о длительной операции ввода-вывода является предупреждением, а не ошибкой. Они указывают не на проблемы с [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], а на проблемы в базовой системе ввода-вывода. Сообщения помогают системному администратору быстрее находить причину длительного времени отклика [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и распознавать ошибки, происходящие вне средств [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Также они не требуют никакого действия, но системный администратор должен выяснить, почему выполнение запроса ввода-вывода заняло столько времени и оправдано ли это.

#### <a name="causes-of-long-io-requests"></a>Причины длительных запросов операций ввода-вывода  
Сообщение о длительной операции ввода-вывода может указывать на то, что ввод-вывод постоянно блокируется и никогда не будет завершен (потерянные операции ввода-вывода) или что он еще не завершен. По сообщению невозможно понять, какой сценарий имеет место, хотя потерянные операции ввода-вывода часто приводят к истечению времени ожидания кратковременной блокировки.

Длительные операции ввода-вывода часто имеют рабочую нагрузку [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] , которая является слишком интенсивной для дисковой подсистемы. Неуправляемая дисковая подсистема может быть получена в следующих случаях.

* В журнале ошибок появляются несколько сообщений о длительных операциях ввода-вывода во время большой рабочей нагрузки [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] .
* Счетчики системного монитора показывают большую задержку, длинные очереди или отсутствие времени простоя диска.  

Длительные операции ввода-вывода также могут быть вызваны компонентом в пути ввода-вывода (например драйвером, контроллером или встроенным ПО), постоянно откладывающим обслуживание старого запроса ввода-вывода в пользу обслуживания более новых запросов, которые ближе к текущей позиции головки диска. Основная методика обработки запросов, которые наиболее близки к текущей позиции головки для чтения-записи, называется «элеваторный поиск». Это довольно сложно отследить с помощью системного монитора Windows (PERFMON.EXE), так как большинство операций ввода-вывода выполняется быстро. Длительные операции ввода-вывода могут усугубляться рабочими нагрузками, которые выполняют большой объем операций последовательного ввода-вывода, например: создание резервных копий и восстановление, просмотр таблиц, сортировку, создание индексов, массовую загрузку и очистку файлов.

Изолированные длительные операции ввода-вывода, которые не связаны с любой из указанных выше причин, могут быть вызваны ошибками драйвера или оборудования. Журнал системных событий может содержать связанные события, которые помогают выявить ошибку.

### <a name="memory-pressure-detection"></a>Обнаружение нехватки памяти
Нехватка памяти — это состояние, возникающие в результате недостаточного объема памяти. Оно может иметь следующие последствия:
- дополнительные операции ввода-вывода (например, очень активный фоновый поток модуля отложенной записи);
- более высокий коэффициент перекомпиляции;
- более длительное выполнение запросов (если имеются задержки временно предоставляемого буфера памяти);
- дополнительные циклы ЦП.

Это состояние может возникать по внешним или внутренним причинам. Возможные внешние причины:
- Недостаточный объем доступной физической памяти. Из-за этого система может ограничивать рабочие наборы выполняющихся в настоящее время процессов, что может приводить к общему замедлению работы. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может снизить целевой уровень фиксации буферного пула и начать чаще усекать внутренние кэши. 
- Недостаточный общий объем памяти, доступной в системе (включая системный файл подкачки). Из-за этого системе может не удаваться выделить память из-за невозможности выгрузить в файл подкачки выделенную в настоящее время память.
Возможные внутренние причины:
- Реагирование на внешнюю нагрузку на память, когда [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] задает более низкие ограничения на использование памяти.
- Настройки памяти были ограничены вручную путем уменьшения значения параметра *max server memory*. 
- Изменения в распределении памяти для внутренних компонентов между несколькими кэшами.

В [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] реализован механизм, предназначенный для обнаружения и обработки нехватки памяти в рамках динамического управления памятью. Этот механизм включает в себя фоновую задачу **Монитор ресурсов**. Задача "Монитор ресурсов" отслеживает состояние внешних и внутренних индикаторов памяти. Как только состояние одного из этих индикаторов меняется, он определяет соответствующее уведомление и рассылает его. Уведомления представляют собой внутренние сообщения от каждого из компонентов ядра и хранятся в кольцевых буферах. 

Сведения, относящиеся к динамическому управлению памятью, хранятся в двух кольцевых буферах: 
- Кольцевой буфер монитора ресурсов, который отслеживает действия монитора ресурсов, например подачу сигналов о нехватке памяти. Сведения о состоянии в этом кольцевом буфере зависят от текущего значения *RESOURCE_MEMPHYSICAL_HIGH*, *RESOURCE_MEMPHYSICAL_LOW*, *RESOURCE_MEMPHYSICAL_STEADY* или *RESOURCE_MEMVIRTUAL_LOW*.
- Кольцевой буфер брокера памяти, который содержит записи уведомлений памяти для каждого пула ресурсов Resource Governor. Когда обнаруживается внутренняя нехватка памяти, для компонентов, выделяющих память, включается уведомление о недостаточном объеме памяти. Оно активирует действия, призванные сбалансировать распределение памяти между кэшами. 

Брокеры памяти отслеживают потребление памяти каждым компонентом и на основе собранной информации вычисляют оптимальный объем памяти для каждого из компонентов. Для каждого пула ресурсов Resource Governor имеется набор брокеров. Затем эти сведения рассылаются каждому компоненту, которые уменьшают или увеличивают потребление памяти по мере необходимости.
Дополнительные сведения о брокерах памяти см. в описании представления [sys.dm_os_memory_brokers](../relational-databases/system-dynamic-management-views/sys-dm-os-memory-brokers-transact-sql.md). 

### <a name="error-detection"></a>Определение ошибки  
Страницы базы данных могут использовать один из двух дополнительных механизмов, чтобы обеспечить целостность страницы от момента записи на диск до чтения: защита от разрыва страницы и защита контрольной суммой. Эти механизмы позволяют отдельному методу проверить правильность не только хранения данных, но и компонентов оборудования, например контроллеров, драйверов, кабелей и даже операционной системы. Защита присоединяется к странице как раз перед ее записью на диск и выполняет проверку после чтения страницы с диска.

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] повторяет любую операцию считывания, которая закончилась ошибкой контрольной суммы, разрыва страницы или другой ошибкой ввода-вывода, четыре раза. Если считывание закончится успешно в любой из попыток, то в журнал ошибок будет записано сообщение и команда, вызвавшая считывание, продолжится. Если все повторные попытки закончатся ошибкой, команда закончит работу с сообщением об ошибке 824. 

Вид используемой защиты страницы является атрибутом базы данных, содержащей страницу. Защита контрольной суммой задана по умолчанию для баз данных, созданных в [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] и более поздних версиях. Механизм защиты страницы указывается во время создания базы данных и может быть изменен с помощью инструкции ALTER DATABASE SET. Установку защиты текущей страницы можно определить, создав запрос значения столбца *page_verify_option* в представлении каталога [sys.databases](../relational-databases/system-catalog-views/sys-databases-transact-sql.md) или свойства *IsTornPageDetectionEnabled* функции [DATABASEPROPERTYEX](../t-sql/functions/databasepropertyex-transact-sql.md). 

> [!NOTE]
> Если установка защиты страницы изменена, новая установка сразу не влияет на всю базу данных. Вместо этого страницы принимают текущий уровень защиты базы данных во время следующей записи. Это означает, что база данных может состоять из страниц с различными видами защиты. 

#### <a name="torn-page-protection"></a>Защита от разрыва страницы  
Защита от разрыва страницы, включенная в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 2000, является прежде всего способом обнаружения поврежденных страниц из-за сбоев питания. Например, неожиданный сбой питания может оставить только часть страницы, записанной на диск. Если используется защита от разрывов страниц, для каждого 512-байтового сектора из 8-килобайтовой (КБ) страницы базы данных в заголовке страницы устанавливается особый двухбитный шаблон подписи при записи страницы на диск. При чтении страницы с диска биты разрыва, хранимые в заголовке страницы, сравниваются с действительными сведениями о секторах страницы. В шаблоне подписи после каждой записи чередуются двоичные числа от 01 до 10, поэтому всегда можно определить, что на диск была записана лишь часть секторов. Если при последующем считывании выясняется, что состояние бита неправильное, это означает, что страница записана некорректно и обнаружено ее повреждение. Защита от разрыва страницы использует минимальные ресурсы, однако она не обнаруживает все ошибки, вызванные аппаратными сбоями диска. Дополнительные сведения о настройке обнаружения разрывов страниц см. в разделе [Параметры ALTER DATABASE SET &#40;Transact-SQL&#41;](../t-sql/statements/alter-database-transact-sql-set-options.md#page_verify).

#### <a name="checksum-protection"></a>Защита контрольной суммой  
Защита контрольной суммой, включенная в [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], обеспечивает более надежную проверку целостности данных. Контрольная сумма рассчитывается для данных каждой записанной страницы и сохраняется в колонтитуле. Всякий раз, когда страница с сохраненной контрольной суммой читается с диска, компонент Database Engine повторно вычисляет контрольную сумму для данных страницы и вызывает ошибку 824, если новая контрольная сумма отличается от сохраненной. Защита контрольной суммой может перехватить больше ошибок, чем защита от разрыва страницы, потому что она учитывает каждый байт страницы, однако она более ресурсоемкая. Когда защита контрольной суммой активирована, ошибки, вызванные сбоями питания и поврежденным оборудованием или встроенным ПО, могут быть обнаружены во время чтения страницы с диска диспетчером буферов. Дополнительные сведения о задании контрольной суммы см. в разделе [Параметры ALTER DATABASE SET &#40;Transact-SQL&#41;](../t-sql/statements/alter-database-transact-sql-set-options.md#page_verify).

> [!IMPORTANT]
> При обновлении пользовательской или системной базы данных до версии [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] или более поздней значение [PAGE_VERIFY](../t-sql/statements/alter-database-transact-sql-set-options.md#page_verify) (NONE или TORN_PAGE_DETECTION) сохраняется. Настоятельно рекомендуется использовать CHECKSUM.
> Значение TORN_PAGE_DETECTION использует меньше ресурсов, но обеспечивает минимальный вариант защиты CHECKSUM.

## <a name="understanding-non-uniform-memory-access"></a>Основные сведения о неоднородном доступе к памяти
[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] совместим с архитектурой неоднородного доступа к памяти (NUMA) и хорошо работает на оборудовании NUMA без дополнительной настройки. С ростом тактовой частоты и количества процессоров становится труднее сократить время задержки памяти, необходимой для использования дополнительной производительности системы. Для устранения этого недостатка поставщики оборудования применяют большие кэши третьего уровня, но это является всего лишь полумерой. Архитектура NUMA обеспечивает масштабируемое решение для этой проблемы. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] позволяет использовать преимущество компьютеров на основе NUMA без необходимости изменять что-либо в приложении. Дополнительные сведения см. в разделе [Как настроить SQL Server для использования программной архитектуры NUMA](../database-engine/configure-windows/soft-numa-sql-server.md).

## <a name="dynamic-partition-of-memory-objects"></a>Динамическое секционирование объектов памяти
Распределители кучи, называемые объектами памяти в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], позволяют [!INCLUDE[ssde_md](../includes/ssde_md.md)] выделять память из кучи. Их можно отслеживать с помощью динамического административного представления [sys.dm_os_memory_objects](../relational-databases/system-dynamic-management-views/sys-dm-os-memory-objects-transact-sql.md). CMemThread — это потокобезопасный тип объекта памяти, позволяющий выделять память параллельно из нескольких потоков. Для правильного отслеживания объекты CMemThread пользуются конструкциями синхронизации (мьютекс), чтобы обеспечить обновление критически важных элементов информации одновременно только в одном потоке. 

> [!NOTE]
> Тип объекта CMemThread используется в базе кода [!INCLUDE[ssde_md](../includes/ssde_md.md)] для множества различных распределений и может быть секционирован глобально, по узлам или по ЦП.   

Однако использование мьютексов может привести к состязанию, если из одного объекта памяти выделяется много потоков в режиме высокой конкуренции. Таким образом, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] имеет концепцию секционированных объектов памяти (PMO) и каждая секция представлена одним объектом CMemThread. Секционирование объекта памяти статически определено и не может быть изменено после создания. Так как шаблоны выделения памяти могут сильно различаться в зависимости от таких факторов, как использование оборудования и памяти, невозможно заранее подготовить идеальный шаблон секционирования. В подавляющем большинстве случаев достаточно использовать одну секцию, но в некоторых сценариях это может привести к состязанию, которое можно предотвратить только с помощью объекта памяти с высоким уровнем секционирования. Не рекомендуется секционировать каждый объект памяти, так как большее количество секций может негативно сказаться на эффективности и вызвать фрагментацию памяти.

> [!NOTE]
> Прежде чем [!INCLUDE[ssSQL15](../includes/sssql15-md.md)], можно использовать флаг трассировки 8048, чтобы превратить PMO на основе узла в PMO на основе ЦП. Начиная с [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] с пакетом обновления 2 (SP2) и [!INCLUDE[ssSQL15](../includes/sssql15-md.md)], эта реакция является динамической и управляется подсистемой.

Начиная с [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] с пакетом обновления 2 (SP2) и [!INCLUDE[ssSQL15](../includes/sssql15-md.md)], [!INCLUDE[ssde_md](../includes/ssde_md.md)] может динамически обнаруживать состязание в конкретном объекте CMemThread и менять реализацию объекта между вариантами на основе узла или на основе ЦП.  После изменения реализации PMO остается в этом состоянии до тех пор, пока не будет перезапущен процесс [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Состязание в CMemThread можно обнаружить по большому времени ожидания CMEMTHREAD в динамическом административном представлении [sys.dm_os_wait_stats](../relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql.md), а также по содержанию столбцов динамического административного представления [sys.dm_os_memory_objects](../relational-databases/system-dynamic-management-views/sys-dm-os-memory-objects-transact-sql.md) *contention_factor*, *partition_type*, *exclusive_allocations_count* и *waiting_tasks_count*.

## <a name="see-also"></a>См. также:
[Параметры конфигурации сервера «Server Memory»](../database-engine/configure-windows/server-memory-server-configuration-options.md)   
[Считывание страниц](../relational-databases/reading-pages.md)   
[Запись страниц](../relational-databases/writing-pages.md)   
[Руководство. настроить SQL Server для использования программной архитектуры NUMA](../database-engine/configure-windows/soft-numa-sql-server.md)   
[Требования к использованию оптимизированных для памяти таблиц](../relational-databases/in-memory-oltp/requirements-for-using-memory-optimized-tables.md)   
[Устранение проблем нехватки памяти с помощью оптимизированных для памяти таблиц](../relational-databases/in-memory-oltp/resolve-out-of-memory-issues.md)