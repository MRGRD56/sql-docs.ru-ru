---
title: Среда, размещенная в среде CLR | Документация Майкрософт
description: В этой статье описывается, как интегрированы CLR и SQL Server для управления системными ресурсами единообразно и как интегрируются системы безопасности CAS и SQL Server.
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- type-safe code [CLR integration]
- UNSAFE permission set
- run-time environments [CLR integration]
- common language runtime [SQL Server], about CLR integration
- application domains [CLR integration]
- host protection attributes [CLR integration]
- managed code [SQL Server], common language runtime
- permission sets [CLR integration]
- reliability [CLR integration]
- SAFE permission set
- code access security [CLR integration]
- EXTERNAL_ACCESS permission set
- verifying type safety
- scalability [CLR integration]
- hosted environments [CLR integration]
- HPAs [CLR integration]
ms.assetid: d280d359-08f0-47b5-a07e-67dd2a58ad73
author: rothja
ms.author: jroth
ms.openlocfilehash: 5f39c1c078b470c2b0c2ec47cb8fa69060481259
ms.sourcegitcommit: 370cab80fba17c15fb0bceed9f80cb099017e000
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97642280"
---
# <a name="clr-integration-architecture---clr-hosted-environment"></a>Архитектура интеграции со средой CLR — среда размещения CLR
[!INCLUDE [SQL Server SQL MI](../../includes/applies-to-version/sql-asdbmi.md)]
  Интеграция [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] со средой CLR платформы .NET Framework позволяет программистам работать с базами данных, используя такие языки, как Visual C#, Visual Basic .NET, Visual C++. С помощью этих языков программисты могут создавать различные объекты бизнес-логики, например: функции, хранимые процедуры, триггеры, типы данных и агрегаты.  
  
  Среда CLR включает в себя память для сбора мусора, вытеснение потоков, службы метаданных (отражение типов), проверку кода и управление доступом для кода. В среде CLR метаданные используются для обнаружения и загрузки классов, размещения экземпляров в памяти, разрешения вызовов методов, формирования машинного кода, обеспечения безопасности и определения границ контекста времени выполнения.  
  
 CLR и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] различаются как варианты среды времени выполнения по способам управления памятью, потоками и синхронизацией. В этой статье описывается, как интегрировать эти два времени выполнения, чтобы все системные ресурсы управлялись единообразно. В этой статье также рассматривается способ интеграции управления доступом для кода CLR (CAS) и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] безопасности для обеспечения надежной и безопасной среды выполнения для пользовательского кода.  
  
## <a name="basic-concepts-of-clr-architecture"></a>Основные понятия архитектуры CLR  
 На платформе .NET Framework программист использует язык высокого уровня, который реализует класс, определяющий его структуру (например, поля или свойства класса) и методы. Некоторые из этих методов могут быть статическими функциями. Компиляция программы создает файл, называемый сборкой, содержащей скомпилированный код на [!INCLUDE[msCoName](../../includes/msconame-md.md)] промежуточном языке (MSIL), и манифест, содержащий все ссылки на зависимые сборки.  
  
> [!NOTE]  
>  Сборки — важнейший элемент архитектуры CLR. Они представляют собой средства упаковки, развертывания и управления версиями кода приложений на платформе .NET Framework. С помощью сборок можно развертывать код приложений в базе данных и предоставлять единообразный способ администрирования, создания резервных копий и восстановления законченных приложений базы данных.  
  
 Манифест сборки содержит метаданные о сборке, описывающие все структуры, поля, свойства, классы, связи наследования, функции и методы, определенные в программе. Манифест устанавливает идентификационные данные сборки, указывает файлы, образующие реализацию сборки, задает типы и ресурсы, составляющие сборку, конкретизирует зависимости времени компиляции от других сборок и регламентирует набор разрешений, необходимых для правильного выполнения сборки. Эти сведения используются во время выполнения для разрешения ссылок, применения политики привязки версии и проверки целостности загруженных сборок.  
  
 Платформа .NET Framework поддерживает пользовательские атрибуты для аннотации классов, свойств, функций и методов с дополнительными сведениями, которые приложение может собрать в метаданных. Все компиляторы .NET Framework воспринимают эти заметки без интерпретации и хранят их как метаданные сборки. Эти заметки можно анализировать так же, как любые другие метаданные.  
  
 Управляемый код представляет собой код MSIL, выполняемый в среде CLR, а не непосредственно операционной системой. Приложения с управляемым кодом используют средства служб CLR, такие как автоматическая сборка мусора, проверка типов на стадии выполнения и обеспечение безопасности. Эти службы помогают обеспечить единообразное поведение приложений с управляемым кодом независимо от платформы и языка.  
  
## <a name="design-goals-of-clr-integration"></a>Цели проектирования при интеграции со средой CLR  
 Если пользовательский код выполняется в среде размещения CLR в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] (что принято называть интеграцией со средой CLR), то ставятся следующие цели проектирования.  
  
###### <a name="reliability-safety"></a>Надежность (безопасность)  
 В пользовательском коде не должно быть разрешено выполнение операций, нарушающих целостность процесса компонента Database Engine, таких как вывод окна сообщения, запрашивающего ответ от пользователя, или выход из процесса. Пользовательский код не должен иметь возможности перезаписывать буфера памяти компонента Database Engine или внутренние структуры данных.  
  
###### <a name="scalability"></a>Масштабируемость  
 В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и в среде CLR используются различные внутренние модели планирования и управления памятью. В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживается кооперативная модель потоков без вытеснения, в которой каждый выполняющийся поток должен сам возвращать управление либо по прошествии определенного периода, либо во время ожидания освобождения блокировок или завершения операций ввода-вывода. Среда CLR поддерживает модель потоков с вытеснением. Если в пользовательском коде, выполняемом в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], допускается непосредственный вызов базовых функций управления потоками операционной системы, то интеграция этого кода в планировщик задач [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] становится неудовлетворительной и может снизиться масштабируемость системы. В среде CLR виртуальная и физическая память не различаются, но [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] непосредственно управляет физической памятью и должна использовать физическую память в пределах, определяемых конфигурацией.  
  
 Если должно быть обеспечено масштабирование системы управления реляционной базой данных (СУРБД) в целях одновременной поддержки тысяч пользовательских сеансов, то приходится решать сложные задачи интеграции в связи с применением разных моделей организации потоков, планирования и управления памятью. Создаваемая архитектура должна гарантировать, чтобы на масштабируемость системы не оказывал отрицательное влияние непосредственный вызов в пользовательском коде прикладных программных интерфейсов (API) в целях применения базовых функций управления потоками, памятью и синхронизацией.  
  
###### <a name="security"></a>Безопасность  
 Пользовательский код, выполняемый в базе данных, должен соответствовать правилам проверки подлинности и авторизации [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] при доступе к таким объектам базы данных, как таблицы и столбцы. Кроме того, администраторы баз данных должны иметь возможность управлять доступом к ресурсам операционной системы, таким как файлы и сетевой доступ, осуществляемым из пользовательского кода, который выполняется в базе данных. Этот подход важен, так как управляемые языки программирования (в отличие от неуправляемых языков, таких как Transact-SQL) предоставляют API-интерфейсы для доступа к таким ресурсам. Система должна предоставить безопасный способ доступа пользовательского кода к ресурсам компьютера вне процесса компонента [!INCLUDE[ssDE](../../includes/ssde-md.md)]. Дополнительные сведения см. в статье [CLR Integration Security](../../relational-databases/clr-integration/security/clr-integration-security.md).  
  
###### <a name="performance"></a>Производительность  
 Управляемый пользовательский код, выполняемый в компоненте [!INCLUDE[ssDE](../../includes/ssde-md.md)], должен обеспечивать вычислительную производительность, сравнимую с выполнением того же кода вне сервера. Доступ к базам данных из управляемого пользовательского кода осуществляется не так быстро, как из собственного кода [!INCLUDE[tsql](../../includes/tsql-md.md)]. Дополнительные сведения см. в статье [производительность интеграции со средой CLR](../../relational-databases/clr-integration/clr-integration-architecture-performance.md).  
  
## <a name="clr-services"></a>Службы CLR  
 Среда CLR предоставляет ряд служб, чтобы облегчить достижение целей проектирования для интеграции среды CLR с [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
###### <a name="type-safety-verification"></a>Проверка безопасности типов  
 Типизированный код — это код, который обращается к структурам памяти только строго определенными способами. Например, при наличии допустимой ссылки на объект типизированный код может обращаться к памяти с фиксированными смещениями, соответствующими фактическим полям элементов. Но если код обращается к памяти с произвольными смещениями внутри и вне области памяти, которая принадлежит к объекту, то код нетипизированный. Если выполняется загрузка сборок в среду CLR до компиляции MSIL с использованием JIT-компиляции, то на этапе проверки во время выполнения код анализируется, чтобы можно было определить безопасность типов. Код, успешно прошедший эту проверку, называется «проверяемым типизированным кодом».  
  
###### <a name="application-domains"></a>Домены приложений  
 Среда CLR поддерживает понятие доменов приложений как зон выполнения внутри основного процесса, в который можно загрузить и выполнить сборки управляемого кода. Граница домена приложения обеспечивает изоляцию между сборками. Сборки изолированы с точки зрения видимости статических переменных и элементов данных, а также возможности динамического вызова кода. Домены приложений также обеспечивают механизм для загрузки и выгрузки кода. Код можно выгрузить из памяти, только выгрузив домен приложения. Дополнительные сведения см. в разделе [домены приложений и безопасность интеграции со средой CLR](/previous-versions/sql/2014/database-engine/dev-guide/application-domains-and-clr-integration-security?view=sql-server-2014&preserve-view=true).  
  
###### <a name="code-access-security-cas"></a>CAS (Code Access Security — безопасность доступа кода)  
 Система безопасности CLR обеспечивает способ выбора типа операций, которые могут быть выполнены управляемым кодом, назначая разрешения коду. Разрешения доступа для кода назначаются на основе удостоверения кода (например, подпись сборки или происхождение кода).  
  
 Среда CLR обеспечивает применение политики уровня компьютера, которую может назначить администратор компьютера. Эта политика предоставляет разрешения для любого управляемого кода, выполняемого на компьютере. Кроме того, существует политика безопасности на уровне узла, которую можно использовать на таких узлах, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], чтобы указать дополнительные ограничения для управляемого кода.  
  
 Если управляемый API на платформе .NET Framework предоставляет операции над ресурсами, защищенные набором разрешений на доступ к коду, то API потребует разрешение перед доступом к ресурсу. В силу этого требования система безопасности CLR запускает исчерпывающую проверку каждого блока кода (сборки) в стеке вызова. Доступ к ресурсу будет предоставляться, только если у всей цепочки вызовов есть разрешение.  
  
 Обратите внимание, что возможность динамического создания управляемого кода с использованием API Reflection.Emit в среде размещения CLR в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не поддерживается. Такой код не будет иметь разрешений CAS для выполнения и поэтому завершится неудачей во время выполнения. Дополнительные сведения см. в статье [Безопасность доступа к коду для интеграции со средой CLR](../../relational-databases/clr-integration/security/clr-integration-code-access-security.md).  
  
###### <a name="host-protection-attributes-hpas"></a>Атрибуты защиты узла (HPA)  
 Среда CLR обеспечивает механизм для аннотирования управляемых API, которые являются частью платформы .NET Framework с определенными атрибутами, которые могут представлять интерес для узла CLR. Примеры таких атрибутов включают следующее.  
  
-   SharedState, который указывает, обеспечивает ли API возможность создавать или управлять общим состоянием (например, статическими полями классов).  
  
-   Synchronization, который указывает, обеспечивает ли API возможность выполнять синхронизацию между потоками.  
  
-   ExternalProcessMgmt, который указывает, предоставляет ли API возможность управлять основным процессом.  
  
 С учетом этих атрибутов узел может указать список атрибутов защиты узла, таких как атрибут SharedState, которые должны быть запрещены в управляемой среде. В этом случае среда CLR запрещает попытки пользовательского кода, которые направлены на вызов API, внесенных атрибутами защиты узла в запрещенный список. Дополнительные сведения см. в разделе [атрибуты защиты узла и программирование интеграции со средой CLR](../../relational-databases/clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md).  
  
## <a name="how-sql-server-and-the-clr-work-together"></a>Совместная работа SQL Server и среды CLR  
 В этом разделе описано, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] интегрирует модели организации потоков, планирования, синхронизации и управления памятью [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и среды CLR. В частности, в этом разделе интеграция рассматривается с позиций масштабируемости, надежности и безопасности. В сущности, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняет функцию операционной системы для среды CLR при ее размещении в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Среда CLR вызывает низкоуровневые программы, реализованные в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], для управления потоками, планированием, синхронизацией и памятью. Эти подпрограммы являются теми же примитивами, которые использует остальная часть [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] подсистемы. Этот подход обеспечивает несколько преимуществ с точки зрения масштабируемости, надежности и безопасности.  
  
###### <a name="scalability-common-threading-scheduling-and-synchronization"></a>Масштабируемость. Общие потоки, планирование и синхронизация  
 В среде CLR происходит вызов API [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для создания потоков, как для выполнения пользовательского кода, так и для собственного внутреннего использования. Чтобы синхронизировать несколько потоков, среда CLR вызывает объекты синхронизации [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Такой подход позволяет [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] планировщику запланировать другие задачи, когда поток ожидает объект синхронизации. Например, когда среда CLR запускает сбор мусора, все потоки ожидают завершения сбора мусора. Потоки CLR и ожидаемые ими объекты синхронизации известны планировщику [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], поэтому [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может планировать потоки, которые выполняют другие задачи базы данных, не связанные со средой CLR. Это также позволяет [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обнаруживать взаимоблокировки с участием блокировок, установленных объектами синхронизации CLR, и использовать традиционные методы снятия взаимоблокировок.  
  
 Управляемый код выполняется в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с приоритетным прерыванием. Планировщик [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обеспечивает обнаружение и останов потоков, не возвращающих управление в течение значительного времени. Возможность связывания потоков CLR с потоками [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обусловливает то, что планировщик [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может определять вышедшие из-под контроля потоки в среде CLR и управлять их приоритетом. Такие вышедшие из-под контроля потоки приостанавливаются и возвращаются в очередь. Потокам, которые были повторно обнаружены как вышедшие из-под контроля, запрещается выполняться в течение определенного периода времени, чтобы обеспечить выполнение других рабочих потоков.  
  
 В некоторых ситуациях, когда длительный управляемый код будет автоматически выдаваться и в некоторых ситуациях, где это не так. В следующих ситуациях длительный управляемый код будет автоматически давать следующее:
 
 - Если код вызывает ОС SQL (например, для запроса данных)
 - Если выделено достаточно памяти для запуска сборки мусора
 - Если код переходит в режим с вытеснением путем вызова функций ОС

 Код, который не выполняет никаких описаний, например, ограниченные циклы, содержащие только вычисления, не будет автоматически давать планировщику, что может привести к длительному ожиданию других рабочих нагрузок в системе. В таких ситуациях разработчику необходимо явно вызвать функцию System. Thread. Sleep () .NET Framework или явно войти в режим примтиве с помощью System. Thread. BeginThreadAffinity () в любом разделе кода, который ожидается долгое выполнение. В следующих примерах кода показано, как вручную использовать каждый из этих методов.

 ```c#
// Example 1: Manually yield to SOS scheduler.
for (int i = 0; i < Int32.MaxValue; i++)
{
  // *Code that does compute-heavy operation, and does not call into
  // any OS functions.*

  // Manually yield to the scheduler regularly after every few cycles.
  if (i % 1000 == 0)
  {
    Thread.Sleep(0);
  }
}
 ```

```c#
// Example 2: Use ThreadAffinity to run preemptively.
// Within BeginThreadAffinity/EndThreadAffinity the CLR code runs in preemptive mode.
Thread.BeginThreadAffinity();
for (int i = 0; i < Int32.MaxValue; i++)
{
  // *Code that does compute-heavy operation, and does not call into
  // any OS functions.*
}
Thread.EndThreadAffinity();
```
  
###### <a name="scalability-common-memory-management"></a>Масштабируемость. общее управление памятью  
 Среда CLR вызывает базовые функции [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для выделения и отмены выделения памяти. Память, используемая средой CLR, учитывается в общем объеме использования памяти системы, поэтому [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может оставаться в пределах памяти, заданных в конфигурации, и предотвращать конкуренцию за память между средой CLR и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может также отвергать запросы памяти от среды CLR при ограниченном объеме доступной системной памяти и запрашивать у среды CLR сокращение использования памяти, если память нужна другим задачам.  
  
###### <a name="reliability-application-domains-and-unrecoverable-exceptions"></a>Надежность: домены приложений и невосстанавливаемые исключения  
 Когда управляемый код в API .NET Framework встречает критические исключения, такие как нехватка памяти или переполнение стека, не всегда удается выполнить восстановление после отказа и обеспечить согласованную и правильную семантику для их реализации. Эти API активизируют исключение прерывания потока в ответ на такие отказы.  
  
 При размещении в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] такие прерывания потока обрабатываются следующим образом: среда CLR обнаруживает любое общее состояние в домене приложения, в котором происходит прерывание потока. Среда CLR обнаруживает это с помощью проверки наличия объектов синхронизации. Если в домене приложения имеется общее состояние, то выгружается сам домен приложения. В результате выгрузки домена приложения останавливаются транзакции базы данных, выполняемые в это время в домене приложения. Поскольку присутствие общего состояния может увеличить влияние таких критических исключений на пользовательские сеансы, отличные от сеанса, вызвавшего исключение, в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и среде CLR приняты меры для уменьшения вероятности возникновения общего состояния. Дополнительные сведения см. в документации по .NET Framework.  
  
###### <a name="security-permission-sets"></a>Безопасность: наборы разрешений  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] позволяет пользователям указывать требования к надежности и безопасности для кода, развернутого в базе данных. Когда сборки загружаются в базу данных, автор сборки может указать один из трех наборов разрешений для этой сборки: "надежный", "EXTERNAL_ACCESS" и "ненадежный".  
  
|функциональное назначение;|SAFE|EXTERNAL_ACCESS|UNSAFE|  
|-|-|-|-|  
|Управление доступом для кода|Только выполнение|Выполнение и доступ к внешним ресурсам|С неограниченным доступом|  
|Ограничения модели программирования|Да|Да|Нет ограничений|  
|Требование к проверяемости|Да|Да|Нет|  
|Возможность вызова машинного кода|Нет|Нет|Да|  
  
 SAFE — самый надежный и безопасный режим с соответствующими ограничениями в отношении разрешенной программной модели. Сборки SAFE получают достаточные разрешения для запуска, выполнения вычислений и доступа к локальной базе данных. Сборки SAFE должны использовать безопасные типы с возможностью проверки этого факта; они также не могут вызывать неуправляемый код.  
  
 Режим UNSAFE предназначен для кода с высоким уровнем доверия, который могут создавать только администраторы базы данных. На этот доверенный код не налагаются ограничения управления доступом для кода, и он может вызывать неуправляемый (машинный) код.  
  
 Режим EXTERNAL_ACCESS обеспечивает промежуточный уровень безопасности, в котором код может обращаться к ресурсам, внешним по отношению к базе данных, и при этом иметь гарантии надежности уровня SAFE.  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует уровень политики CAS на уровне узла, чтобы установить политику узла, которая предоставляет один из трех наборов разрешений на основе набора разрешений, хранимого в каталогах [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Управляемый код, выполняемый внутри базы данных, всегда получает один из этих наборов разрешений доступа для кода.  
  
### <a name="programming-model-restrictions"></a>Ограничения модели программирования  
 Модель программирования для управляемого кода в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] включает написание функций, процедур и типов, которые обычно не требуют использования общего состояния в нескольких вызовах или общего состояния нескольких пользовательских сеансов. Кроме того, как было описано выше, наличие общего состояния может привести к критическим исключениям, которые влияют на масштабируемость и надежность приложения.  
  
 С учетом этих факторов не рекомендуется использовать статические переменные и статические элементы данных классов, используемых в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Для сборок SAFE и EXTERNAL_ACCESS в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] анализируются метаданные сборки во время выполнения инструкции CREATE ASSEMBLY и отменяется создание таких сборок, если будет обнаружено использование статических элементов данных и переменных.  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] также запрещает вызовы .NET Framework API, помеченные атрибутами защиты узла **шаредстате**, **Synchronization** и **екстерналпроцессмгмт** . Это не позволяет сборкам SAFE и EXTERNAL_ACCESS направлять вызовы к любым API, которые поддерживают общее состояние, выполнение синхронизации и влияют на целостность процесса [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в разделе [ограничения модели программирования интеграции со средой CLR](../../relational-databases/clr-integration/database-objects/clr-integration-programming-model-restrictions.md).  
  
## <a name="see-also"></a>См. также:  
 [Безопасность интеграции со средой CLR](../../relational-databases/clr-integration/security/clr-integration-security.md)   
 [Производительность интеграции со средой CLR](../../relational-databases/clr-integration/clr-integration-architecture-performance.md)  
  
