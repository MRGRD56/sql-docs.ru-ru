---
description: Руководство по архитектуре обработки запросов
title: Руководство по архитектуре обработки запросов | Документация Майкрософт
ms.custom: ''
ms.date: 02/21/2020
ms.prod: sql
ms.prod_service: database-engine, sql-database, synapse-analytics, pdw
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- guide, query processing architecture
- query processing architecture guide
- row mode execution
- batch mode execution
ms.assetid: 44fadbee-b5fe-40c0-af8a-11a1eecf6cb5
author: pmasl
ms.author: pelopes
ms.openlocfilehash: 0d755b3e6d6cac04a2d6ba67b012e4b42c1aab3c
ms.sourcegitcommit: 0310fdb22916df013eef86fee44e660dbf39ad21
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2021
ms.locfileid: "104755524"
---
# <a name="query-processing-architecture-guide"></a>Руководство по архитектуре обработки запросов
[!INCLUDE [SQL Server Azure SQL Database](../includes/applies-to-version/sql-asdb.md)]

Компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] обрабатывает запросы к различным архитектурам хранения данных, таким как локальные таблицы, секционированные таблицы и таблицы, распределенные по нескольким серверам. В следующих разделах описано, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] обрабатывает запросы и оптимизирует повторное использование запросов с помощью кэширования плана выполнения.

## <a name="execution-modes"></a>Режимы выполнения
[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] может обрабатывать инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] в двух разных режимах:
- выполнение в построчном режиме;
- выполнение в пакетном режиме.

### <a name="row-mode-execution"></a>выполнение в построчном режиме;
*Построчный режим выполнения* — это метод обработки запросов, применяемый с традиционными таблицами RDMBS, при котором данные сохраняются в строковом формате. При выполнении запроса к данным в таблицах, хранящих строки, операторы дерева выполнения и дочерние операторы считывают каждую требуемую строку по всем столбцам, указанным в схеме таблицы. Из каждой считанной строки [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] затем извлекает столбцы, необходимые для результирующего набора, как указано в инструкции SELECT, предикате JOIN или предикате фильтра.

> [!NOTE]
> Построчный режим выполнения очень эффективен в сценариях OLTP, но может быть не так эффективен при обращении к большим объемам данных, например при работе с хранилищем данных.

### <a name="batch-mode-execution"></a>выполнение в пакетном режиме.  
*Пакетный режим выполнения* — это метод обработки запросов, при котором обрабатываются сразу несколько строк (поэтому он и называется пакетным). Каждый столбец из пакета сохраняется как вектор в отдельной области памяти. Таким образом, обработка в пакетном режиме основана на векторах. Кроме того, при обработке в пакетном режиме применяются алгоритмы, оптимизированные для многоядерных ЦП и увеличенной пропускной способности памяти, что характерно для современного оборудования.      

Выполнение в пакетном режиме тесно интегрировано и оптимизировано для взаимодействия с форматом хранения columnstore. Обработка в пакетном режиме применяется к сжатым данным, когда это возможно, и исключает необходимость применения [оператора обмена](../relational-databases/showplan-logical-and-physical-operators-reference.md#exchange), используемого в построчном режиме выполнения. Это позволяет повысить уровень параллелизма и производительность.    

Когда запрос выполняется в пакетном режиме и получает доступ к данным в индексах columnstore, операторы дерева выполнения и дочерние операторы считывают сразу несколько строк по сегментам столбцов. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] считывает только столбцы, которые требуются в результатах, как указано в инструкции SELECT, предикате JOIN или предикате фильтра.    
Дополнительные сведения об индексах columnstore см. в статье [Архитектура индексов columnstore](../relational-databases/sql-server-index-design-guide.md#columnstore_index).  

> [!NOTE]
> Пакетный режим выполнения очень эффективен в сценариях хранилищ данных, в которых считываются и вычисляются большие объемы данных.

## <a name="sql-statement-processing"></a>Обработка инструкций SQL
Обработка одиночной инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] — наиболее распространенный способ, с помощью которого [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]. Шаги, используемые для обработки одиночной инструкции `SELECT` , которая обращается только к таблицам локальной базы (а не к представлениям и не к удаленным таблицам), иллюстрируют основной процесс.

### <a name="logical-operator-precedence"></a>Приоритет логических операторов
При использовании в инструкции нескольких логических операторов первым вычисляется `NOT`, затем `AND` и, наконец, `OR`. Арифметические и побитовые операторы выполняются до логических. Дополнительные сведения см. в разделе [Приоритет операторов](../t-sql/language-elements/operator-precedence-transact-sql.md).

В приведенном ниже примере условие цвета относится к модели продукта 21, но не к модели продукта 20, так как оператора `AND` имеет приоритет над оператором `OR`.

```sql
SELECT ProductID, ProductModelID
FROM Production.Product
WHERE ProductModelID = 20 OR ProductModelID = 21
  AND Color = 'Red';
GO
```

Можно изменить смысл запроса, добавляя скобки, чтобы добиться вычисления `OR` сначала. В приведенном ниже запросе будут найдены модели 20 и 21 красного цвета.

```sql
SELECT ProductID, ProductModelID
FROM Production.Product
WHERE (ProductModelID = 20 OR ProductModelID = 21)
  AND Color = 'Red';
GO
```

С помощью скобок, даже если они не требуются, можно улучшить читаемость запросов и уменьшить вероятность совершения незаметной ошибки из-за приоритета операторов. Использование скобок практически не влияет на производительность. Следующий пример более понятен, чем исходный, хотя синтаксически они равноправны.

```sql
SELECT ProductID, ProductModelID
FROM Production.Product
WHERE ProductModelID = 20 OR (ProductModelID = 21
  AND Color = 'Red');
GO
```

### <a name="optimizing-select-statements"></a>Оптимизация инструкций SELECT
Инструкция `SELECT` является непроцедурной. Она не определяет точные шаги, которые сервер базы данных должен предпринять для получения запрошенных данных. Это означает, что сервер базы данных должен проанализировать инструкцию для определения самого эффективного способа извлечения запрошенных данных. Это упоминается как оптимизация инструкции `SELECT` . Компонент, который выполняет эти действия, называется оптимизатором запросов. Входные данные оптимизатора запросов включают сам запрос, схему базы данных (определения таблиц и индексов) и статистику базы данных. Выходные данные оптимизатора запросов — это план выполнения запроса, который иногда называется планом запроса или выполнения. Содержимое плана выполнения описывается более подробно далее в этом разделе.

Входные и выходные данные оптимизатора запросов при оптимизации одиночной инструкции `SELECT` показаны на следующей схеме.

![query_processor_io](../relational-databases/media/query-processor-io.gif)

Инструкция `SELECT` определяет только следующее.  
* Формат результирующего набора. Он указан, главным образом, в списке выбора. Однако другие предложения, например `ORDER BY` и `GROUP BY` , также затрагивают конечную форму результирующего набора.
* Таблицы, которые содержат исходные данные. Они указываются в предложении `FROM` .
* Логическую связь между таблицами для инструкции `SELECT` . Это определяется в спецификациях соединения, которые могут появляться в предложении `WHERE` или в предложении `ON` , следующем за предложением `FROM`.
* Условия, которым строки в исходных таблицах должны соответствовать для выбора их инструкцией `SELECT` . Они указываются в предложениях `WHERE` и `HAVING` .

План выполнения запроса представляет собой определение следующего. 

- **Последовательности, в которой происходит обращение к исходным таблицам.** Как правило, существует много последовательностей, в которых сервер базы данных может обращаться к базовым таблицам для построения результирующего набора. Например, если инструкция `SELECT` ссылается на три таблицы, сервер базы данных сначала может обратиться к `TableA`, использовать данные из `TableA` для извлечения соответствующих строк из `TableB`, а затем использовать данные из `TableB` для извлечения данных из `TableC`. Другие последовательности, в которых сервер базы данных может обращаться к таблицам:  
  `TableC`, `TableB`, `TableA`или  
  `TableB`, `TableA`, `TableC`или  
  `TableB`, `TableC`, `TableA`или  
  `TableC`, `TableA`, `TableB`  

- **Методы, используемые для извлечения данных из каждой таблицы.**  
  Есть различные методы для обращения к данным в каждой таблице. Если необходимы только несколько строк с определенными ключевыми значениями, то сервер базы данных может использовать индекс. Если необходимы все строки в таблице, то сервер базы данных может пропустить индексы и выполнить просмотр таблицы. Если необходимы все строки в таблице, но есть индекс, ключевые столбцы которого находятся в `ORDER BY`, то просмотр индекса вместо просмотра таблицы позволит избежать отдельный сортировки результирующего набора. Если таблица является очень маленькой, то просмотры таблицы могут быть самым эффективным методом для практически всех обращений к таблице.
  
- **Методы, используемые для вычислений, а также фильтрации, статистической обработки и сортировки данных из каждой таблицы.**  
  По мере доступа к данным из таблиц можно разными способами выполнять вычисления над данными (например, вычисления скалярных значений), а также статистическую обработку и сортировку данных, как определено в тексте запроса (например, при использовании предложения `GROUP BY` или `ORDER BY`) и их фильтрацию (например, при использовании предложения `WHERE` или `HAVING`).

Процесс выбора одного плана выполнения из множества потенциально возможных планов называется оптимизацией. Оптимизатор запросов является одним из самых важных компонентов [!INCLUDE[ssde_md](../includes/ssde_md.md)]. Хотя для анализа запроса и выбора плана оптимизатору запросов требуются некоторые накладные расходы, эти накладные расходы обычно многократно окупаются, когда оптимизатор запроса выбирает эффективный план выполнения. Например, двум строительным компаниям могут быть предоставлены идентичные проекты дома. Если одна компания потратит сначала несколько дней на планирование того, как она будет строить дом, а другая компания начнет строить без планирования, то компания, которая потратит время на планирование проекта, вероятно, закончит первой.

Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] основан на оценке стоимости. Каждому возможному плану выполнения соответствует некоторая стоимость, определенная в терминах объема использованных вычислительных ресурсов. Оптимизатор запросов должен проанализировать возможные планы и выбрать один файл с самой низкой предполагаемой стоимостью. Для некоторых сложных инструкций `SELECT` есть тысячи возможных планов выполнения. В этих случаях оптимизатор запросов не анализирует все возможные комбинации. Вместо этого он использует сложные алгоритмы поиска плана выполнения, имеющего стоимость, близкую к минимальной возможной стоимости.

Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не выбирает план выполнения только на основе самой низкой стоимости ресурсов. Он выбирает такой план, который возвращает результаты пользователю при разумной стоимости ресурсов и делает это быстрее по сравнению с другими планами. Например, параллельная обработка запроса обычно использует больше ресурсов, чем его последовательная обработка, но завершает выполнение запроса быстрее. Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] будет использовать план параллельного выполнения для возврата результатов, если это не окажет неблагоприятного влияния на загрузку сервера.

Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] полагается на статистику распределения при оценке затрат на ресурсы для различных методов извлечения сведений из таблицы или индекса. Статистика распределения хранится для столбцов и индексов и содержит сведения о плотности <sup>1</sup> базовых данных. Она указывает избирательность значений в определенном индексе или столбце. Например, в таблице, представляющей автомобили, много автомобилей имеют одного производителя, но каждый автомобиль имеет уникальный идентификационный номер транспортного средства (VIN). Индекс по VIN является более избирательным, чем индекс по производителям, так как VIN с меньшей плотностью, чем производитель. Если статистика индекса не является текущей, оптимизатор запросов, возможно, не сделает лучший выбор для текущего состояния таблицы. Дополнительные сведения о плотности см. в разделе [Статистика](../relational-databases/statistics/statistics.md#density). 

<sup>1</sup> Плотность определяет распределение уникальных значений в данных или среднее количество повторяющихся значений для данного столбца. По мере повышения плотности избирательность значения повышается.

Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] очень важен, так как позволяет серверу базы данных динамически изменять конфигурацию в ответ на меняющиеся условия в базе данных без участия программиста или администратора базы данных. Это дает возможность программистам сосредоточиться на описании конечного результата запроса. Они могут положиться на то, что каждый раз при выполнении инструкции оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] будет создавать эффективный план выполнения с учетом состояния базы данных.

> [!NOTE]
> В [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] есть три способа отображения планов выполнения:        
> -  ***[Предполагаемый план выполнения](../relational-databases/performance/display-the-estimated-execution-plan.md)***  — это скомпилированный план, созданный оптимизатором запросов.        
> -  ***[Действительный план выполнения](../relational-databases/performance/display-an-actual-execution-plan.md)***  — это скомпилированный план с контекстом выполнения. Сюда входят сведения времени выполнения, доступные после завершения выполнения, такие как предупреждения времени выполнения, а также в более новых версиях [!INCLUDE[ssde_md](../includes/ssde_md.md)] время, затраченное на выполнение, и время ЦП.        
> -  ***[Статистика активных запросов](../relational-databases/performance/live-query-statistics.md)***  — это скомпилированный план с контекстом выполнения. Сюда входят сведения о времени выполнения, которые обновляются каждую секунду. Эти сведения включают в себя, например, фактическое количество строк, передаваемых через операторы.       

### <a name="processing-a-select-statement"></a>Обработка инструкции SELECT
Основные шаги, используемые [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] для обработки одиночной инструкции SELECT, включают следующее: 

1. Средство анализа просматривает инструкцию `SELECT` и разбивает ее на логические единицы, такие как ключевые слова, выражения, операторы и идентификаторы.
2. Строится дерево запроса, иногда называемое деревом последовательности, с описанием логических шагов, необходимых для преобразования исходных данных в формат, требуемый результирующему набору.
3. Оптимизатор запросов анализирует различные способы, с помощью которых можно обратиться к исходным таблицам. Затем он выбирает ряд шагов, которые возвращают результаты быстрее всего и используют меньше ресурсов. Дерево запроса обновляется для записи этого точного ряда шагов. Конечную, оптимизированную версию дерева запроса называют планом выполнения.
4. Реляционный механизм начинает реализовывать план выполнения. В ходе обработки шагов, требующих данных из базовых таблиц, реляционный механизм запрашивает у подсистемы хранилища передачу данных из набора строк, указанных реляционным механизмом.
5. Реляционный механизм преобразует данные, возвращенные подсистемой хранилища, в заданный для результирующего набора формат и возвращает результирующий набор клиенту.

### <a name="constant-folding-and-expression-evaluation"></a><a name="ConstantFolding"></a> Свертывание констант и вычисление выражений 
[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] предварительно вычисляет некоторые постоянные выражения для улучшения производительности запросов. Это называет сверткой констант. Константа — это литерал языка [!INCLUDE[tsql](../includes/tsql-md.md)], такой как `3`, `'ABC'`, `'2005-12-31'`, `1.0e3` или `0x12345678`.

#### <a name="foldable-expressions"></a>Свертываемые выражения
[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует свертку констант со следующими типами выражений.
- Арифметические выражения, такие как 1+1, 5/3*2, которые содержат только константы.
- Логические выражения, такие как 1=1, 1>2 и 3>4, которые содержат только константы.
- Встроенные функции, которые считаются сворачиваемыми [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], включая `CAST` и `CONVERT`. Обычно внутренняя функция является свертываемой, если это функция только своих входных данных, а не контекстуальных данных, таких как параметры SET, настройки языка, параметры базы данных, ключи шифрования. Недетерминированные функции не являются свертываемыми. Детерминированные встроенные функции являются свертываемыми за некоторыми исключениями.
- Детерминированные методы определяемых пользователем типов данных CLR и детерминированные скалярные определяемые пользователем функции CLR (начиная с [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]). Дополнительные сведения см. в разделе [Свертка констант для определяемых пользователем функций и методов среды CLR](/previous-versions/sql/2014/database-engine/behavior-changes-to-database-engine-features-in-sql-server-2014#constant-folding-for-clr-user-defined-functions-and-methods).

> [!NOTE] 
> Исключение делается для типов больших объектов. Если в процессе свертки для выходных данных используется тип больших объектов (text, ntext, image, nvarchar(max), varchar(max), varbinary(max) или XML), то [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не свертывает такое выражение.

#### <a name="nonfoldable-expressions"></a>Несворачиваемые выражения
Все остальные типы выражения являются несвертываемыми. В частности, несвертываемыми являются следующие типы выражений.
- Неконстантные выражения, такие как выражение, результат которого зависит от значения столбца.
- Выражения, результат которых зависит от локальной переменной или параметра, такие как @x.
- Недетерминированные функции.
- Определяемые пользователем функции [!INCLUDE[tsql](../includes/tsql-md.md)]<sup>1</sup>.
- Выражения, результат которых зависит от языковых настроек.
- Выражения, результат которых зависит от параметров SET.
- Выражения, результат которых зависит от параметров конфигурации сервера.

<sup>1</sup> До [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] детерминированные скалярные определяемые пользователем функции CLR и методы определяемых пользователем типов данных CLR не были свертываемыми. 

#### <a name="examples-of-foldable-and-nonfoldable-constant-expressions"></a>Примеры свертываемых и несвертываемых постоянных выражений
Обратите внимание на следующий запрос:

```sql
SELECT *
FROM Sales.SalesOrderHeader AS s 
INNER JOIN Sales.SalesOrderDetail AS d 
ON s.SalesOrderID = d.SalesOrderID
WHERE TotalDue > 117.00 + 1000.00;
```

Если для параметра базы данных `PARAMETERIZATION` не установлено значение `FORCED` для этого запроса, выражение `117.00 + 1000.00` вычисляется и заменяется его результатом (`1117.00`) перед компиляцией запроса. Такая свертка констант имеет следующие преимущества.
- Нет необходимости вычислять выражение несколько раз во время выполнения.
- Значение выражения после его вычисления используется оптимизатором запросов для оценки размера результирующего набора части запроса `TotalDue > 117.00 + 1000.00`.

С другой стороны, если `dbo.f` является скалярной, определяемой пользователем функцией, выражение `dbo.f(100)` не свертывается, так как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не свертывает выражения, которые включают определяемые пользователем функции, даже если они детерминированы. Дополнительные сведения о параметризации см. в разделе [Принудительная параметризация](#ForcedParam) далее в этой статье.

#### <a name="expression-evaluation"></a><a name="ExpressionEval"></a>Вычисление выражений 
В дополнение некоторые выражения, которые не свертываются, но аргументы которых известны во время компиляции, где аргументы являются параметрами или постоянными, вычисляются механизмом оценки размера (количества элементов) набора результатов, который является частью оптимизатора во время оптимизации.

Во время компиляции вычисляются следующие встроенные функции и специальные операторы (если их входные данные известны): `UPPER`, `LOWER`, `RTRIM`, `DATEPART( YY only )`, `GETDATE`, `CAST` и `CONVERT`. Следующие операторы также вычисляются во время компиляции, если все входные данные известны:
- Арифметические операторы: +, –, \*, / и unary -
- Логические операторы: `AND`, `OR` и `NOT`
- Операторы сравнения: <, >, <=, >=, <>, `LIKE`, `IS NULL` и `IS NOT NULL`

Остальные функции или операторы не вычисляются оптимизатором запросов во время оценки кратности.

#### <a name="examples-of-compile-time-expression-evaluation"></a>Примеры вычисления выражений во время компиляции
Рассмотрим следующую хранимую процедуру:

```sql
USE AdventureWorks2014;
GO
CREATE PROCEDURE MyProc( @d datetime )
AS
SELECT COUNT(*)
FROM Sales.SalesOrderHeader
WHERE OrderDate > @d+1;
```

Во время оптимизации инструкции `SELECT` в процедуре оптимизатор запросов пытается вычислить ожидаемую кратность результирующего набора для условия `OrderDate > @d+1`. Выражение `@d+1` не свертывается, так как `@d` является параметром. Однако во время оптимизации значение этого параметра известно. Это дает возможность оптимизатору запросов точно оценить размер результирующего набора, что поможет выбрать наилучший план запроса.

Теперь рассмотрим пример, похожий на предыдущий, за исключением того, что локальная переменная `@d2` заменена в запросе выражением `@d+1` и это выражение вычисляется в инструкции SET вместо вычисления в запросе.

```sql 
USE AdventureWorks2014;
GO
CREATE PROCEDURE MyProc2( @d datetime )
AS
BEGIN
  DECLARE @d2 datetime
  SET @d2 = @d+1
  SELECT COUNT(*)
  FROM Sales.SalesOrderHeader
  WHERE OrderDate > @d2
END;
```

Когда инструкция `SELECT` в *MyProc2* оптимизируется в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], значение переменной `@d2` неизвестно. Поэтому в оптимизаторе запросов используется оценка по умолчанию для избирательности значений `OrderDate > @d2` (в данном случае 30 %).

### <a name="processing-other-statements"></a>Обработка других инструкций
Основные шаги, описанные для обработки инструкции `SELECT`, применимы к другим инструкциям [!INCLUDE[tsql](../includes/tsql-md.md)], таким как `INSERT`, `UPDATE` и `DELETE`. Инструкции`UPDATE` и `DELETE` предназначены для набора строк, которые будут изменены или удалены. Идентификация этих строк выполняется так же, как и идентификация исходных строк, определяющих результирующий набор инструкции `SELECT` . Обе инструкции (`UPDATE` и `INSERT`) могут содержать встроенные инструкции `SELECT`, предоставляющие значения данных, которые будут обновлены или вставлены.

Даже инструкции языка описания данных (DDL), такие как `CREATE PROCEDURE` или `ALTER TABLE`, в конечном счете приводятся к ряду реляционных операций с таблицами системного каталога, а иногда (например, `ALTER TABLE ADD COLUMN`) с таблицами данных.

### <a name="worktables"></a>Рабочие таблицы
Чтобы выполнить логическую операцию, указанную в инструкции [!INCLUDE[tsql](../includes/tsql-md.md)], реляционному модулю может потребоваться создать рабочую таблицу. Рабочие таблицы — это внутренние таблицы, предназначенные для хранения промежуточных результатов. Они создаются для некоторых запросов `GROUP BY`, `ORDER BY`или `UNION` . Например, если предложение `ORDER BY` ссылается на столбцы, не включенные в индексы, реляционному модулю может потребоваться создать рабочую таблицу, чтобы отсортировать результирующий набор в необходимом порядке. Рабочие таблицы также иногда применяются для временного хранения результатов выполнения части плана запроса. Рабочие таблицы строятся в базе данных tempdb и после того, как они больше не нужны, автоматически удаляются.

### <a name="view-resolution"></a>Разрешение представлений
Обработчик запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] обращается с индексированными и неиндексированными представлениями по-разному: 

* Строки индексированного представления хранятся в базе данных в том же формате, что и таблица. Если оптимизатор запросов решает использовать индексированное представление в плане запроса, оно обрабатывается так же, как базовая таблица.
* В случае неиндексированного представления хранится только его определение, но не строки. Оптимизатор запросов интегрирует логику из определения представления в план выполнения, который создается для инструкции [!INCLUDE[tsql](../includes/tsql-md.md)], ссылающейся на неиндексированное представление. 

Решение об использовании индексированного представления принимается оптимизатором запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] на основе тех же принципов, что и решение об использовании индекса таблицы. Если данные индексированного представления охватывают всю инструкцию [!INCLUDE[tsql](../includes/tsql-md.md)] или ее часть, и оптимизатор запросов определит, что использовать индекс представления выгодно с точки зрения стоимости, он выберет индекс независимо от того, имеется ли в запросе ссылка на представление по имени.

Если инструкция [!INCLUDE[tsql](../includes/tsql-md.md)] ссылается на неиндексированное представление, средство синтаксического анализа и оптимизатор запросов анализируют исходный код инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] и представления, разрешая их в один план выполнения. Отдельных планов для инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] и представления нет.

Рассмотрим следующее представление:

```sql
USE AdventureWorks2014;
GO
CREATE VIEW EmployeeName AS
SELECT h.BusinessEntityID, p.LastName, p.FirstName
FROM HumanResources.Employee AS h 
JOIN Person.Person AS p
  ON h.BusinessEntityID = p.BusinessEntityID;
GO
```

Обе следующих инструкции [!INCLUDE[tsql](../includes/tsql-md.md)], основанных на данном представлении, выполняют одни и те же операции над базовой таблицей, формируя одинаковый результат:

```sql
/* SELECT referencing the EmployeeName view. */
SELECT LastName AS EmployeeLastName, SalesOrderID, OrderDate
FROM AdventureWorks2014.Sales.SalesOrderHeader AS soh
JOIN AdventureWorks2014.dbo.EmployeeName AS EmpN
  ON (soh.SalesPersonID = EmpN.BusinessEntityID)
WHERE OrderDate > '20020531';

/* SELECT referencing the Person and Employee tables directly. */
SELECT LastName AS EmployeeLastName, SalesOrderID, OrderDate
FROM AdventureWorks2014.HumanResources.Employee AS e 
JOIN AdventureWorks2014.Sales.SalesOrderHeader AS soh
  ON soh.SalesPersonID = e.BusinessEntityID
JOIN AdventureWorks2014.Person.Person AS p
  ON e.BusinessEntityID =p.BusinessEntityID
WHERE OrderDate > '20020531';
```

Функция Showplan [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Management Studio показывает, что реляционное ядро создает один и тот же план выполнения для обеих инструкций `SELECT`.

### <a name="using-hints-with-views"></a>Использование указаний с представлениями
Указания, связываемые с представлениями в запросах, могут конфликтовать с другими указаниями, которые обнаруживаются при расширении представления для доступа к его базовым таблицам. Когда это происходит, запрос возвращает ошибку. Взгляните, например, на следующее представление, в определение которого входит табличное указание:

```sql
USE AdventureWorks2014;
GO
CREATE VIEW Person.AddrState WITH SCHEMABINDING AS
SELECT a.AddressID, a.AddressLine1, 
    s.StateProvinceCode, s.CountryRegionCode
FROM Person.Address a WITH (NOLOCK), Person.StateProvince s
WHERE a.StateProvinceID = s.StateProvinceID;
```

Предположим, что вводится следующий запрос:

```sql
SELECT AddressID, AddressLine1, StateProvinceCode, CountryRegionCode
FROM Person.AddrState WITH (SERIALIZABLE)
WHERE StateProvinceCode = 'WA';
```

Он завершится ошибкой, так как указание `SERIALIZABLE` , примененное в запросе к представлению `Person.AddrState` , при расширении представления распространится как на таблицу `Person.Address` , так и на таблицу `Person.StateProvince` . Однако при расширении представления будет также обнаружено указание `NOLOCK` , связанное с таблицей `Person.Address`. Из-за конфликта указаний `SERIALIZABLE` и `NOLOCK` результирующий запрос окажется неправильным. 

Табличные указания `PAGLOCK`, `NOLOCK`, `ROWLOCK`, `TABLOCK`и `TABLOCKX` , а также `HOLDLOCK`, `NOLOCK`, `READCOMMITTED`, `REPEATABLEREAD`и `SERIALIZABLE` конфликтуют друг с другом.

Указания могут распространяться через уровни вложенных представлений. Предположим, что в запросе указание `HOLDLOCK` применяется к представлению `v1`. При расширении представления `v1` выясняется, что представление `v2` является частью его определения. Определение`v2`включает в себя связанное с одной из его базовых таблиц указание `NOLOCK` . Однако эта таблица также наследует представленное в запросе указание `HOLDLOCK` , примененное к представлению `v1`. Из-за конфликта указаний `NOLOCK` и `HOLDLOCK` запрос завершится ошибкой.

Если в запросе, включающем представление, используется указание `FORCE ORDER` , порядок соединения таблиц в представлении определяется по позиции представления в конструкции упорядочения. Например, приведенный ниже запрос выбирает данные из трех таблиц и представления:

```sql
SELECT * FROM Table1, Table2, View1, Table3
WHERE Table1.Col1 = Table2.Col1 
    AND Table2.Col1 = View1.Col1
    AND View1.Col2 = Table3.Col2;
OPTION (FORCE ORDER);
```

Допустим, что представление `View1` определено следующим образом:

```sql
CREATE VIEW View1 AS
SELECT Colx, Coly FROM TableA, TableB
WHERE TableA.ColZ = TableB.Colz;
```

В этом случае порядок соединения таблиц в плане запроса будет таким: `Table1`, `Table2`, `TableA`, `TableB`, `Table3`.

### <a name="resolving-indexes-on-views"></a>Разрешение индексов для представлений

Как и при работе с любым индексом, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует индексированное представление в плане запроса только в том случае, если оптимизатор запросов определит, что это целесообразно.

Индексированные представления можно создавать в любом выпуске [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. В некоторых версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] оптимизатор запросов автоматически учитывает индексированные представления. В некоторых версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] для использования индексированного представления необходимо применить табличное указание `NOEXPAND`. Пояснения см. в документации для каждой версии.

Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует индексированные представления при соблюдении следующих условий. 

* Для следующих параметров сеанса установлено значение `ON`: 
  * `ANSI_NULLS`
  * `ANSI_PADDING`
  * `ANSI_WARNINGS`
  * `ARITHABORT`
  * `CONCAT_NULL_YIELDS_NULL`
  * `QUOTED_IDENTIFIER` 
* Для параметра сеанса `NUMERIC_ROUNDABORT` установлено значение OFF.
* Оптимизатор запросов находит соответствие между столбцами индексированного представления и элементами запроса, например: 
  * предикатами условия поиска в предложении WHERE;
  * операциями соединения;
  * Агрегатные функции
  * Предложения`GROUP BY`
  * ссылками на таблицы.
* Предполагаемые затраты на использование индекса имеют меньшую стоимость по сравнению с любыми механизмами доступа, имеющимися в распоряжении оптимизатора запросов. 
* Каждая таблица, на которую ссылается запрос (либо прямо, либо при расширении представления для доступа к его базовым таблицам), соответствующая табличной ссылке в индексированном представлении, должна иметь в запросе точно такой же набор указаний.

> [!NOTE] 
> Указания `READCOMMITTED` и `READCOMMITTEDLOCK` в данном контексте всегда рассматриваются как разные, независимо от уровня изоляции текущей транзакции.
 
За исключением требований к параметрам `SET` и табличным указаниям, это те же самые правила, по которым оптимизатор запросов выясняет, подходит ли индекс таблицы для выполнения запроса. Для использования индексированного представления в запросе больше ничего указывать не нужно.

Запрос не обязательно должен ссылаться в предложении `FROM` на индексированное представление, чтобы оптимизатор запросов его использовал. Если запрос ссылается на столбцы в базовой таблице, которые также присутствуют в индексированном представлении, и оптимизатор запросов определяет, что индексированное представление будет иметь самую низкую стоимость механизма доступа, он применит индексированное представление точно так же, как он применяет индекс базовой таблицы, если на него отсутствуют прямые ссылки в запросе. Оптимизатор запросов может применить представление и в том случае, если оно содержит столбцы, на которые не ссылается запрос, если это представление обеспечивает самую низкую стоимость доступа к одному или нескольким столбцам, указанным в запросе.

Индексированное представление, указанное в предложении `FROM` , оптимизатор запросов рассматривает как стандартное представление. В начале процесса оптимизации оптимизатор запросов расширяет определение представления в запрос, а затем выполняет в индексированном представлении поиск соответствий. В окончательном плане выполнения, выбранном оптимизатором запросов, может быть использовано индексированное представление, или план может материализовать необходимые данные за счет доступа к базовым таблицам этого представления. Оптимизатор запросов выбирает вариант с наименьшей стоимостью.

#### <a name="using-hints-with-indexed-views"></a>Использование указаний с индексированными представлениями
Чтобы индексы представления не использовались в запросе, можно задать указание запроса `EXPAND VIEWS` или табличное указание `NOEXPAND` , чтобы принудительно задействовать индекс для индексированного представления запроса в предложении `FROM` . Однако оптимизатору запросов следует разрешить динамически определять лучший метод доступа для каждого из запросов. Ограничьте применение указаний `EXPAND` и `NOEXPAND` только теми случаями, когда очевидно, что они значительно повысят производительность.

Параметр `EXPAND VIEWS` указывает, что оптимизатор запросов не будет использовать индексы представления для всего запроса. 

Если для представления задано указание `NOEXPAND` , оптимизатор запросов предполагает использование всех индексов, определенных в представлении. `NOEXPAND` может иметь необязательное предложение `INDEX()` , которое активирует принудительное применение указанных индексов в оптимизаторе запросов. `NOEXPAND` может быть указано только для индексированного представления и не применяется для представлений без индексов.

Если в запросе, содержащем представление, не заданы ни `NOEXPAND` , ни `EXPAND VIEWS` , это представление расширяется для доступа к базовым таблицам. Если запрос представления содержит какие-либо табличные указания, они распространяются на базовые таблицы. (Этот процесс подробно описан в разделе "Разрешение представлений".) Пока указания, имеющиеся в базовых таблицах представления, идентичны, для запроса может устанавливаться соответствие с индексированным представлением. Чаще всего эти указания соответствуют друг другу, поскольку они наследуются непосредственно из представления. Однако если запрос ссылается на таблицы, а не на представления, и применяемые к этим таблицам указания неидентичны, то для такого запроса соответствие с индексированным представлением устанавливаться не может. Если указания `INDEX`, `PAGLOCK`, `ROWLOCK`, `TABLOCKX`, `UPDLOCK`или `XLOCK` применяются к таблицам, на которые запрос ссылается после расширения представления, для этого запроса не может быть установлено соответствие с индексированным представлением.

Если табличное указание вида `INDEX (index_val[ ,...n] )` ссылается на представление в запросе, а указание `NOEXPAND` не задано, указание индекса не обрабатывается. Для указания конкретного индекса используйте `NOEXPAND`. 

Обычно, если оптимизатор запросов устанавливает соответствие индексированного представления запросу, все заданные в таблицах или представлениях запроса указания применяются непосредственно к индексированному представлению. Если оптимизатор запросов решил не использовать индексированное представление, все указания распространяются непосредственно на таблицы, на которые ссылается это представление. Дополнительные сведения см. в разделе "Разрешение представлений". Это не относится к указаниям соединения. Они применяются только в той исходной позиции запроса, где они указаны. Указания в соединении оптимизатором запросов при установке соответствия запроса индексированным представлениям не рассматриваются. Если план запроса использует индексированное представление, которое совпадает с частью запроса, содержащей указание соединения, последний в данном плане не используется.

В определении индексированных представлений указания не допускаются. В режимах совместимости 80 и выше [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] пропускает указания при работе с определениями индексированных представлений и при выполнении содержащих их запросов. В режиме совместимости 80 использование указаний в определениях индексированных представлений не вызывает ошибок синтаксиса — они просто пропускаются.

### <a name="resolving-distributed-partitioned-views"></a>Разрешение распределенных секционированных представлений
Обработчик запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] оптимизирует производительность распределенных секционированных представлений. При оптимизации распределенных секционированных представлений важно минимизировать количество данных, передаваемых между серверами.

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] интеллектуальные динамические планы, которые позволяют эффективно использовать распределенные запросы для доступа к данным в таблицах удаленных серверов. 

* Обработчик запросов сначала использует OLE DB для получения определений ограничений CHECK для каждой таблицы-элемента. Это позволяет ему определить распределение ключевых значений между таблицами серверов.
* Обработчик запросов сравнивает диапазоны ключей, заданные в инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]`WHERE`, со схемой распределения строк между таблицами-элементами. Затем обработчик запросов строит план выполнения, который использует распределенные запросы для получения только тех удаленных строк, которые требуются для завершения инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]. Кроме того, план выполнения строится таким образом, чтобы обращение к удаленным данным или метаданным выполнялось только в тот момент, когда они требуются.

Например, рассмотрим систему, в которой пользовательская таблица разделена на три секции на серверах Server1 (`CustomerID` от 1 до 3299999), Server2 (`CustomerID` от 3300000 до 6599999) и Server3 (`CustomerID` от 6600000 до 9999999).

Допустим, план выполнения, созданный для этого запроса, выполняется на сервере Server1:

```sql
SELECT *
FROM CompanyData.dbo.Customers
WHERE CustomerID BETWEEN 3200000 AND 3400000;
```

План выполнения этого запроса извлекает строки со значениями ключей `CustomerID` от 3200000 до 3299999 из локальной таблицы-элемента и вызывает распределенный запрос для получения строк со значениями ключей от 3300000 до 3400000 с сервера Server2.

Обработчик запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] также может встраивать динамическую логику в планы выполнения запросов для инструкций [!INCLUDE[tsql](../includes/tsql-md.md)] в тех случаях, когда значения ключей во время создания плана неизвестны. Рассмотрим следующую хранимую процедуру:

```sql
CREATE PROCEDURE GetCustomer @CustomerIDParameter INT
AS
SELECT *
FROM CompanyData.dbo.Customers
WHERE CustomerID = @CustomerIDParameter;
```

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не может предсказать, какое значение ключа будет выдавать параметр `@CustomerIDParameter` каждый раз при выполнении процедуры. Поскольку значение ключа предсказать нельзя, обработчик запросов не может заранее определить, к какой таблице потребуется доступ. В этом случае [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] встраивает в план выполнения условную логику, называемую динамическими фильтрами, для управления доступом к удаленным таблицам на основе значения входного параметра. Если предположить, что хранимая процедура `GetCustomer` выполнена на сервере Server1, логику плана выполнения можно представить следующим образом:

```sql
IF @CustomerIDParameter BETWEEN 1 and 3299999
   Retrieve row from local table CustomerData.dbo.Customer_33
ELSE IF @CustomerIDParameter BETWEEN 3300000 and 6599999
   Retrieve row from linked table Server2.CustomerData.dbo.Customer_66
ELSE IF @CustomerIDParameter BETWEEN 6600000 and 9999999
   Retrieve row from linked table Server3.CustomerData.dbo.Customer_99
```

Иногда [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] строит динамические планы даже для непараметризованных запросов. Оптимизатор запросов может параметризовать запрос так, чтобы план выполнения можно было использовать повторно. Если оптимизатор запросов параметризует запрос, ссылающийся на секционированное представление, он не будет знать, находятся ли нужные строки в заданной базовой таблице. В дальнейшем ему придется использовать динамические фильтры в планах выполнения.

## <a name="stored-procedure-and-trigger-execution"></a>Выполнение хранимых процедур и триггеров
[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] хранит только исходный код хранимых процедур и триггеров. При выполнении хранимой процедуры или триггера в первый раз исходный код компилируется в план выполнения. Если очередной вызов хранимой процедуры или триггера будет инициирован до устаревания плана выполнения, реляционный механизм обнаружит существующий план и использует его повторно. Если план устарел и был удален из памяти, будет создан новый план. Этот процесс похож на то, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] обрабатывает все инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]. Основное преимущество хранимых процедур и триггеров [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] над пакетами динамического кода [!INCLUDE[tsql](../includes/tsql-md.md)] в плане быстродействия заключается в том, что их инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] всегда остаются постоянными. Благодаря этому реляционный механизм может с легкостью сопоставлять их с любыми существующими планами выполнения. Это облегчает повторное использование планов хранимых процедур и триггеров.

Планы выполнения хранимых процедур и триггеров обрабатываются отдельно от плана выполнения пакета, вызвавшего хранимую процедуру или приведшего к срабатыванию триггера. Это способствует повторному использованию планов выполнения хранимых процедур и триггеров.

## <a name="execution-plan-caching-and-reuse"></a>Кэширование и повторное использование плана выполнения
В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] есть пул памяти, предназначенный для хранения планов выполнения и буферов данных. Процентное соотношение размера пула, выделенного для планов выполнения и буферов данных, динамически изменяется в зависимости от состояния системы. Часть пула памяти, используемого для хранения планов выполнения, называется кэшем планов.

В кэше планов есть два хранилища для всех скомпилированных планов:
-  хранилище кэша **Object Plans** (OBJCP), которое используется для планов, связанных с сохраняемыми объектами (хранимыми процедурами, функциями и триггерами);
-  хранилище кэша **SQL Plans** (SQLCP), которое используется для планов, связанных с автоматически параметризуемыми, динамическими или подготовленными запросами.

Следующий запрос предоставляет сведения об использовании памяти для этих двух хранилищ:

```sql
SELECT * FROM sys.dm_os_memory_clerks
WHERE name LIKE '%plans%';
```

> [!NOTE]
> В кэше планов есть еще два хранилища, которые не используются для хранения планов.     
> -  Хранилище кэша **Bound Trees** (PHDR) предназначено для структур данных, используемых во время компиляции плана для представлений, ограничений и значений по умолчанию. Эти структуры называются связанными деревьями или деревьями алгебризатора.      
> -  Хранилище кэша **Extended Stored Procedures** (XPROC) предназначено для предварительно определенных системных процедур, таких как `sp_executeSql` или `xp_cmdshell`, которые определены с помощью библиотеки DLL, а не инструкций Transact-SQL. Кэшированная структура содержит только имя функции и имя библиотеки DLL, в которой реализована процедура.      

В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] планы выполнения состоят из следующих основных компонентов. 

- **Скомпилированный план** (или план запроса)     
  План запроса, создаваемый в результате компиляции, является, как правило, реентерабельной структурой данных только для чтения, которую могут использовать любое число пользователей. В нем хранятся следующие сведения:
  -  физические операторы, которые реализуют действия, описанные логическими операторами; 
  -  порядок этих операторов, определяющий очередность доступа к данным, их фильтрации и агрегирования; 
  -  предполагаемое количество строк, передаваемых через операторы. 
  
     > [!NOTE]
     > В более новых версиях [!INCLUDE[ssde_md](../includes/ssde_md.md)] также сохраняются сведения об объектах статистики, которые использовались для [оценки кратности](../relational-databases/performance/cardinality-estimation-sql-server.md).
     
  -  Какие вспомогательные объекты необходимо создать, например [рабочие таблицы](#worktables) или рабочие файлы в tempdb. 
  Контекст пользователя или сведения времени выполнения в плане запроса не хранятся. В памяти содержится одна или две копии плана запроса (но не более): одна — для всех последовательных выполнений, а другая — для всех параллельных выполнений. Одна параллельная копия обслуживает все параллельные выполнения независимо от степени параллелизма.   
  
- **Контекст выполнения**     
  Для каждого пользователя, который в настоящий момент выполняет запрос, имеется структура данных, которая содержит данные, относящиеся к данному выполнению, например значения параметров. Эта структура данных называется контекстом выполнения. Структуры данных контекста выполнения являются повторно используемыми, в отличие от их содержимого. Если другой пользователь выполняет тот же запрос, структуры данных инициализируются повторно контекстом нового пользователя. 

  ![execution_context](../relational-databases/media/execution-context.gif)

При выполнении любой инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] [!INCLUDE[ssde_md](../includes/ssde_md.md)] сначала просматривает кэш планов, проверяя, нет ли в нем плана выполнения для такой же инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]. Инструкция [!INCLUDE[tsql](../includes/tsql-md.md)] считается существующей, если она точно соответствует выполнявшейся ранее инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] с кэшированным планом, символ за символом. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] повторно использует все найденные планы, что позволяет избежать перекомпиляции инструкций [!INCLUDE[tsql](../includes/tsql-md.md)]. Если не найдено ни одного существующего плана, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] формирует для этого запроса новый план.

> [!NOTE]
> Планы выполнения для некоторых инструкций [!INCLUDE[tsql](../includes/tsql-md.md)] не сохраняются в кэше планов. К ним относятся инструкции массовых операций, работающие в rowstore, а также инструкции, содержащие строковые литералы размером более 8 КБ. Такие планы существуют только во время выполнения запроса.

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] реализует эффективный алгоритм поиска существующих планов выполнения для любой инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]. В большинстве систем ресурсы, затрачиваемые на поиск готового плана, всегда меньше ресурсов, затрачиваемых на повторную компиляцию каждой инструкции [!INCLUDE[tsql](../includes/tsql-md.md)].

Алгоритмы поиска соответствия инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] существующему неиспользуемому плану выполнения в кэше планов требуют, чтобы все ссылки на объекты были полными. Например, предположим, что `Person` является схемой по умолчанию для пользователя, выполняющего инструкции `SELECT` ниже. Хотя в этом примере для выполнения не обязательно, чтобы таблица `Person` была полной, это означает, что вторая инструкция не соответствует существующему плану, однако третья инструкция соответствует:

```sql
USE AdventureWorks2014;
GO
SELECT * FROM Person;
GO
SELECT * FROM Person.Person;
GO
SELECT * FROM Person.Person;
GO
```

Изменение любого из следующих параметров SET для данного выполнения повлияет на возможность повторного использования планов, так как [!INCLUDE[ssde_md](../includes/ssde_md.md)] выполняет [свертку констант](#ConstantFolding) и эти параметры влияют на результаты таких выражений:

:::row:::
    :::column:::
        ANSI_NULL_DFLT_OFF
    :::column-end:::
    :::column:::
        FORCEPLAN
    :::column-end:::
    :::column:::
        ARITHABORT
    :::column-end:::
:::row-end:::
:::row:::
    :::column:::
        DATEFIRST
    :::column-end:::
    :::column:::
        ANSI_PADDING
    :::column-end:::
    :::column:::
        NUMERIC_ROUNDABORT
    :::column-end:::
:::row-end:::
:::row:::
    :::column:::
        ANSI_NULL_DFLT_ON
    :::column-end:::
    :::column:::
        LANGUAGE
    :::column-end:::
    :::column:::
        CONCAT_NULL_YIELDS_NULL
    :::column-end:::
:::row-end:::
:::row:::
    :::column:::
        DATEFORMAT
    :::column-end:::
    :::column:::
        ANSI_WARNINGS
    :::column-end:::
    :::column:::
        QUOTED_IDENTIFIER
    :::column-end:::
:::row-end:::
:::row:::
    :::column:::
        ANSI_NULLS
    :::column-end:::
    :::column:::
        NO_BROWSETABLE
    :::column-end:::
    :::column:::
        ANSI_DEFAULTS
    :::column-end:::
:::row-end:::

### <a name="caching-multiple-plans-for-the-same-query"></a>Кэширование нескольких планов для одного запроса 
Запросы и планы выполнения являются уникально идентифицируемыми в [!INCLUDE[ssde_md](../includes/ssde_md.md)], как отпечатки пальцев.
-  **Хэш-значение плана запроса** — это двоичное хэш-значение, вычисленное для плана выполнения данного запроса и используемое для уникальной идентификации планов выполнения со сходной логикой. 
-  **Хэш-значение для запроса** — это двоичное хэш-значение, вычисленное для текста [!INCLUDE[tsql](../includes/tsql-md.md)] запроса и используемое для уникальной идентификации запросов. 

Скомпилированный план можно получить из кэша планов с помощью **дескриптора плана**, который представляет собой временный идентификатор, сохраняющий свое значение, только пока план остается в кэше. Дескриптор плана — это хэш-значение, которое выводится из скомпилированного плана целого пакета. Дескриптор скомпилированного плана остается неизменным даже в том случае, если одна или несколько инструкций в пакете перекомпилируются.

> [!NOTE]
> Если план был скомпилирован для пакета, а не для одной инструкции, то планы для отдельных инструкций в пакете можно получить с помощью дескриптора плана и смещений инструкций.     
> Динамическое административное представление `sys.dm_exec_requests` содержит для каждой записи столбцы `statement_start_offset` и `statement_end_offset`, которые ссылаются на выполняемую в настоящее время инструкцию выполняющегося пакета или сохраняемого объекта. Дополнительные сведения см. в статье [sys.dm_exec_requests (Transact-SQL)](../relational-databases/system-dynamic-management-views/sys-dm-exec-requests-transact-sql.md).       
> Динамическое административное представление `sys.dm_exec_query_stats` также содержит для каждой записи столбцы, ссылающиеся на положение инструкции внутри пакета или сохраняемого объекта. Дополнительные сведения см. в статье [sys.dm_exec_query_stats (Transact-SQL)](../relational-databases/system-dynamic-management-views/sys-dm-exec-query-stats-transact-sql.md).     

Фактический текст [!INCLUDE[tsql](../includes/tsql-md.md)] пакета хранится в отдельной области памяти, которая не связана с кэшем планов и называется кэшем **SQL Manager** (SQLMGR). Текст [!INCLUDE[tsql](../includes/tsql-md.md)] для скомпилированного плана можно получить из кэша SQL Manager с помощью **дескриптора SQL**, который представляет собой временный идентификатор, сохраняющий свое значение, только пока в кэше планов остается по крайней мере один ссылающийся на него план. Дескриптор SQL — это хэш-значение, которое выводится из всего текста пакета и гарантированно является уникальным для каждого пакета.

> [!NOTE]
> Как и скомпилированный план, текст [!INCLUDE[tsql](../includes/tsql-md.md)] хранится для каждого пакета, включая комментарии. Дескриптор SQL содержит хэш-код MD5 всего текста пакета и гарантированно является уникальным для каждого пакета.

Следующий запрос предоставляет сведения об использовании памяти для кэша SQL Manager:

```sql
SELECT * FROM sys.dm_os_memory_objects
WHERE type = 'MEMOBJ_SQLMGR';
```

Между дескриптором SQL и дескрипторами планов существует связь "один ко многим". Такая ситуация возникает, когда ключ кэша для скомпилированных планов отличается. Это может происходить из-за изменения параметров SET между двумя выполнениями одного пакета.

Рассмотрим следующую хранимую процедуру:

```sql
USE WideWorldImporters;
GO
CREATE PROCEDURE usp_SalesByCustomer @CID int
AS
SELECT * FROM Sales.Customers
WHERE CustomerID = @CID
GO

SET ANSI_DEFAULTS ON
GO

EXEC usp_SalesByCustomer 10
GO
```

Проверьте содержимое кэша планов, используя следующий запрос:

```sql
SELECT cp.memory_object_address, cp.objtype, refcounts, usecounts, 
    qs.query_plan_hash, qs.query_hash,
    qs.plan_handle, qs.sql_handle
FROM sys.dm_exec_cached_plans AS cp
CROSS APPLY sys.dm_exec_sql_text (cp.plan_handle)
CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle)
INNER JOIN sys.dm_exec_query_stats AS qs ON qs.plan_handle = cp.plan_handle
WHERE text LIKE '%usp_SalesByCustomer%'
GO
```

[!INCLUDE[ssResult](../includes/ssresult-md.md)]

```
memory_object_address    objtype   refcounts   usecounts   query_plan_hash    query_hash
---------------------    -------   ---------   ---------   ------------------ ------------------ 
0x000001CC6C534060        Proc      2           1           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D  

plan_handle                                                                               
------------------------------------------------------------------------------------------
0x0500130095555D02D022F111CD01000001000000000000000000000000000000000000000000000000000000

sql_handle
------------------------------------------------------------------------------------------
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
```

Теперь выполните хранимую процедуру с другим параметром, не внося иных изменений в контекст выполнения:

```sql
EXEC usp_SalesByCustomer 8
GO
```

Еще раз проверьте содержимое кэша планов. [!INCLUDE[ssResult](../includes/ssresult-md.md)]

```
memory_object_address    objtype   refcounts   usecounts   query_plan_hash    query_hash
---------------------    -------   ---------   ---------   ------------------ ------------------ 
0x000001CC6C534060        Proc      2           2           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D  

plan_handle                                                                               
------------------------------------------------------------------------------------------
0x0500130095555D02D022F111CD01000001000000000000000000000000000000000000000000000000000000

sql_handle
------------------------------------------------------------------------------------------
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
```

Обратите внимание, что значение `usecounts` увеличилось до 2. Это означает, что один и тот же кэшированный план использовался повторно "как есть", так как использовались повторно структуры данных контекста выполнения. Теперь измените параметр `SET ANSI_DEFAULTS` и выполните хранимую процедуру с использованием того же параметра.

```sql
SET ANSI_DEFAULTS OFF
GO

EXEC usp_SalesByCustomer 8
GO
```

Еще раз проверьте содержимое кэша планов. [!INCLUDE[ssResult](../includes/ssresult-md.md)]

```
memory_object_address    objtype   refcounts   usecounts   query_plan_hash    query_hash
---------------------    -------   ---------   ---------   ------------------ ------------------ 
0x000001CD01DEC060        Proc      2           1           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D  
0x000001CC6C534060        Proc      2           2           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D

plan_handle                                                                               
------------------------------------------------------------------------------------------
0x0500130095555D02B031F111CD01000001000000000000000000000000000000000000000000000000000000
0x0500130095555D02D022F111CD01000001000000000000000000000000000000000000000000000000000000

sql_handle
------------------------------------------------------------------------------------------
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
```

Обратите внимание, что в выходных данных динамического административного представления `sys.dm_exec_cached_plans` теперь есть две записи.
-  Первая запись в столбце `usecounts` содержит значение `1`, что соответствует одному выполнению плана с параметром `SET ANSI_DEFAULTS OFF`.
-  Вторая запись в столбце `usecounts` содержит значение `2`, что соответствует двум выполнениям плана с параметром `SET ANSI_DEFAULTS ON`.    
-  Разные значения `memory_object_address` указывают на разные записи планов выполнения в кэше планов. Однако значение `sql_handle` одинаково для обеих записей, так как они ссылаются на один и тот же пакет. 
   -  Выполнение с параметром `ANSI_DEFAULTS` со значением OFF имеет новый дескриптор `plan_handle` и может использоваться повторно для вызовов с тем же набором параметров SET. Новый дескриптор плана необходим по той причине, что контекст выполнения был инициализирован повторно из-за измененных параметров SET. Но это не вызывает перекомпиляцию: обе записи ссылаются на одни и те же план и запрос, о чем свидетельствуют одинаковые значения `query_plan_hash` и `query_hash`.

Таким образом, в кэше есть две записи планов, соответствующие одному пакету. Это подчеркивает важность того, что параметры SET, влияющие на кэш планов, должны быть одинаковы, когда одни и те же запросы выполняются повторно. Это позволяет оптимизировать повторное использование плана и свести необходимый размер кэша планов к минимуму. 

> [!TIP]
> Распространенной проблемой является то, что разные клиенты могут иметь разные значения по умолчанию для параметров SET. Например, при установлении подключения через [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] параметр `QUOTED_IDENTIFIER` автоматически принимает значение ON, но SQLCMD присваивает параметру `QUOTED_IDENTIFIER` значение OFF. Выполнение одних и тех же запросов из этих двух клиентов приведет к созданию нескольких планов (как описано в примере выше).

### <a name="removing-execution-plans-from-the-plan-cache"></a>Удаление планов выполнения из кэша планов
Планы выполнения остаются в кэше планов до тех пор, пока для их хранения остается достаточно памяти. При нехватке памяти [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] определяет планы выполнения, которые нужно удалить из кэша процедур, на основе стоимости планов. Для принятия основанного на стоимости решения компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] увеличивает и уменьшает переменную текущей стоимости для каждого плана выполнения, руководствуясь следующими факторами.

Когда пользовательский процесс добавляет в кэш план выполнения, он устанавливает текущую стоимость равной стоимости компиляции исходного запроса. Для нерегламентированных планов выполнения пользовательский процесс устанавливает значение текущей стоимости равным нулю. После этого каждый раз, когда пользовательский процесс ссылается на план выполнения, он сбрасывает текущую стоимость, делая ее равной исходной стоимости компиляции. Для нерегламентированных планов выполнения пользовательский процесс повышает значение текущей стоимости. Для всех планов максимальное значение текущей стоимости равно исходной стоимости компиляции.

При нехватке памяти [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] удаляет планы выполнения из кэша планов. Чтобы определить, какие планы следует удалить, компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] многократно проверяет состояние каждого плана выполнения и удаляет те из них, для которых текущая стоимость равна нулю. План выполнения с нулевой текущей стоимостью не удаляется автоматически при возникновении нехватки памяти; он удаляется только после проверки компонентом [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)], если его текущая стоимость равна нулю. При проверке плана выполнения компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] приближает текущую стоимость к нулю, уменьшая ее в случае, если запрос в данный момент не использует план.

Компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] многократно проверяет планы выполнения, пока не удалит достаточно, чтобы удовлетворить требования к памяти. При нехватке памяти стоимость плана выполнения может увеличиться и уменьшиться несколько раз. При восстановлении достаточного объема памяти [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] прекращает уменьшать текущую стоимость неиспользуемых планов выполнения, и все планы выполнения остаются в кэше планов, даже если их стоимость равна нулю.

[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] использует монитор ресурсов и пользовательские рабочие потоки для освобождения памяти, занимаемой кэшем планов, при нехватке памяти. Монитор ресурсов и пользовательские рабочие потоки могут проверять параллельно выполняющиеся планы, что позволяет уменьшать текущую стоимость для каждого неиспользуемого плана выполнения. Монитор ресурсов удаляет планы выполнения из кэша планов при глобальной нехватке памяти. Он освобождает память для принудительного выполнения политик для системной памяти, памяти процессов, памяти пула ресурсов и максимального размера всех кэшей. 

Максимальный размер всех кэшей является функцией от размера буферного пула и не может превышать максимальный объем памяти сервера. Дополнительные сведения о настройке максимального объема памяти сервера см. в описании параметра `max server memory` в статье об `sp_configure`. 

Пользовательские рабочие потоки удаляют планы выполнения из кэша планов при нехватке памяти в одиночном кэше. Они обеспечивают выполнение политик для максимального размера кэша и максимума записей одиночного кэша. 

В следующих примерах показано, какие планы выполнения удаляются из кэша планов.

* План выполнения часто используется, поэтому его стоимость никогда не принимает значение ноль. Этот план остается в кэше планов и не удаляется, пока имеется достаточный объем памяти, а его текущая стоимость не равна нулю.
* Нерегламентированный план выполнения вставляется и не используется до возникновения нехватки памяти. Так как нерегламентированные планы выполнения инициализируются с текущей стоимостью, равной нулю, то [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] при проверке планов выполнения обнаруживает план выполнения с нулевой стоимостью и удаляет его из кэша планов. Нерегламентированный план выполнения с нулевой текущей стоимостью остается в кэше планов при наличии достаточного объема памяти.

Чтобы вручную удалить отдельный план выполнения или все планы, используйте команду [DBCC FREEPROCCACHE](../t-sql/database-console-commands/dbcc-freeproccache-transact-sql.md). [DBCC FREESYSTEMCACHE](../t-sql/database-console-commands/dbcc-freesystemcache-transact-sql.md) также можно использовать для очистки любого кэша, включая кэш планов. Начиная с версии [!INCLUDE[sssql15-md](../includes/sssql16-md.md)], для очистки кэша процедур (планов) для базы данных в области действия служит инструкция `ALTER DATABASE SCOPED CONFIGURATION CLEAR PROCEDURE_CACHE`. Изменение некоторых параметров конфигурации с помощью [sp_configure](system-stored-procedures/sp-configure-transact-sql.md) и [reconfigure](../t-sql/language-elements/reconfigure-transact-sql.md) также приведет к удалению планов из кэша планов. Список этих параметров конфигурации можно найти в разделе "Примечания" статьи [DBCC FREEPROCCACHE](../t-sql/database-console-commands/dbcc-freeproccache-transact-sql.md#remarks). Такое изменение конфигурации приведет к записи в журнал ошибок следующего информационного сообщения:

> `SQL Server has encountered %d occurrence(s) of cachestore flush for the '%s' cachestore (part of plan cache) due to some database maintenance or reconfigure operations.`

### <a name="recompiling-execution-plans"></a>Перекомпиляция планов выполнения

Некоторые изменения в базе данных могут привести к тому, что план выполнения станет неэффективным или неправильным в зависимости от нового состояния базы данных. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] обнаруживает изменения, которые делают план выполнения недействительным, и помечает такой план как недействительный. При следующем выполнении данного запроса план должен быть перекомпилирован. План может стать недействительным в следующих случаях. 

* Изменены таблица или представления, на которые ссылается запрос (`ALTER TABLE` или `ALTER VIEW`).
* Изменена одна процедура, которая удалит все планы для этой процедуры из кэша (`ALTER PROCEDURE`).
* Изменены индексы, используемые планом выполнения.
* Обновлена статистика, которая используется планом выполнения и сформирована либо явным образом по `UPDATE STATISTICS`, либо автоматически.
* Удалены индексы, используемые планом выполнения.
* Явный вызов `sp_recompile`.
* Частое изменение ключей (инструкциями `INSERT` или `DELETE` от пользователей, изменяющих таблицу, на которую ссылается запрос).
* Для таблиц с триггерами: значительный рост числа строк в таблицах inserted и deleted.
* Выполнение хранимой процедуры с помощью параметра `WITH RECOMPILE` .

Большинство перекомпиляций необходимы либо для обеспечения правильности работы инструкции, либо для потенциального ускорения работы плана выполнения.

В версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] до 2005, независимо от того, какая из инструкций пакета вызвала перекомпиляцию, перекомпилируется весь пакет, переданный через хранимую процедуру, триггер, нерегламентированный пакет или подготовленную инструкцию. В [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] и более поздних версиях перекомпилируется только та инструкция пакета, которая вызвала перекомпиляцию. Кроме этого, в [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] и более поздних версиях есть дополнительные типы перекомпиляции, что вызвано расширением набора возможностей.

Перекомпиляция на уровне инструкции дает выигрыш в производительности, поскольку в большинстве случаев перекомпиляция небольшого числа инструкций и связанных с этим потерь занимает меньше ресурсов в плане использования времени ЦП и затрат на блокировки. Этих потерь, таким образом, удается избежать для остальных инструкций пакета, которые в перекомпиляции не нуждаются.

Расширенное событие `sql_statement_recompile` (xEvent) выводит сведения о перекомпиляции на уровне инструкций. Это событие xEvent возникает при перекомпиляции инструкций уровня для любого типа пакета. К таким пакетам относятся хранимые процедуры, триггеры, нерегламентированные пакеты и запросы. Пакеты можно отправлять с помощью различных интерфейсов, включая sp_executesql, динамический язык SQL, методы Prepare и Execute.
Столбец `recompile_cause` для событий xEvent `sql_statement_recompile` содержит код причины перекомпиляции в виде целого числа. В следующей таблице приведены возможные причины.

:::row:::
    :::column:::
        Изменение схемы
    :::column-end:::
    :::column:::
        Изменение статистики
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        Отложенная компиляция
    :::column-end:::
    :::column:::
        Изменение параметра SET
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        Изменение временной таблицы
    :::column-end:::
    :::column:::
        Изменение удаленного набора строк
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        Изменение разрешения `FOR BROWSE`
    :::column-end:::
    :::column:::
        Изменение среды уведомлений о запросах
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        Изменение секционированного представления
    :::column-end:::
    :::column:::
        Изменение параметров курсора
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        `OPTION (RECOMPILE)` запрошено
    :::column-end:::
    :::column:::
        Очистка параметризованного плана
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        Изменение версии базы данных, влияющее на план
    :::column-end:::
    :::column:::
        Изменение политики форсирования плана для хранилища запросов
    :::column-end:::
:::row-end:::  
:::row:::
    :::column:::
        Сбой форсирования плана для хранилища запросов
    :::column-end:::
    :::column:::
        Отсутствие плана для хранилища запросов
    :::column-end:::
:::row-end:::

> [!NOTE]
> В выпусках [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], в которых xEvents недоступны, для тех же целей (отслеживание перекомпиляции уровня инструкций) можно использовать событие трассировки [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Profiler [SP:Recompile](../relational-databases/event-classes/sp-recompile-event-class.md).
> Событие трассировки `SQL:StmtRecompile` также сообщает о перекомпиляции уровня инструкций и может использоваться для отслеживания и отладки перекомпиляции. Событие `SP:Recompile` создается только для хранимых процедур и триггеров, а `SQL:StmtRecompile` — для хранимых процедур, триггеров, нерегламентированных пакетов, пакетов, которые выполняются с помощью `sp_executesql`, подготовленных запросов и динамического SQL.
> Столбец *EventSubClass* для событий `SP:Recompile` и `SQL:StmtRecompile` содержит код в виде целого числа, обозначающий причину перекомпиляции. Коды описаны [здесь](../relational-databases/event-classes/sql-stmtrecompile-event-class.md).

> [!NOTE]
> Если для параметра базы данных `AUTO_UPDATE_STATISTICS` установлено значение `ON`, то запросы перекомпилируются при условии, что они указывают на целевые таблицы или индексированные представления, для которых со времени последнего выполнения была изменена статистика или в значительной степени была изменена кратность. Это относится к стандартным пользовательским таблицам, временным таблицам, а также таблицам inserted и deleted, созданным триггерами DML. Если на производительность запроса оказывают влияние излишние перекомпиляции, измените значение этого параметра на `OFF`. Если для параметра базы данных `AUTO_UPDATE_STATISTICS` установлено значение `OFF`, перекомпиляция по причине изменения статистики или кратности не выполняется, за исключением вставляемых и удаляемых таблиц, созданных триггерами DML `INSTEAD OF`. Так как данные таблицы создаются в базе данных tempdb, перекомпиляция запросов, которые обращаются к этим таблицам, зависит от значения параметра `AUTO_UPDATE_STATISTICS` в базе данных tempdb. Обратите внимание, что в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] до версии 2005 запросы по-прежнему будут перекомпилироваться при изменении кратности в таблицах, вставляемых и удаляемых триггерами DML, даже если этот параметр имеет значение `OFF`.

### <a name="parameters-and-execution-plan-reuse"></a><a name="PlanReuse"></a> Параметры и повторное использование планов выполнения
Использование параметров, включая маркеры параметров в приложениях ADO, OLE DB и ODBC, может повысить уровень использования планов выполнения. 

> [!WARNING] 
> Использование параметров и маркеров параметров для хранения введенных конечными пользователями значений безопаснее, чем сцепление значений в строку, которая затем выполняется с помощью метода API доступа к данным, инструкции `EXECUTE` или хранимой процедуры `sp_executesql` .
 
Единственная разница между следующими двумя инструкциями `SELECT` — в значениях, сравниваемых в предложении `WHERE` :

```sql
SELECT * 
FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 1;
```

```sql
SELECT * 
FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 4;
```

Единственная разница между планами выполнения для этих запросов — в значении, хранимом для сравнения со столбцом `ProductSubcategoryID` . В то время как выявление факта формирования инструкциями одного и того же плана и повторного его использования является основной задачей [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не всегда может это обнаружить в сложных инструкциях [!INCLUDE[tsql](../includes/tsql-md.md)].

Отделение констант от инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] с помощью параметров помогает реляционному механизму распознавать дубликаты планов. Параметры можно использовать следующими способами. 

* В [!INCLUDE[tsql](../includes/tsql-md.md)] используется атрибут `sp_executesql`: 

   ```sql
   DECLARE @MyIntParm INT
   SET @MyIntParm = 1
   EXEC sp_executesql
     N'SELECT * 
     FROM AdventureWorks2014.Production.Product 
     WHERE ProductSubcategoryID = @Parm',
     N'@Parm INT',
     @MyIntParm
   ```

   Этот метод рекомендуется использовать для скриптов языка [!INCLUDE[tsql](../includes/tsql-md.md)], хранимых процедур и триггеров, динамически формирующих инструкции SQL. 

* В технологиях ADO, OLE DB и ODBC используются маркеры параметров. Маркеры параметров представляют собой знаки вопроса (?), заменяющие константу в инструкции SQL и привязываемые к программной переменной. Например, в приложении ODBC можно сделать следующее: 

   * использовать параметр `SQLBindParameter` для привязки целочисленной переменной к первому маркеру параметра в инструкции SQL;
   * поместить целочисленное значение в переменную;
   * выполнить инструкцию, указав маркер параметра (?): 

   ```
   SQLExecDirect(hstmt, 
     "SELECT * 
     FROM AdventureWorks2014.Production.Product 
     WHERE ProductSubcategoryID = ?",
     SQL_NTS);
   ```

   Если в приложениях используются маркеры параметров, то поставщик OLE DB для собственного клиента [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], включенные в состав [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], используют для отправки инструкций в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] процедуру `sp_executesql`. 

* Чтобы проектировать хранимые процедуры, использующие указанные разработчиком параметры.

Если структура приложения не предусматривает явного создания параметров, можно воспользоваться оптимизатором запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] для автоматической параметризации некоторых запросов с использованием установленного по умолчанию поведения простой параметризации. В качестве альтернативы можно настроить принудительный учет параметризации всех запросов к базе данных в оптимизаторе запросов, установив для параметра `PARAMETERIZATION` инструкции `ALTER DATABASE` значение `FORCED`.

При включенной принудительной параметризации может также иметь место и простая параметризация. Например, в соответствии с правилами принудительной параметризации следующий запрос не может быть параметризован.

```sql
SELECT * FROM Person.Address
WHERE AddressID = 1 + 2;
```

Однако он может быть параметризован согласно правилам простой параметризации. В случае неуспешной попытки принудительной параметризации впоследствии производятся попытки использования простой параметризации.

### <a name="simple-parameterization"></a><a name="SimpleParam"></a> Простая параметризация
В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использование параметров или маркеров параметров в инструкциях Transact-SQL позволяет реляционному ядру более эффективно применять существующие скомпилированные планы выполнения для новых инструкций [!INCLUDE[tsql](../includes/tsql-md.md)].

> [!WARNING] 
> Использование параметров и маркеров параметров для хранения введенных конечными пользователями значений безопаснее, чем сцепление значений в строку, которая затем выполняется с помощью метода API доступа к данным, инструкции `EXECUTE` или хранимой процедуры `sp_executesql` .

Если инструкция [!INCLUDE[tsql](../includes/tsql-md.md)] выполняется без параметров, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] неявно параметризует инструкцию, чтобы увеличить возможность ее противопоставления существующему плану выполнения. Данный процесс называется простой параметризацией. В версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] до 2005 этот процесс назывался автоматической параметризацией.

Рассмотрим следующую инструкцию.

```sql
SELECT * FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 1;
```

Значение 1 в конце инструкции может быть указано в виде параметра. Реляционный механизм строит план выполнения для данного пакета, как если бы параметр был указан на месте значения 1. При помощи этой простой параметризации [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] распознает, что следующие две инструкции формируют, по сути, одинаковый план выполнения, и повторно использует первый план для второй инструкции:

```sql
SELECT * FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 1;
```
```sql
SELECT * FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 4;
```

В процессе обработки сложных инструкций [!INCLUDE[tsql](../includes/tsql-md.md)] реляционный механизм может с трудом определять, какие выражения могут быть параметризованы. Чтобы увеличить возможность реляционного модуля находить соответствующие существующие неиспользованные планы выполнения для сложных инструкций [!INCLUDE[tsql](../includes/tsql-md.md)], необходимо явно указать параметры с помощью процедуры sp_executesql или маркеров параметров. 

> [!NOTE]
> При использовании арифметических операторов (+, -, \*, / или %) для явного или неявного преобразования постоянных значений типов данных int, smallint, tinyint или bigint в типы данных float, real, decimal или numeric [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] применяет специальные правила для определения типа и точности результатов выражения. Однако эти правила различаются в зависимости от того, параметризован запрос или нет. Таким образом, одинаковые выражения в запросах могут в некоторых случаях давать отличающиеся результаты.

При проведении простой параметризации [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] по умолчанию параметризует сравнительно небольшой класс запросов. Однако можно указать, чтобы все запросы в базе данных были параметризованы в соответствии с определенными ограничениями, настроив параметр `PARAMETERIZATION` команды `ALTER DATABASE` на `FORCED`. Уменьшая частоту компиляции запросов, эти действия улучшат производительность баз данных, которые испытывают большие объемы параллельных запросов.

Иначе можно указать параметризацию одного запроса и других, синтаксически равных, но отличающихся значениями параметра, запросов. 

### <a name="forced-parameterization"></a><a name="ForcedParam"></a> Принудительная параметризация
Можно переопределить простую параметризацию, используемую в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] по умолчанию, указав, что все инструкции `SELECT`, `INSERT`, `UPDATE` и `DELETE` в базе данных должны быть параметризованы (с учетом некоторых ограничений). Принудительная параметризация активируется путем установки для параметра `PARAMETERIZATION` значения `FORCED` в инструкции `ALTER DATABASE` . Принудительная параметризация может улучшить производительность некоторых баз данных, сократив частоту выполнения компиляции и перекомпиляции запросов. Базы данных, которым может пойти на пользу принудительная параметризация, — это, как правило, те, которым приходится выполнять большое количество параллельных запросов из источников наподобие приложений торговых точек.

Если параметру `PARAMETERIZATION` присвоено значение `FORCED`, любое литеральное значение, представленное в инструкции `SELECT`, `INSERT`, `UPDATE`или `DELETE` , заявленной в любой форме, преобразуется в аргумент в процессе компиляции запроса. Исключениями являются литералы, представленные в следующих конструкциях запроса. 

* Инструкции`INSERT...EXECUTE` .
* Инструкции в теле хранимых процедур, триггеров или определяемых пользователем функций. В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] планы запросов для этих подпрограмм уже используются повторно.
* Подготовленные инструкции, которые уже были параметризованы приложением на стороне клиента.
* Инструкции, содержащие вызовы метода XQuery, где метод представлен в контексте, в котором его аргументы обычно параметризуются, например в предложении `WHERE` . Если метод представлен в контексте, где его аргументы не параметризуются, остальная часть инструкции будет параметризована.
* Инструкции внутри курсора [!INCLUDE[tsql](../includes/tsql-md.md)]. (Инструкции`SELECT` внутри курсоров API-интерфейса параметризуются.)
* Устаревшие конструкции запроса.
* Любая инструкция, выполняемая в контексте `ANSI_PADDING` или `ANSI_NULLS` со значением `OFF`.
* Инструкции, содержащие более 2 097 литералов, пригодных для параметризации.
* Инструкции, ссылающиеся на переменные, такие как `WHERE T.col2 >= @bb`.
* Инструкции, содержащие указание запроса `RECOMPILE` .
* Инструкции, содержащие предложение `COMPUTE` .
* Инструкции, содержащие предложение `WHERE CURRENT OF` .

Кроме того, в запросах не параметризуются следующие предложения (следует иметь в виду, что не параметризуются только предложения; другие предложения внутри того же запроса могут оказаться пригодными для принудительной параметризации).

* Список <select_list> любой инструкции `SELECT`. Сюда входят списки `SELECT` во вложенных запросах и списки `SELECT` внутри инструкций `INSERT`.
* Инструкции `SELECT` во вложенных запросах, представленные внутри инструкции `IF` .
* Предложения запроса `TOP`, `TABLESAMPLE`, `HAVING`, `GROUP BY`, `ORDER BY`, `OUTPUT...INTO` или `FOR XML`.
* Аргументы, прямые или в качестве подвыражений, для `OPENROWSET`, `OPENQUERY`, `OPENDATASOURCE`, `OPENXML`или для любого оператора `FULLTEXT` .
* Аргументы pattern и escape_character предложения `LIKE` .
* Аргумент style предложения `CONVERT` .
* Целочисленные константы внутри предложения `IDENTITY` .
* Константы, указанные использованием синтаксиса расширения ODBC.
* Свертываемые константные выражения, являющиеся аргументами операторов `+`, `-`, `*`, `/` и `%`. При определении пригодности для принудительной параметризации [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] рассматривает выражение как свертываемое, если верно хотя бы одно из следующих условий.  
  * В выражении не представлены столбцы, переменные или вложенные запросы.  
  * Выражение содержит предложение `CASE` .  
* Аргументы для предложений указаний запросов. Сюда входит аргумент *number_of_rows* указания запроса `FAST`, аргумент *number_of_processors* указания запроса `MAXDOP` и аргумент *number* указания запроса `MAXRECURSION`.

Параметризация происходит на уровне отдельных инструкций [!INCLUDE[tsql](../includes/tsql-md.md)]. Иными словами, параметризуются отдельные инструкции в пакете. После компиляции параметризированный запрос выполняется в контексте пакета, в котором он был изначально заявлен. Если план выполнения для запроса кэширован, можно определить, был ли параметризован запрос, обратившись к столбцу sql в динамическом административном представлении sys.syscacheobjects. Если запрос параметризован, имена и типы данных аргументов располагаются перед текстом заявленного пакета в этом столбце, например (\@1 tinyint).

> [!NOTE]
> Имена аргументов произвольны. Пользователи или приложения не должны опираться на какой-либо конкретный порядок именования. Кроме того, в зависимости от версии [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и пакетов обновления могут меняться имена параметров, выбор литералов, подлежащих параметризации, и разбивка параметризованного текста.

#### <a name="data-types-of-parameters"></a>Типы данных аргументов
Когда [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] параметризует литералы, аргументы преобразовываются в следующие типы данных.

* Целочисленные литералы, размер которых в ином случае соответствовал бы типу данных int, параметризуются в int. Большие целочисленные литералы, являющиеся частью предикатов, которые включают в себя любой оператор сравнения (в том числе <, \<=, =, !=, >, >=, , !\<, !>, <>, `ALL`, `ANY`, `SOME`, `BETWEEN` и `IN`), параметризуются в numeric(38,0). Большие литералы, не являющиеся частью предикатов, которые включают в себя операторы сравнения, параметризуются в числовой тип с точностью достаточно большой, чтобы поддержать их размер, и с масштабом 0.
* Числовые литералы с фиксированной запятой, являющиеся частью предикатов, которые включают в себя операторы сравнения, параметризуются в числовой тип с точностью 38 и масштабом достаточно большим, чтобы поддержать их размер. Числовые литералы с фиксированной запятой, не являющиеся частью предикатов, которые включают в себя операторы сравнения, параметризуются в числовой тип с точностью и масштабом достаточно большими, чтобы поддержать их размер.
* Числовые литералы с плавающей запятой параметризуются в float(53).
* Строковые литералы не в формате Юникод параметризуются в varchar(8000), если размер литерала не превышает 8000 символов, и в varchar(max), если он больше 8000 символов.
* Строковые литералы в формате Юникод параметризуются в nvarchar(4000), если размер литерала не превышает 4000 символов Юникода, и в nvarchar(max), если он больше 4000 символов.
* Двоичные литералы параметризуются в varbinary(8000), если размер литерала не превышает 8000 байт. Если он больше 8000 байт, он преобразуется в varbinary(max).
* Денежные литералы параметризуются в тип money.

#### <a name="guidelines-for-using-forced-parameterization"></a><a name="ForcedParamGuide"></a> Рекомендации по использованию принудительной параметризации
Устанавливая для параметра `PARAMETERIZATION` значение FORCED, примите во внимание следующие сведения.

* Принудительная параметризация, в сущности, преобразует литеральные константы в запросе в параметры при компиляции запроса. Следовательно, оптимизатор запросов может выбирать не самые оптимальные планы для запросов. В частности, уменьшается вероятность того, что оптимизатор запросов сопоставит запрос с индексированным представлением или индексом по вычисляемому столбцу. Он может также выбирать не самые оптимальные планы для запросов, ориентированных на секционированные таблицы или распределенные секционированные представления. Принудительная параметризация не должна использоваться в средах, в значительной степени опирающихся на индексированные представления и индексы по вычисляемым столбцам. Параметр `PARAMETERIZATION FORCED` должны использовать только опытные администраторы баз данных и лишь после того, как они определят, что такое использование не повредит производительности.
* Распределенные запросы, ссылающиеся на более чем одну базу данных, пригодны для принудительной параметризации, если для параметра `PARAMETERIZATION` задано значение `FORCED` в базе данных, в контексте которой выполняется запрос.
* Установка для параметра `PARAMETERIZATION` на значения `FORCED` производит очистку всех планов запросов из кэша планов в базе данных за исключением тех, которые компилируются, перекомпилируются или выполняются в настоящий момент. Планы для запросов, которые компилируются или выполняются в момент изменения настроек, параметризуются при следующем выполнении запроса.
* Настройка параметра `PARAMETERIZATION` выполняется в режиме в сети и не требует монопольных блокировок на уровне базы данных.
* Текущая настройка параметра `PARAMETERIZATION` сохраняется при повторном присоединении или восстановлении базы данных.

Можно перекрывать поведение принудительной параметризации, предписав выполнение попытки простой параметризации для отдельного запроса, а также всех остальных запросов с таким же синтаксисом, отличающихся только значениями аргументов. Справедливо и обратное: можно потребовать выполнения попытки принудительной параметризации для отдельного набора синтаксически эквивалентных запросов, даже если принудительная параметризация в базе данных отключена. В этих целях используются[структуры планов](../relational-databases/performance/plan-guides.md) .

> [!NOTE]
> Если для параметра `PARAMETERIZATION` задано значение `FORCED`, то отчеты об ошибках могут отличаться от отчетов в случае, когда для параметра `PARAMETERIZATION` задано значение `SIMPLE`: при принудительной параметризации число сообщений об ошибках в некоторых случаях больше, чем при простой параметризации, а номера строк, в которых возникают ошибки, могут указываться неверно.

### <a name="preparing-sql-statements"></a>Подготовка инструкций SQL
В реляционном механизме [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] введена полная поддержка подготовки инструкций [!INCLUDE[tsql](../includes/tsql-md.md)] перед их выполнением. Если приложению требуется выполнить инструкцию [!INCLUDE[tsql](../includes/tsql-md.md)] несколько раз, то оно может использовать API базы данных следующим образом. 

* Однократная подготовка инструкции. Инструкция [!INCLUDE[tsql](../includes/tsql-md.md)] компилируется в план выполнения.
* Ранее скомпилированный план выполнения выполняется каждый раз при необходимости использовать эту инструкцию. Это избавляет от необходимости повторно компилировать инструкцию [!INCLUDE[tsql](../includes/tsql-md.md)] при каждом последующем выполнении.   
  Подготовка и выполнение инструкций контролируется функциями и методами API. Они не имеют отношения к языку [!INCLUDE[tsql](../includes/tsql-md.md)]. Модель подготовки и выполнения инструкций [!INCLUDE[tsql](../includes/tsql-md.md)] поддерживается поставщиком OLE DB для собственного клиента [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], а также драйвером ODBC для собственного клиента [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. При запросе на подготовку поставщик или драйвер отправляет в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] инструкцию с запросом на подготовку инструкции. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] компилирует план выполнения и возвращает его дескриптор поставщику или драйверу. При запросе на выполнение поставщик или драйвер отправляет на сервер запрос на выполнение плана, связанного с этим дескриптором. 

В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] подготовленные инструкции нельзя применять для создания временных объектов. Подготовленные инструкции не могут содержать ссылки на системные хранимые процедуры, создающие временные объекты, такие как временные таблицы. Эти процедуры следует выполнять напрямую.

Злоупотребление моделью подготовки и выполнения может отрицательно сказаться на производительности. Если инструкция выполняется только один раз, то для прямого выполнения потребуется только один цикл приема-передачи с сервером. Для подготовки и выполнения инструкции [!INCLUDE[tsql](../includes/tsql-md.md)], которая выполняется только один раз, потребуется два таких цикла: один для подготовки и один для выполнения.

Подготовка инструкции более эффективна, если используются маркеры параметров. Предположим, что приложение случайно запросило сведения о продукте из образца базы данных `AdventureWorks` . Эти сведения можно извлечь двумя способами. 

Приложение может выполнять отдельный запрос по каждому необходимому продукту:

```sql
SELECT * FROM AdventureWorks2014.Production.Product
WHERE ProductID = 63;
```

Второй способ заключается в следующем. 

1. Приложение подготавливает инструкцию, содержащую маркер параметра (?):  
   ```sql
   SELECT * FROM AdventureWorks2014.Production.Product  
   WHERE ProductID = ?;
   ```
2. Затем оно связывает переменную программы с этим маркером.
3. Каждый раз, когда требуются сведения о продукте, приложение присваивает связанной переменной ключевое значение и выполняет инструкцию.

Второй способ более эффективен, если инструкция выполняется более трех раз.

В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] модель подготовки и выполнения не дает существенного прироста производительности по сравнению с непосредственным выполнением из-за того, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] повторно использует планы выполнения. В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] предусмотрены эффективные алгоритмы для сопоставления текущих инструкций [!INCLUDE[tsql](../includes/tsql-md.md)] и планов выполнения, созданных для предыдущих случаев выполнения той же инструкции [!INCLUDE[tsql](../includes/tsql-md.md)]. Если приложение несколько раз выполняет инструкцию [!INCLUDE[tsql](../includes/tsql-md.md)] с маркерами параметров, то со второго выполнения [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] будет использовать готовый план выполнения (если этот план не будет удален из кэша планов). Впрочем, у модели подготовки и выполнения есть следующие достоинства: 

* поиск плана производится путем идентификации дескриптора, что эффективнее алгоритмов, которые применяются для сопоставления инструкции [!INCLUDE[tsql](../includes/tsql-md.md)] и существующих планов выполнения;
* приложение может управлять временем создания и повторного использования плана выполнения;
* Модель подготовки и выполнения можно переносить в другие базы данных, включая более ранние версии [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].

### <a name="parameter-sensitivity"></a><a name="ParamSniffing"></a> Учет параметров
Учет параметров (также называется сканированием параметров) — это процесс, посредством которого [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] сканирует текущие значения параметров во время компиляции или перекомпиляции и передает их оптимизатору запросов для создания более эффективных планов запросов.

Значения параметров сканируются во время компиляции или перекомпиляции для следующих типов пакетов:

-  Хранимые процедуры
-  Запросы, отправленные командой `sp_executesql` 
-  Подготовленные запросы

Дополнительные сведения об устранении неполадок с выявлением неверных параметров см. в разделе [Устранение неполадок при выполнении запросов с проблемами в плане выполнения запроса, зависящими от параметров](/azure/sql-database/sql-database-monitor-tune-overview).

> [!NOTE]
> Для запросов, в которых используется указание `RECOMPILE`, сканируются как значения параметров, так и текущие значения локальных переменных. Сканируемые значения (параметров и локальных переменных) — это значения, которые имеются в пакете, прямо перед выполнением указания `RECOMPILE`. В частности для параметров значения, которые поставляются вместе с вызовом пакета, не сканируются.

## <a name="parallel-query-processing"></a>Параллельная обработка запросов
[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] обеспечивает параллельную обработку запросов, оптимизирующую выполнение запросов и операции с индексами на компьютерах, где установлено несколько микропроцессоров (ЦП). Благодаря параллельной обработке запросов и параллельному выполнению операций с индексами с помощью нескольких рабочих потоков операционной системы [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет эти операции быстрее и эффективнее.

Во время оптимизации запроса [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] пытается обнаружить запросы и операции с индексами, которые можно ускорить за счет параллельного выполнения. Для таких запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вставляет в план выполнения операторы обмена, чтобы подготовить запрос к параллельной обработке. Операторы обмена служат для управления процессом, перераспределения данных и управления потоком. К ним относятся логические операторы `Distribute Streams`, `Repartition Streams`и `Gather Streams` (в качестве подтипов), один или несколько из которых появляются в выводе инструкции Showplan плана запроса для параллельного запроса. 

> [!IMPORTANT]
> Определенные конструкции блокируют для [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] возможность использования параллелизма для всего плана выполнения или его частей.

Конструкции, которые блокируют параллелизм, включают перечисленные ниже.
-   **Определяемые пользователем скалярные функции**        
    Дополнительные сведения об определяемых пользователем скалярных функциях см. в разделе [Создание определяемых пользователем функций](../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#Scalar). Начиная с [!INCLUDE[sql-server-2019](../includes/sssql19-md.md)][!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] включает возможность встраивать эти функции и разблокировать использование параллелизма во время обработки запросов. Дополнительные сведения о встраивании скалярных пользовательских функций см. в разделе [Интеллектуальная обработка запросов в базах данных SQL](../relational-databases/performance/intelligent-query-processing.md#scalar-udf-inlining).
    
-   **Remote Query**        
    Дополнительные сведения о Remote Query см. в разделе [Справочник по логическим и физическим операторам Showplan](../relational-databases/showplan-logical-and-physical-operators-reference.md).
    
-   **Динамические курсоры**        
    Дополнительные сведения о курсорах см. в описании [DECLARE CURSOR](../t-sql/language-elements/declare-cursor-transact-sql.md).
    
-   **Рекурсивные запросы**        
    Дополнительные сведения о рекурсии см. в разделах [Рекомендации по созданию и использованию рекурсивных обобщенных табличных выражений](../t-sql/queries/with-common-table-expression-transact-sql.md#guidelines-for-defining-and-using-recursive-common-table-expressions) и [Рекурсия в T-SQL](/previous-versions/sql/legacy/aa175801(v=sql.80)).

-   **Функции с табличным значением с несколькими инструкциями (MSTVF)**         
    Дополнительные сведения о функциях MSTVF см. в разделе [Создание определяемых пользователем функций (ядро СУБД)](../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#TVF).
    
-   **Ключевое слово TOP**        
    Дополнительные сведения см. в разделе [TOP (Transact-SQL)](../t-sql/queries/top-transact-sql.md).

План выполнения запроса может содержать атрибут **NonParallelPlanReason** в элементе **QueryPlan**. В атрибуте указывается, почему не использовался параллелизм.  Значения этого атрибута:

|Значение NonParallelPlanReason|Описание|
|----|----|
|MaxDOPSetToOne|Максимальной степени параллелизма задано значение 1.|
|EstimatedDOPIsOne|Ожидаемая степень параллелизма — 1.|
|NoParallelWithRemoteQuery|Удаленные запросы не поддерживают параллелизм.|
|NoParallelDynamicCursor|Динамические курсоры не поддерживают параллельные планы.|
|NoParallelFastForwardCursor|Курсоры перемотки вперед не поддерживают параллельные планы.|
|NoParallelCursorFetchByBookmark|Курсоры, получающие данные по закладкам, не поддерживают параллельные планы.|
|NoParallelCreateIndexInNonEnterpriseEdition|Все выпуски, кроме Enterprise, не поддерживают параллельное создание индексов.|
|NoParallelPlansInDesktopOrExpressEdition|Выпуски Desktop и Express не поддерживают параллельные планы.|
|NonParallelizableIntrinsicFunction|Запрос ссылается на встроенную функцию, которая не поддерживает параллелизм.|
|CLRUserDefinedFunctionRequiresDataAccess|Определяемая пользователем функции CLR, которая требует доступа к данным, не поддерживает параллелизм.|
|TSQLUserDefinedFunctionsNotParallelizable|Запрос ссылается на определяемую пользователем функцию T-SQL, которая не поддерживает параллелизм.|
|TableVariableTransactionsDoNotSupportParallelNestedTransaction|Транзакции табличных переменных не поддерживают параллельные вложенные транзакции.|
|DMLQueryReturnsOutputToClient|DML-запрос возвращает клиенту выходные данные без поддержки параллелизма.|
|MixedSerialAndParallelOnlineIndexBuildNotSupported|Неподдерживаемый набор последовательных и параллельных планов для одной сборки индекса в сети.|
|CouldNotGenerateValidParallelPlan|Сбой проверки параллельного плана, возврат к последовательному плану.|
|NoParallelForMemoryOptimizedTables|Таблицы выполняющейся в памяти OLTP, на которые добавлены ссылки, не поддерживают параллелизм.|
|NoParallelForDmlOnMemoryOptimizedTable|DML-запрос к таблице, выполняющейся в памяти OLTP, не поддерживает параллелизм.|
|NoParallelForNativelyCompiledModule|Модули, скомпилированные в собственном коде, на которые добавлены ссылки, не поддерживают параллелизм.|
|NoRangesResumableCreate|Сбой создания диапазона для возобновляемой операции создания.|

После вставки операторов обмена получается план параллельного выполнения запроса. План параллельного выполнения запроса может использовать несколько рабочих потоков. План последовательного выполнения, который используется для обработки непараллельных (серийных) запросов, использует только один рабочий поток. Фактическое количество рабочих потоков для параллельного выполнения запроса определяется при инициализации плана выполнения запроса и зависит от сложности и степени параллелизма плана. 

Степень параллелизма определяет максимальное количество используемых ЦП, а не количество используемых рабочих потоков. Ограничение этой степени задается для каждой [задачи](../relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql.md). Оно не задается для каждого [запроса](../relational-databases/system-dynamic-management-views/sys-dm-exec-requests-transact-sql.md). Это означает, что во время параллельного выполнения один запрос может порождать множество задач, назначаемых [планировщику](../relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql.md). Количество процессоров, превышающее значение MAXDOP, может одновременно использоваться в любой момент выполнения запроса, когда разные задачи выполняются параллельно. Дополнительные сведения см. в статье [Руководство по архитектуре потоков и задач](../relational-databases/thread-and-task-architecture-guide.md).

Оптимизатор запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не использует план параллельного выполнения для запроса, если выполняется любое из следующих условий.

* Затраты на последовательное выполнение запроса не настолько высоки, чтобы альтернативой ему считался план параллельного выполнения. 
* План последовательного выполнения признан более быстрым, чем любой другой возможный план параллельного выполнения данного запроса.
* Запрос содержит скалярные или реляционные операторы, параллельное выполнение которых невозможно. Определенные операторы могут привести к выполнению участка запроса или всего плана целиком в последовательном режиме.

### <a name="degree-of-parallelism"></a><a name="DOP"></a> Степень параллелизма
[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] автоматически обнаруживает высшую степень параллелизма для каждого экземпляра параллельного выполнения запроса или индекс операции языка DDL. Это осуществляется на основе следующих критериев. 

1. Работает ли [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] на **компьютере, имеющем более одного микропроцессора или ЦП** (таком как симметричный многопроцессорный компьютер (SMP)). Использовать параллельные запросы могут только компьютеры, имеющие более одного ЦП. 

2. Достаточно ли **доступных рабочих потоков**. Каждый запрос или операция с индексами требуют определенного числа рабочих потоков. Для выполнения параллельного плана требуется больше рабочих потоков, чем для выполнения последовательного плана, и по мере увеличения степени параллелизма число необходимых рабочих потоков возрастает. Если требования к рабочим потокам для параллельного плана с определенной степенью параллелизма не могут быть удовлетворены, [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] автоматически уменьшает степень параллелизма или полностью отказывается от параллельного плана в указанном контексте рабочей нагрузки. В этом случае он выполняет последовательный план (с одним рабочим потоком). 

3. **Тип выполняемого запроса или операции с индексами**. Операции с индексами, которые создают или перестраивают индекс или удаляют кластеризованный индекс и запросы, интенсивно использующие циклы ЦП, являются лучшими кандидатами для параллельного плана. Например, хорошими кандидатами являются соединения больших таблиц, больших статистических выражений и сортировка больших результирующих наборов. Простые запросы, часто находящиеся в приложениях обработки транзакций, находят дополнительную координацию, запрашиваемую для выполнения запроса в параллельном перевешивании возможного повышения производительности. Чтобы различать запросы, которые выигрывают от параллелизма, и запросы, которые не выигрывают от параллелизма, [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] сравнивает предполагаемую стоимость выполняемого запроса или операции индекса со значением [ценового ограничения для параллелизма](../database-engine/configure-windows/configure-the-cost-threshold-for-parallelism-server-configuration-option.md). Пользователи могут изменить значение по умолчанию 5 при помощи [sp_configure](../relational-databases/system-stored-procedures/sp-configure-transact-sql.md), если при надлежащем тестировании найдено другое значение, которое больше подходит для выполнения рабочей нагрузки. 

4. Достаточно ли количество **строк, подлежащих обработке**. Если оптимизатор запросов устанавливает, что число строк слишком мало, то для распространения строк он не вставляет операторы преобразования валюты. Следовательно, операторы обрабатываются последовательно. Обработка операторов в последовательном плане позволяет избежать сценариев, когда стоимость запуска, распределения и координации превышает преимущества, достигнутые параллельной обработкой оператора.

5. Доступна ли **статистика распределения**. Если наивысшая степень параллелизма невозможна, более низкие степени рассматриваются до того, как отвергается параллельный план. Например, статистика распределения не может вычисляться при создании кластеризованного индекса на представлении, потому что кластеризованный индекс еще не существует. В таком случае компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] не может предоставить наивысшую степень параллелизма для операции с индексами. Однако некоторые операторы, такие как сортировка и сканирование, по-прежнему могут выигрывать от параллельной обработки.

> [!NOTE]
> Параллельные операции с индексами доступны только в выпусках [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Developer Edition, Evaluation Edition и Enterprise Edition.
 
Во время выполнения компонент [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] устанавливает, разрешены ли описанные ранее текущая рабочая нагрузка системы и конфигурация для параллельного выполнения. Если параллельное выполнение гарантировано, [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] определяет оптимальное число рабочих потоков и распределяет выполнение параллельного плана по этим рабочим потокам. Если запрос или операция с индексами начинает параллельно выполняться в нескольких рабочих потоках, это же число рабочих потоков используется до тех пор, пока операция не будет завершена. [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] повторно определяет оптимальное число рабочих потоков каждый раз при получении плана выполнения из кэша планов. Например, при первом выполнении запроса может использоваться последовательный план, при повторном выполнении того же запроса — параллельный план с тремя рабочими потоками, при третьем выполнении — параллельный план с четырьмя рабочими потоками.

Операторы UPDATE и DELETE в плане параллельного выполнения запросов выполняются последовательно, но предложение WHERE инструкции UPDATE или DELETE можно выполнять параллельно. В таком случае изменения фактических данных последовательно применяются к базе данных.

До [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] оператор INSERT также выполнялся последовательно, но часть SELECT инструкции INSERT можно выполнять параллельно. В таком случае изменения фактических данных последовательно применяются к базе данных. 

Начиная с [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] и уровня совместимости базы данных 110, инструкцию `SELECT … INTO` можно выполнять параллельно. Другие формы операторов INSERT работают так же, как для [!INCLUDE[ssSQL11](../includes/sssql11-md.md)].

Начиная с [!INCLUDE[sssql15-md](../includes/sssql16-md.md)] и уровня совместимости базы данных 130, инструкцию `INSERT … SELECT` можно выполнять параллельно при вставке в кучи или кластеризованные индексы columnstore (CCI) и использовании подсказки TABLOCK. Операции вставки в локальные временные таблицы (определяемые префиксом #) и глобальные временные таблицы (определяемые префиксами ##) также поддерживают параллелизм с использованием указания TABLOCK. Дополнительные сведения см. в статье [Инструкция INSERT (Transact-SQL)](../t-sql/statements/insert-transact-sql.md#best-practices).

Статические курсоры и курсоры, управляемые набором ключей, могут быть заполнены параллельными планами выполнения. Однако поведение динамических курсоров может поддерживаться только последовательным выполнением. Оптимизатор запросов всегда формирует последовательный план выполнения для запроса, являющегося частью динамического курсора.

#### <a name="overriding-degrees-of-parallelism"></a>Переопределение степеней параллелизма
Максимальная степень параллелизма задает количество процессоров, используемых при одновременном исполнении планов. Эту конфигурацию можно задать на различных уровнях:

1.  На уровне сервера — с помощью [параметра конфигурации сервера](../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md) **max degree of parallelism (MAXDOP)** .</br> **Применимо к:** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]

    > [!NOTE]
    > [!INCLUDE [sssql19-md](../includes/sssql19-md.md)] содержит автоматические рекомендации по настройке параметра конфигурации сервера MAXDOP в процессе установки. Пользовательский интерфейс программы установки позволяет либо принять рекомендуемые параметры, либо задать свое значение. Дополнительные сведения см. в разделе [Конфигурация ядра СУБД — страница MaxDOP](../sql-server/install/instance-configuration.md#maxdop).

2.  На уровне рабочих нагрузок — с помощью [параметра конфигурации группы рабочей нагрузки Resource Governor](../t-sql/statements/create-workload-group-transact-sql.md) **MAX_DOP**.</br> **Применимо к:** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]

3.  На уровне базы данных — с помощью [конфигурации области баз данных](../t-sql/statements/alter-database-scoped-configuration-transact-sql.md)**MAXDOP**.</br> **Область применения:** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и [!INCLUDE[ssSDSfull](../includes/sssdsfull-md.md)] 

4.  На уровне инструкции запроса или индекса — с помощью [указания запроса](../t-sql/queries/hints-transact-sql-query.md) **MAXDOP** или параметра индекса **MAXDOP**. Например, с помощью параметра MAXDOP можно увеличить или уменьшить число процессоров, выделенных для операций с индексами в сети. Таким образом, можно сбалансировать ресурсы, используемые операцией с индексами с теми текущими пользователями.</br> **Область применения:** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и [!INCLUDE[ssSDSfull](../includes/sssdsfull-md.md)] 

Если указать для параметра "максимальная степень параллелизма" значение 0 (по умолчанию), [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] сможет использовать все доступные процессоры (до 64) при выполнении параллельного плана. Хотя при использовании значения 0 параметра MAXDOP целевое количество процессоров в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] составляет 64 логических процессора, при необходимости можно указать другое значение вручную. При использовании значения 0 параметра MAXDOP для запросов и индексов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует все доступные процессоры (максимально допустимое количество процессоров равно 64) для данных запросов и индексов при выполнении параллельного плана. Значение MAXDOP не применяется принудительно для всех параллельных запросов. Оно представляет собой условный целевой показатель для всех запросов, которые можно выполнять параллельно. Это означает, что если во время выполнения доступно недостаточное количество рабочих потоков, запрос может выполняться со степенью параллелизма, более низкой по сравнению с той, которая задана в параметре MAXDOP.

> [!TIP]
> Инструкции по настройке MAXDOP см. на этой [странице документации](../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md#Guidelines).

### <a name="parallel-query-example"></a>Пример параллельного запроса
В нижеследующем запросе подсчитывается количество заказов, размещенных в течение указанного квартала, начиная с 1 апреля 2000, в которых хотя бы один элемент из списка заказанных товаров был получен заказчиком позже фиксированной даты. В этом запросе представлен подсчет таких заказов, сгруппированных в соответствии со срочностью каждого заказа и отсортированных в возрастающем порядке. 

В этом примере используются теоретические имена таблицы и столбцов.

```sql
SELECT o_orderpriority, COUNT(*) AS Order_Count
FROM orders
WHERE o_orderdate >= '2000/04/01'
   AND o_orderdate < DATEADD (mm, 3, '2000/04/01')
   AND EXISTS
         (
          SELECT *
            FROM    lineitem
            WHERE l_orderkey = o_orderkey
               AND l_commitdate < l_receiptdate
         )
   GROUP BY o_orderpriority
   ORDER BY o_orderpriority
```

Предположим, что в таблицах `lineitem` и `orders` определены следующие индексы:

```sql
CREATE INDEX l_order_dates_idx 
   ON lineitem
      (l_orderkey, l_receiptdate, l_commitdate, l_shipdate)

CREATE UNIQUE INDEX o_datkeyopr_idx
   ON ORDERS
      (o_orderdate, o_orderkey, o_custkey, o_orderpriority)
```

Вот один из возможных параллельных планов, созданный для запроса, показанного выше:

```
|--Stream Aggregate(GROUP BY:([ORDERS].[o_orderpriority])
                  DEFINE:([Expr1005]=COUNT(*)))
    |--Parallelism(Gather Streams, ORDER BY:
                  ([ORDERS].[o_orderpriority] ASC))
         |--Stream Aggregate(GROUP BY:
                  ([ORDERS].[o_orderpriority])
                  DEFINE:([Expr1005]=Count(*)))
              |--Sort(ORDER BY:([ORDERS].[o_orderpriority] ASC))
                   |--Merge Join(Left Semi Join, MERGE:
                  ([ORDERS].[o_orderkey])=
                        ([LINEITEM].[l_orderkey]),
                  RESIDUAL:([ORDERS].[o_orderkey]=
                        [LINEITEM].[l_orderkey]))
                        |--Sort(ORDER BY:([ORDERS].[o_orderkey] ASC))
                        |    |--Parallelism(Repartition Streams,
                           PARTITION COLUMNS:
                           ([ORDERS].[o_orderkey]))
                        |         |--Index Seek(OBJECT:
                     ([tpcd1G].[dbo].[ORDERS].[O_DATKEYOPR_IDX]),
                     SEEK:([ORDERS].[o_orderdate] >=
                           Apr  1 2000 12:00AM AND
                           [ORDERS].[o_orderdate] <
                           Jul  1 2000 12:00AM) ORDERED)
                        |--Parallelism(Repartition Streams,
                     PARTITION COLUMNS:
                     ([LINEITEM].[l_orderkey]),
                     ORDER BY:([LINEITEM].[l_orderkey] ASC))
                             |--Filter(WHERE:
                           ([LINEITEM].[l_commitdate]<
                           [LINEITEM].[l_receiptdate]))
                                  |--Index Scan(OBJECT:
         ([tpcd1G].[dbo].[LINEITEM].[L_ORDER_DATES_IDX]), ORDERED)
```

На рисунке показан план запросов, который выполняется со степенью параллелизма, равной 4, и включает соединение двух таблиц.

![parallel_plan](../relational-databases/media/parallel-plan.gif)

Параллельный план содержит три оператора параллелизма. Оба оператора, Index Seek для индекса `o_datkey_ptr` и Index Scan для индекса `l_order_dates_idx`, выполняются параллельно. В результате образуется несколько исключающих потоков. Это можно определить по ближайшим операторам параллелизма над операторами Index Scan и Index Seek соответственно. Оба перераспределяют тип обмена. То есть они всего лишь перегруппируют данные между потоками и выдают в результате столько же потоков на выходе, сколько их было на входе. Количество потоков равно степени параллелизма.

Оператор параллелизма над оператором Index Seek `l_order_dates_idx` перераспределяет свои входные потоки с использованием значения `L_ORDERKEY` в качестве ключа. В этом случае те же значения `L_ORDERKEY` выдаются в том же выходном потоке. Одновременно в выходных потоках сохраняется порядок в столбце `L_ORDERKEY` для соответствия требованиям оператора Merge Join к входным данным.

Оператор параллелизма над оператором Index Seek перераспределяет свои входные потоки с использованием значения `O_ORDERKEY`. Так как его входные данные не сортируются по значениям столбца `O_ORDERKEY`, а он является столбцом соединения в операторе `Merge Join`, то оператор Sort между операторами параллелизма и Merge Join обеспечивает сортировку входных данных для оператора `Merge Join` по столбцам соединения. Оператор `Sort`, как и оператор Merge Join, выполняется параллельно.

Первый оператор параллелизма объединяет результаты из нескольких потоков в один. Результаты частичной статистической обработки, выполняемой оператором Stream Aggregate под оператором параллелизма, затем собираются в единое значение `SUM` для каждого отдельного значения `O_ORDERPRIORITY` в операторе Stream Aggregate над оператором параллелизма. Так как этот план состоит из двух сегментов обмена со степенью параллелизма, равной 4, в этом плане используется восемь рабочих потоков.

Дополнительные сведения об операторах, используемых в этом примере, см. в [справочнике по логическим и физическим операторам Showplan](../relational-databases/showplan-logical-and-physical-operators-reference.md).

### <a name="parallel-index-operations"></a>Параллельные операции с индексами

Планы запросов, созданные для операций создания или перестроения индекса либо удаления кластеризованного индекса, поддерживают возможность параллельной обработки в нескольких рабочих потоках на многопроцессорных компьютерах.

> [!NOTE]
> Параллельные операции с индексами доступны, начиная с выпуска [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)].
 
В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] используются одни и те же алгоритмы определения степени параллелизма (общего числа отдельных рабочих потоков, которые будут запущены) как для операций с индексами, так и для других запросов. Максимальная степень параллелизма для операции с индексом определяется параметром конфигурации сервера [max degree of parallelism](../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md) . Значение max degree of parallelism можно переопределять для отдельных операций с индексами путем настройки параметра индекса MAXDOP в инструкциях CREATE INDEX, ALTER INDEX, DROP INDEX и ALTER TABLE.

Когда [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] создает план выполнения индекса, количество параллельных операций устанавливается в самое низкое из следующих значений. 

* Число микропроцессоров (ЦП) в компьютере.
* Число, указанное в качестве параметра конфигурации сервера max degree of parallelism.
* Число ЦП, которые не превышают порог загруженности для рабочих потоков [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].

Например, на компьютере с восемью ЦП, на котором максимальная степень параллелизма равна 6, для операций с индексами создается не более шести параллельных рабочих потоков. Если на пяти ЦП компьютера будет превышено ограничение количества рабочих потоков [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], когда строится план выполнения индексации, в плане выполнения будет указано только три параллельных рабочих потока.

Главные фазы параллельных операций с индексами таковы. 

* Координирующий рабочий поток быстро и случайным образом просматривает таблицу для оценки распределения ключей индекса. Координирующий рабочий поток устанавливает ключевые границы, образующие число диапазонов ключей, равное степени параллелизма. Каждый диапазон должен покрывать примерно одинаковое число строк. Например, если в таблице четыре миллиона строк, а степень параллелизма равна 4, то координирующий рабочий поток определит ключевые значения, которые разделят все строки на четыре набора строк по одному миллиону строк в каждом. Если для использования всех ЦП невозможно установить достаточное число диапазонов ключей, степень параллелизма соответствующим образом снижается.  
* Координирующий рабочий поток запускает рабочие потоки, количество которых равно степени параллелизма операций, и ожидает завершения этих потоков. Каждый из рабочих потоков просматривает базовую таблицу с использованием фильтра, который отделяет только строки со значениями ключей в диапазоне, назначенном этому рабочему потоку. Каждый рабочий поток создает структуру индекса для строк в своем диапазоне ключей. В случае секционированного индекса каждый из рабочих потоков создает заданное число секций. Одни и те же секции не разделяются между несколькими рабочими потоками.  
* После завершения работы всех параллельных рабочих потоков координирующий рабочих поток связывает компоненты индекса в единый индекс. Эта фаза применяется только для операций с индексами в сети.

В отдельных инструкциях `CREATE TABLE` или `ALTER TABLE` могут содержаться несколько ограничений, требующих создания индекса. Такие множественные операции по созданию индекса выполняются последовательно, хотя каждая из них может быть параллельной операцией на многопроцессорном компьютере.

## <a name="distributed-query-architecture"></a>Архитектура распределенных запросов
Microsoft [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] поддерживает два метода обращения к разнородным источникам данных OLE DB в инструкциях [!INCLUDE[tsql](../includes/tsql-md.md)].

* Имена связанных серверов  
  Системные хранимые процедуры `sp_addlinkedserver` и `sp_addlinkedsrvlogin` используются для задания серверного имени источнику данных OLE DB. К объектам на этих связанных серверах можно обращаться в инструкциях языка [!INCLUDE[tsql](../includes/tsql-md.md)] по четырехкомпонентным именам. Например, если имя связанного сервера `DeptSQLSrvr` определено для другого экземпляра [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], для обращения к таблице на таком сервере используется следующая инструкция. 
  
  ```sql
  SELECT JobTitle, HireDate 
  FROM DeptSQLSrvr.AdventureWorks2014.HumanResources.Employee;
  ```

   Имя связанного сервера можно также указать в инструкции `OPENQUERY` для открытия набора строк из источника данных OLE DB. К этому набору строк можно обращаться в инструкциях языка [!INCLUDE[tsql](../includes/tsql-md.md)] так же, как и к таблице: 

* Имена нерегламентированных соединителей  
  Для нечастых обращений к источнику данных используются функции `OPENROWSET` или `OPENDATASOURCE` , которым задаются данные, необходимые для подключения к связанному серверу. Затем можно обращаться к набору строк в инструкциях языка [!INCLUDE[tsql](../includes/tsql-md.md)] тем же путем, что и к таблице: 
  
  ```sql
  SELECT *
  FROM OPENROWSET('Microsoft.Jet.OLEDB.4.0',
        'c:\MSOffice\Access\Samples\Northwind.mdb';'Admin';'';
        Employees);
  ```

В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] для коммуникации между реляционным механизмом и подсистемой хранилища используется технология OLE DB. Реляционный механизм разбивает каждую инструкцию языка [!INCLUDE[tsql](../includes/tsql-md.md)] на последовательные операции над простыми наборами строк OLE DB, открываемые подсистемой хранилища из базовых таблиц. Это означает, что реляционный механизм может также открывать простые наборы строк OLE DB на любом источнике данных OLE DB.  
![oledb_storage](../relational-databases/media/oledb-storage.gif)  
В реляционном механизме используется прикладной программный интерфейс (API) OLE DB для открытия наборов строк на связанных серверах, выборки строк и управления транзакциями.

Для каждого источника данных OLE DB, доступ к которому осуществляется как к связанному серверу, на сервере с запущенной службой [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] должен быть поставщик OLE DB. Набор операций языка [!INCLUDE[tsql](../includes/tsql-md.md)], которые можно использовать с конкретным источником данных OLE DB, зависит от возможностей поставщика OLE DB.

Для каждого экземпляра [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] участники предопределенной роли сервера `sysadmin` могут включать или отключать использование нерегламентированных имен соединителей для поставщика OLE DB с помощью свойства [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] `DisallowAdhocAccess`. Если нерегламентированный доступ включен, любой пользователь, зарегистрированный на данном экземпляре, может выполнять инструкции [!INCLUDE[tsql](../includes/tsql-md.md)], содержащие имена нерегламентированных соединителей, обращающиеся к любым источникам данных в сети, доступ к которым возможен посредством данного поставщика OLE DB. Для управления доступом к источникам данных члены роли `sysadmin` могут отключить нерегламентированный доступ к определенному поставщику OLE DB, ограничивая таким образом пользователям доступ лишь к тем источникам данных, обращение к которым производится по именам связанных серверов, определенным администраторами. По умолчанию нерегламентированный доступ включен для поставщика OLE DB [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и отключен для всех остальных поставщиков OLE DB.

С помощью распределенных запросов пользователи могут обращаться к другим источникам данных (например, файлам, нереляционным источникам данных, таким как Active Directory и др.) с помощью контекста безопасности учетной записи Microsoft Windows, от имени которой запущена служба [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может олицетворять имена для входа в Windows, но в случае имен для входа [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] это невозможно. Это потенциально может открыть пользователю распределенного запроса доступ к другому источнику данных, для которого у него нет разрешения, но у учетной записи, под которой запущена служба [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], такое разрешение есть. Для указания конкретных имен входа, которым будет разрешен доступ к соответствующему связанному серверу, используется процедура `sp_addlinkedsrvlogin` . Для нерегламентированных имен такой контроль недоступен, поэтому следует проявлять осторожность при включении нерегламентированного доступа к поставщику OLE DB.

По возможности [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] принудительно отправляет реляционные операции (соединения, ограничения, проекции, сортировки и группировки по операциям) к источнику данных OLE DB. По умолчанию [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не просматривает базовую таблицу в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] и не выполняет реляционных операций самостоятельно. [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] запрашивает у поставщика OLE DB уровень поддерживаемой им грамматики SQL и на основе этих данных направляет поставщику максимально возможное число реляционных операций. 

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] указывает поставщику OLE DB механизм возвращения статистики распределения ключевых значений в пределах источника данных OLE DB. Это позволяет оптимизатору запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] лучше проанализировать шаблон данных в источнике данных на соответствие требованиям для каждой инструкции [!INCLUDE[tsql](../includes/tsql-md.md)], что позволяет более эффективно создавать оптимальные планы выполнения. 

## <a name="query-processing-enhancements-on-partitioned-tables-and-indexes"></a>Улучшенные возможности обработки запросов для секционированных таблиц и индексов

В [!INCLUDE[ssKatmai](../includes/ssKatmai-md.md)] повышена эффективность обработки запросов к секционированным таблицам для множества параллельных планов, изменен способ представления параллельных и последовательных планов и улучшены сведения о секционировании, содержащиеся в планах выполнения времени компиляции и времени выполнения. В этом разделе описываются названные улучшения, содержится справочник об интерпретации планов выполнения запросов таблиц секционирования и индексов и дополнительные сведения об улучшении производительности запросов к секционированным объектам. 

> [!NOTE]
> До [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] секционированные таблицы и индексы поддерживаются только в выпусках [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Enterprise Edition, Developer Edition и Evaluation Edition.   
> Начиная с [!INCLUDE[sssql15-md](../includes/sssql16-md.md)] с пакетом обновления 1 (SP1) секционированные таблицы и индексы также поддерживаются в выпуске [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Standard Edition. 

### <a name="new-partition-aware-seek-operation"></a>Новая операция поиска, учитывающая секционирование

В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] внутреннее представление секционированной таблицы изменено таким образом, что таблица представляется обработчику запросов как индекс по нескольким столбцам с `PartitionID` в качестве начального столбца. `PartitionID` представляет собой скрытый внутренний вычисляемый столбец для представления `ID` секции, содержащей определенную строку. Например, предположим, что таблица T, определенная как `T(a, b, c)`, секционирована по столбцу a и содержит кластеризованный индекс по столбцу b. В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] эта секционированная таблица обрабатывается как несекционированная таблица со схемой `T(PartitionID, a, b, c)` и кластеризованным индексом по составному ключу `(PartitionID, b)`. Это позволяет оптимизатору запросов выполнять операции поиска на основе `PartitionID` по любой секционированной таблице или индексу. 

Устранение секций теперь осуществляется в этой операции поиска.

In addition, the Query Optimizer is extended so that a seek or scan operation with one condition can be done on `PartitionID` (в качестве логического начального столбца) и, возможно, по другим ключевым столбцам индекса, а затем может быть выполнен поиск второго уровня с другим условием по одному дополнительному столбцу или более для каждого уникального значения, удовлетворяющего операции поиска первого уровня. Операция, называемая "просмотр с пропуском", позволяет оптимизатору запросов выполнять операцию поиска или просмотра по одному условию для определения секций, к которым будет осуществляться доступ, и операцию поиска индекса второго уровня с помощью этого оператора для выборки строк из этих секций, удовлетворяющих другому условию. Например, рассмотрим следующий запрос.

```sql
SELECT * FROM T WHERE a < 10 and b = 2;
```

В данном примере, предположим, таблица T, определенная как `T(a, b, c)`, секционирована по столбцу a и содержит кластеризованный индекс по столбцу b. Границы секции для таблицы T определены следующей функцией секционирования:

```sql
CREATE PARTITION FUNCTION myRangePF1 (int) AS RANGE LEFT FOR VALUES (3, 7, 10);
```

Для разрешения запроса обработчик запросов выполняет операцию поиска первого уровня для нахождения каждой секции, содержащей строки, удовлетворяющие условию `T.a < 10`. Это позволяет выявить секции, к которым необходимо получить доступ. В каждой выявленной секции обработчик выполняет поиск второго уровня по кластеризованному индексу по столбцу b для нахождения строк, удовлетворяющих условию `T.b = 2` и `T.a < 10`. 

На следующем рисунке изображено логическое представление операции просмотра с пропуском. На нем изображена таблица `T` с данными в столбцах `a` и `b`. Секции пронумерованы от 1 до 4, а границы секций показаны вертикальными штриховыми линиями. Операция поиска первого уровня для секций (на иллюстрации не показана) определила, что секции 1, 2 и 3 удовлетворяют условию поиска, предполагаемого секционированием, определенным для таблицы и предиката по столбцу `a`. то есть `T.a < 10`. Путь, пройденный частью операции просмотра с пропуском, поиском второго уровня, изображен изогнутой линией. Фактически операция просмотра с пропуском выполняет поиск строк, удовлетворяющих условию `b = 2`в каждой их этих секций. Общие затраты на выполнение операции просмотра с пропуском соответствуют трем отдельным поискам по индексу.   

![skip_scan](../relational-databases/media/skip-scan.gif)

### <a name="displaying-partitioning-information-in-query-execution-plans"></a>Отображение сведений о секционировании в планах выполнения запросов

Планы выполнения запросов в секционированных таблицах и индексах можно изучить с помощью инструкций `SET SHOWPLAN_XML` или `SET STATISTICS XML` языка [!INCLUDE[tsql](../includes/tsql-md.md)] `SET` или с помощью графического представления в среде [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Management Studio. Например, план выполнения времени компиляции можно отобразить, щелкнув *Показать предполагаемый план выполнения* на панели инструментов редактора запросов, а план времени выполнения — щелкнув *Включить действительный план выполнения*. 

С помощью этих средств можно получить следующую информацию:

* операции, такие как `scans`, `seeks`, `inserts`, `updates`, `merges`и `deletes` , которые осуществляют доступ к таблицам и индексам;
* секции, к которым запрос получает доступ — например, в планах времени выполнения приведено общее число секций, к которым получен доступ, и диапазоны смежных секций, к которым получен доступ;
* когда операция просмотра с пропуском используется в операции поиска или просмотра для получения данных из одной секции или более.

#### <a name="partition-information-enhancements"></a>Улучшенные возможности информации о секции

[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] содержит расширенные сведения о секционировании как для планов времени компиляции, так и для планов времени выполнения. Планы выполнения теперь содержат следующую информацию.

* Дополнительный атрибут `Partitioned` указывает, что оператор, например `seek`, `scan`, `insert`, `update`, `merge`или `delete`, выполняется в отношении секционированной таблицы.  
* Новый элемент `SeekPredicateNew` с вложенным элементом `SeekKeys` , содержащим `PartitionID` в качестве начального ключевого столбца индекса и условия фильтра, определяющие операции поиска по диапазону в `PartitionID`. Наличие двух вложенных элементов `SeekKeys` указывает на то, что в отношении `PartitionID` используется операция просмотра с пропуском.   
* Сводные данные об общем числе секций, к которым получен доступ. Эта информация доступна только в планах времени выполнения. 

Для демонстрации отображения этой информации как в графическом плане выполнения, так и в отчете инструкции XML Showplan рассмотрим следующий запрос по секционированной таблице `fact_sales`. Этот запрос обновляет данные в двух секциях. 

```sql
UPDATE fact_sales
SET quantity = quantity * 2
WHERE date_id BETWEEN 20080802 AND 20080902;
```

На следующем рисунке показаны свойства оператора `Clustered Index Seek` в плане времени для времени выполнения этого запроса. Определение таблицы `fact_sales` и определение секции см. в подразделе "Пример" в этом разделе.  

![clustered_index_seek](../relational-databases/media/clustered-index-seek.gif)

#### <a name="partitioned-attribute"></a>Атрибут Partitioned

Когда оператор, такой как Index Seek, выполняется применительно к секционированной таблице или индексу, в планах времени компиляции и времени выполнения появляется атрибут `Partitioned` со значением `True` (1). Этот атрибут не отображается, если его значение установлено как `False` (0).

Атрибут `Partitioned` может встречаться в следующих физических и логических операторах:  
|||
|--------|--------|
|Table Scan|Index Scan|
|Index Seek|Вставить|
|Update|DELETE|
|Объединить||

Как показано на предыдущей иллюстрации, этот атрибут отображается в свойствах оператора, в котором он определен. В отчете инструкции XML Showplan этот атрибут появляется как `Partitioned="1"` в узле `RelOp` оператора, в котором он определен.

#### <a name="new-seek-predicate"></a>Предикат New Seek

В выводе инструкции XML Showplan элемент `SeekPredicateNew` появляется в операторе, в котором он определен. Он может содержать до двух экземпляров вложенного элемента `SeekKeys` . Первый элемент `SeekKeys` определяет операцию поиска первого уровня на уровне идентификатора секции логического индекса. То есть эта операция поиска определяет секции, к которым должен быть осуществлен доступ для удовлетворения условий запроса. Второй элемент `SeekKeys` определяет часть операции просмотра с пропуском, поиск второго уровня, который производится в каждой секции, определенной поиском первого уровня. 

#### <a name="partition-summary-information"></a>Сводные данные по секциям

В планах времени выполнения сводка по секциям содержит данные о числе секций, к которым осуществлен доступ, и фактический перечень секций, к которым осуществлен доступ. С помощью этих данных можно проверить, к правильным ли секциям обращается запрос и исключены ли из рассмотрения остальные секции.

Предоставляется следующая информация: `Actual Partition Count`и `Partitions Accessed`. 

`Actual Partition Count` — это общее число секций, к которым запрос получает доступ.

`Partitions Accessed`в выводе инструкции XML Showplan — это сводные данные по секциям, которые появляются в новом элементе `RuntimePartitionSummary` в узле `RelOp` оператора, в котором он определен. В следующем примере показано содержимое элемента `RuntimePartitionSummary` , указывающее, что получен доступ только к двум секциям (секции 2 и 3).
```
<RunTimePartitionSummary>

    <PartitionsAccessed PartitionCount="2" >

        <PartitionRange Start="2" End="3" />

    </PartitionsAccessed>

</RunTimePartitionSummary>
```

#### <a name="displaying-partition-information-by-using-other-showplan-methods"></a>Отображение сведений о секционировании с помощью других методов Showplan

Методы Showplan `SHOWPLAN_ALL`, `SHOWPLAN_TEXT`и `STATISTICS PROFILE` не формируют сведения о секционировании, описанные в этом разделе, за следующим исключением. Как часть предиката `SEEK` , секции, к которым необходимо получить доступ, обозначаются предикатом по диапазону в вычисляемом столбце, представляющем идентификатор секций. В следующем примере показан предикат `SEEK` для оператора `Clustered Index Seek` . К секциям 2 и 3 происходит обращение, и оператор поиска производит фильтрацию по строкам, удовлетворяющим условию `date_id BETWEEN 20080802 AND 20080902`.
```
|--Clustered Index Seek(OBJECT:([db_sales_test].[dbo].[fact_sales].[ci]), 

        SEEK:([PtnId1000] >= (2) AND [PtnId1000] \<= (3) 

                AND [db_sales_test].[dbo].[fact_sales].[date_id] >= (20080802) 

                AND [db_sales_test].[dbo].[fact_sales].[date_id] <= (20080902)) 

                ORDERED FORWARD)
```

#### <a name="interpreting-execution-plans-for-partitioned-heaps"></a>Интерпретация планов выполнения для секционированной кучи

Секционированная куча обрабатывается как логический индекс по идентификатору секции. Устранение секций на секционированной куче представлено в плане выполнения в виде оператора `Table Scan` с предикатом `SEEK` по идентификатору секции. Следующий пример отображает сведения Showplan:
```
|-- Table Scan (OBJECT: ([db].[dbo].[T]), SEEK: ([PtnId1001]=[Expr1011]) ORDERED FORWARD)
```

#### <a name="interpreting-execution-plans-for-collocated-joins"></a>Интерпретация планов выполнения для выровненных соединений

Выравнивание соединений может возникать, когда две таблицы секционированы с использованием одной и той же функции или эквивалентных функций секционирования и столбцы секционирования из обеих сторон соединения указываются в условии соединения запроса. Оптимизатор запросов может сформировать план, в котором секции каждой таблицы, имеющие равные идентификаторы, соединяются отдельно. Выровненные соединения могут выполняться быстрее, чем невыровненные, поскольку требуют меньшего объема памяти и времени обработки. Оптимизатор выбирает невыровненный план или выровненный план исходя из расчета затрат.

В выровненных планах соединение `Nested Loops` считывает одну или более секций для соединяемых таблиц или индексов с внутренней стороны. Цифры в операторах `Constant Scan` представляют собой номера секций. 

Если для секционированных таблиц или индексов формируются параллельные планы для выровненных соединений, то между операторами соединения `Constant Scan` и `Nested Loops` появляется оператор Parallelism. В этом случае каждый из нескольких рабочих потоков на внешней стороне соединения считывает разные секции и работает с разными секциями. 

Следующий рисунок демонстрирует план параллельных запросов для выровненных соединений.   
![colocated_join](../relational-databases/media/colocated-join.gif)


#### <a name="parallel-query-execution-strategy-for-partitioned-objects"></a>Стратегия выполнения параллельных запросов для секционированных объектов

Обработчик запросов использует стратегию параллельного выполнения для запросов, производящих выборку из секционированных объектов. В рамках стратегии выполнения обработчик запросов определяет секции таблицы, необходимые для запроса, и долю рабочих потоков, которую следует выделить для каждой секции. В большинстве случаев обработчик запросов выделяет равное или почти равное количество рабочих потоков для каждой секции, а затем выполняет запрос параллельно на всех секциях. Выделение рабочих потоков более подробно описано ниже.  

![Рабочий поток 1](../relational-databases/media/thread1.gif)

Если число рабочих потоков меньше числа секций, обработчик запросов назначает по одному рабочему потоку каждой отдельной секции, оставляя несколько секций без рабочих потоков. Когда рабочий поток завершает работу с секцией, обработчик запросов назначает этот поток следующей секции. Это продолжается до тех пор, пока у каждой секции не будет по одному рабочему потоку. Это единственный случай, когда обработчик запросов перераспределяет рабочие потоки к другим секциям.  
Отображает рабочий поток, повторно назначенный после завершения. Если число рабочих потоков равно числу секций, обработчик запросов назначает каждой секции по одному рабочему потоку. После того как рабочий поток заканчивает работу, он не назначается другой секции.  

![Рабочий поток 2](../relational-databases/media/thread2.gif)  

Если число рабочих потоков больше числа секций, обработчик запросов назначает каждой секции одинаковое число рабочих потоков. Если число рабочих потоков не кратно числу секций, обработчик запросов выделяет по одному дополнительному рабочему потоку для некоторых секций, чтобы были использованы все доступные рабочие потоки. Обратите внимание, что если секция всего одна, ей будут назначены все потоки. На приведенном ниже рисунке показаны четыре секции и 14 рабочих потоков. Каждой секции назначено по 3 рабочих потока, у двух секций есть дополнительные рабочие потоки; всего назначено 14 рабочих потоков. После того как рабочий поток заканчивает работу, он не назначается другой секции.  

![Рабочий поток 3](../relational-databases/media/thread3.gif)  

В приведенных выше примерах демонстрируется достаточно прямолинейный способ распределения рабочих потоков. Реальная стратегия более сложна; она учитывает другие факторы, которые возникают при выполнении запроса. Например, если таблица секционирована и имеет кластеризованный индекс для столбца А, а в запросе используется предложение предиката `WHERE A IN (13, 17, 25)`, то обработчик запросов выделит один рабочий поток или несколько каждому из трех искомых значений из значений поиска (A=13, A=17 и A=25), а не каждой секции таблицы. Запрос необходимо выполнить только в секциях, содержащих эти значения; если все предикаты поиска будут расположены в одной секции таблицы, все рабочие потоки будут назначены этой секции.

Другой пример: предположим, что таблица имеет четыре секции для столбца A с граничными точками (10, 20, 30), индекс на столбце B, а в запросе содержится предикат `WHERE B IN (50, 100, 150)`. Так как секции таблицы основаны на значениях A, значения столбца B могут появляться во всех секциях таблицы. Поэтому обработчик запросов будет искать каждое из этих трех значений столбца B (50, 100, 150) в каждой из четырех секций таблицы. Обработчик запросов распределит рабочие потоки пропорционально, чтобы эти 12 операций сканирования запроса могли выполняться параллельно.

|Секции таблицы основаны на столбце А    |Операции поиска для столбца B в каждой секции таблицы |
|----|----|
|Секция таблицы 1: A < 10     |B = 50, B = 100, B = 150 |
|Секция таблицы 2: A >= 10 AND A < 20     |B = 50, B = 100, B = 150 |
|Секция таблицы 3: A >= 20 И A < 30     |B = 50, B = 100, B = 150 |
|Секция таблицы 4: A >= 30     |B = 50, B = 100, B = 150 |

### <a name="best-practices"></a>Рекомендации

Для увеличения производительности запросов, обращающихся к большому количеству данных из больших секционированных таблиц и индексов, предлагаются следующие рекомендации.

* Распределяйте каждую секцию по нескольким дискам. Это особенно актуально при использовании шпиндельных жестких дисков.
* Чтобы снизить затраты на ввод-вывод, по возможности используйте сервер с достаточным объемом основной памяти, вмещающей секции, требующие частого доступа, или все секции.
* Если данные, по которым выполняется запрос, не помещаются в памяти, рекомендуется выполнить сжатие таблиц и индексов. Это позволит снизить затраты на ввод-вывод.
* Чтобы в полной мере реализовать возможности параллельной обработки запросов, используйте сервер с быстрыми процессорами и как можно большим числом процессорных ядер.
* Обеспечьте достаточную пропускную способность контроллера ввода-вывода для сервера. 
* Чтобы в полной мере реализовать возможности оптимизированного просмотра сбалансированного дерева, создайте кластеризованный индекс по каждой большой секционированной таблице.
* При массовой загрузке данных в секционированные таблицы следуйте рекомендациям, приведенным в техническом документе [The Data Loading Performance Guide](/previous-versions/sql/sql-server-2008/dd425070(v=sql.100)) (Руководство по эффективной загрузке данных).

### <a name="example"></a>Пример

В следующем примере показано создание тестовой базы данных, состоящей из одной таблицы с семью секциями. Чтобы при выполнении запросов в этом примере просматривать сведения о секционировании в планах времени компиляции и времени выполнения, следует пользоваться инструментами, описанными ранее. 

> [!NOTE]
> В данном примере в таблицу вставляется более 1 миллиона строк. В зависимости от имеющегося оборудования выполнение данного примера может занять несколько минут. Перед выполнением этого примера следует убедиться, что на диске 1,5 ГБ свободного места. 
 
```sql
USE master;
GO
IF DB_ID (N'db_sales_test') IS NOT NULL
    DROP DATABASE db_sales_test;
GO
CREATE DATABASE db_sales_test;
GO
USE db_sales_test;
GO
CREATE PARTITION FUNCTION [pf_range_fact](int) AS RANGE RIGHT FOR VALUES 
(20080801, 20080901, 20081001, 20081101, 20081201, 20090101);
GO
CREATE PARTITION SCHEME [ps_fact_sales] AS PARTITION [pf_range_fact] 
ALL TO ([PRIMARY]);
GO
CREATE TABLE fact_sales(date_id int, product_id int, store_id int, 
    quantity int, unit_price numeric(7,2), other_data char(1000))
ON ps_fact_sales(date_id);
GO
CREATE CLUSTERED INDEX ci ON fact_sales(date_id);
GO
PRINT 'Loading...';
SET NOCOUNT ON;
DECLARE @i int;
SET @i = 1;
WHILE (@i<1000000)
BEGIN
    INSERT INTO fact_sales VALUES(20080800 + (@i%30) + 1, @i%10000, @i%200, RAND() * 25, (@i%3) + 1, '');
    SET @i += 1;
END;
GO
DECLARE @i int;
SET @i = 1;
WHILE (@i<10000)
BEGIN
    INSERT INTO fact_sales VALUES(20080900 + (@i%30) + 1, @i%10000, @i%200, RAND() * 25, (@i%3) + 1, '');
    SET @i += 1;
END;
PRINT 'Done.';
GO
-- Two-partition query.
SET STATISTICS XML ON;
GO
SELECT date_id, SUM(quantity*unit_price) AS total_price
FROM fact_sales
WHERE date_id BETWEEN 20080802 AND 20080902
GROUP BY date_id ;
GO
SET STATISTICS XML OFF;
GO
-- Single-partition query.
SET STATISTICS XML ON;
GO
SELECT date_id, SUM(quantity*unit_price) AS total_price
FROM fact_sales
WHERE date_id BETWEEN 20080801 AND 20080831
GROUP BY date_id;
GO
SET STATISTICS XML OFF;
GO
```

##  <a name="additional-reading"></a><a name="Additional_Reading"></a> Дополнительные материалы  
 [Справочник по логическим и физическим операторам Showplan](../relational-databases/showplan-logical-and-physical-operators-reference.md)  
 [Расширенные события](../relational-databases/extended-events/extended-events.md)  
 [Рекомендации по хранилищу запросов](../relational-databases/performance/best-practice-with-the-query-store.md)  
 [Оценка количества элементов](../relational-databases/performance/cardinality-estimation-sql-server.md)  
 [Интеллектуальная обработка запросов](../relational-databases/performance/intelligent-query-processing.md)   
 [Приоритет операторов](../t-sql/language-elements/operator-precedence-transact-sql.md)    
 [Планы выполнения](../relational-databases/performance/execution-plans.md)    
 [Центр производительности для базы данных SQL Azure и ядра СУБД SQL Server](../relational-databases/performance/performance-center-for-sql-server-database-engine-and-azure-sql-database.md)