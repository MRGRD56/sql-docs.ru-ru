---
title: Рекомендации и ограничения для групповой загрузки XML (SQLXML)
description: Сведения о рекомендациях и ограничениях использования групповой загрузки XML в SQLXML 4,0.
ms.date: 03/16/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- XML Bulk Load [SQLXML], about XML Bulk Load
- bulk load [SQLXML], about bulk load
ms.assetid: c5885d14-c7c1-47b3-a389-455e99a7ece1
author: MightyPen
ms.author: genemi
ms.custom: seo-lt-2019
monikerRange: =azuresqldb-current||>=sql-server-2016||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: b17b1990f168326ae884b4db4f1ff22a63b24e21
ms.sourcegitcommit: 1a544cf4dd2720b124c3697d1e62ae7741db757c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2020
ms.locfileid: "97439696"
---
# <a name="guidelines-and-limitations-of-xml-bulk-load-sqlxml-40"></a>Правила и ограничения массовой загрузки XML (SQLXML 4.0)
[!INCLUDE [SQL Server Azure SQL Database](../../../includes/applies-to-version/sql-asdb.md)]
  Использование массовой загрузки XML требует понимания следующих рекомендаций и ограничений.  
  
-   Встроенные схемы не поддерживаются.  
  
     Если в исходном XML-документе содержится встроенная схема, при массовой загрузке XML она не учитывается. Для массовой загрузки XML нужно задать схему сопоставления, внешнюю по отношению к XML-данным. Нельзя указать схему сопоставления в узле с помощью атрибута **xmlns = "КС:счема"** .  
  
-   Проверяется правильность формата XML-документа, но сам документ не проверяется.  
  
     При выполнении операции XML-загрузки выполняется проверка XML-документа, чтобы определить, соответствует ли он правильному формату, т. е. чтобы XML-код соответствует требованиям, предъявляемым к синтаксису XML-1,0 консорциум W3C. Если формат документа содержит ошибки, массовая загрузка XML прекращается и возвращает ошибку. Единственное исключение — когда документ является фрагментом (например, когда у него не один корневой элемент), в этом случае массовая загрузка XML загружает документ.  
  
     Массовая загрузка XML не проверяет документ на соответствие какой-либо схеме DTD или XML-Data, которую содержит или на которую ссылается файл XML-данных. Кроме того, массовая загрузка XML-данных не проверяет файл XML-данных на соответствие переданной схеме сопоставления.  
  
-   Никакая информация из пролога XML-документа не учитывается.  
  
     При выполнении операции XML-загрузки вся информация пропускается до и после \<root> элемента в XML-документе. В частности, массовая загрузка XML не учитывает никаких XML-деклараций, внутренних определений DTD, ссылок на внешние DTD, комментариев и тому подобное.  
  
-   При наличии схемы сопоставления, задающей связь «первичный ключ — внешний ключ» между двумя таблицами (например, между таблицами Customer и CustOrder), таблица, содержащая первичный ключ, должна описываться в схеме первой. Таблица с внешним ключевым столбцом должна располагаться после нее. Причина заключается в том, что порядок, в котором таблицы определяются в схеме, является порядком, который используется для их загрузки в базу данных. Например, следующая схема XDR выдаст ошибку при выполнении групповой загрузки XML, так как **\<Order>** элемент описан перед **\<Customer>** элементом. Столбец CustomerID в таблице CustOrder представляет собой внешний ключевой столбец, ссылающийся на первичный ключевой столбец CustomerID в таблице Cust.  
  
    ```  
    <?xml version="1.0" ?>  
    <Schema xmlns="urn:schemas-microsoft-com:xml-data"   
            xmlns:dt="urn:schemas-microsoft-com:xml:datatypes"    
            xmlns:sql="urn:schemas-microsoft-com:xml-sql" >  
  
        <ElementType name="Order" sql:relation="CustOrder" >  
          <AttributeType name="OrderID" />  
          <AttributeType name="CustomerID" />  
          <attribute type="OrderID" />  
          <attribute type="CustomerID" />  
        </ElementType>  
  
       <ElementType name="CustomerID" dt:type="int" />  
       <ElementType name="CompanyName" dt:type="string" />  
       <ElementType name="City" dt:type="string" />  
  
       <ElementType name="root" sql:is-constant="1">  
          <element type="Customers" />  
       </ElementType>  
       <ElementType name="Customers" sql:relation="Cust"   
                         sql:overflow-field="OverflowColumn"  >  
          <element type="CustomerID" sql:field="CustomerID" />  
          <element type="CompanyName" sql:field="CompanyName" />  
          <element type="City" sql:field="City" />  
          <element type="Order" >   
               <sql:relationship  
                   key-relation="Cust"  
                    key="CustomerID"  
                    foreign-key="CustomerID"  
                    foreign-relation="CustOrder" />  
          </element>  
       </ElementType>  
    </Schema>  
    ```  
  
-   Если в схеме не заданы столбцы переполнения с помощью заметки **SQL: overflow-поля** , то при выполнении XML-загрузки с массовыми загрузками данные XML-документа игнорируются, но не описываются в схеме сопоставления.  
  
     Массовая загрузка XML применяет заданную схему сопоставления каждый раз, как в потоке XML-данных попадаются известные теги. Данные, которые присутствуют в XML-документе, но не описаны в схеме, пропускаются. Например, предположим, что имеется схема сопоставления, описывающая **\<Customer>** элемент. Файл данных XML содержит **\<AllCustomers>** корневой тег (не описанный в схеме), включающий все **\<Customer>** элементы:  
  
    ```  
    <AllCustomers>  
      <Customer>...</Customer>  
      <Customer>...</Customer>  
       ...  
    </AllCustomers>  
    ```  
  
     В этом случае при выполнении операции XML с массовым загрузкой элемент не учитывается **\<AllCustomers>** и начинается сопоставление в **\<Customer>** элементе. Массовая загрузка XML пропускает все элементы, не описанные в схеме, но присутствующие в XML-документе.  
  
     Рассмотрите другой исходный XML-файл данных, содержащий **\<Order>** элементы. Эти элементы не описаны в схеме сопоставления.  
  
    ```  
    <AllCustomers>  
      <Customer>...</Customer>  
        <Order> ... </Order>  
        <Order> ... </Order>  
         ...  
      <Customer>...</Customer>  
        <Order> ... </Order>  
        <Order> ... </Order>  
         ...  
      ...  
    </AllCustomers>  
    ```  
  
     При выполнении групповой загрузки XML эти **\<Order>** элементы игнорируются. Но если в схеме для задания столбца в качестве столбца переполнения используется заметка **SQL: overflow-поле**, то при выполнении операции XML-загрузки в этом столбце сохраняются все невостребованные данные.  
  
-   Разделы CDATA и ссылки на сущности для сохранения их в базе данных преобразуются в эквивалентные строки.  
  
     В этом примере раздел CDATA заключает в оболочку значение для **\<City>** элемента. При выполнении групповой загрузки XML извлекается строковое значение ("Нью-Йорк") перед вставкой **\<City>** элемента в базу данных.  
  
    ```  
    <City><![CDATA[NY]]> </City>  
    ```  
  
     Массовая загрузка XML не сохраняет ссылки на сущности.  
  
-   Если в схеме сопоставления задано значение по умолчанию для атрибута и в исходных XML-данных этот атрибут отсутствует, при массовой загрузке XML будет использовано значение по умолчанию.  
  
     Следующий пример схемы XDR присваивает атрибуту **HireDate** значение по умолчанию:  
  
    ```  
    <?xml version="1.0" ?>  
    <Schema xmlns="urn:schemas-microsoft-com:xml-data"   
            xmlns:dt="urn:schemas-microsoft-com:xml:datatypes"    
            xmlns:sql="urn:schemas-microsoft-com:xml-sql" >  
       <ElementType name="root" sql:is-constant="1">  
          <element type="Customers" />  
       </ElementType>  
  
       <ElementType name="Customers" sql:relation="Cust3" >  
          <AttributeType name="CustomerID" dt:type="int"  />  
          <AttributeType name="HireDate"  default="2000-01-01" />  
          <AttributeType name="Salary"   />  
  
          <attribute type="CustomerID" sql:field="CustomerID" />  
          <attribute type="HireDate"   sql:field="HireDate"  />  
          <attribute type="Salary"     sql:field="Salary"    />  
       </ElementType>  
    </Schema>  
    ```  
  
     В этих XML-данных атрибут **HireDate** отсутствует во втором **\<Customers>** элементе. Когда при выполнении операции XML-загрузки в базу данных вставляется второй **\<Customers>** элемент, используется значение по умолчанию, указанное в схеме.  
  
    ```  
    <ROOT>  
      <Customers CustomerID="1" HireDate="1999-01-01" Salary="10000" />  
      <Customers CustomerID="2" Salary="10000" />  
    </ROOT>  
    ```  
  
-   Аннотация **SQL: URL-encoded** не поддерживается:  
  
     Нельзя задать во вводных XML-данных URL-адрес и ждать, что массовая загрузка XML прочтет данные, находящиеся по этому адресу.  
  
     Создаются таблицы, заданные в схеме сопоставления (база данных должна существовать). Если одна или несколько таблиц уже существуют в базе данных, свойство Сгдроптаблес определяет, нужно ли удалять и повторно создавать эти предварительно существовавшие таблицы.  
  
-   Если указать свойство SchemaGen (например, SchemaGen = true), то будут созданы таблицы, определенные в схеме сопоставления. Но SchemaGen не создает никаких ограничений (таких как ограничения ПЕРВИЧного и внешнего ключей) в этих таблицах с одним исключением: Если XML-узлы, составляющие первичный ключ в связи, определяются как имеющие тип XML ID (то есть **Type = "xsd: ID"** для XSD), а свойство сгусеид имеет значение true для SchemaGen, то не только первичные ключи создаются из узлов с типом ID, но связи первичного и внешнего ключей создаются из связей схемы сопоставления.  
  
-   SchemaGen не использует аспекты и расширения схемы XSD для создания реляционной [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] схемы.  
  
-   Если указать свойство SchemaGen (например, SchemaGen = true) при выполнении групповой загрузки, обновляются только таблицы (а не представления общего имени), которые задаются.  
  
-   SchemaGen предоставляет базовую функциональность только для создания реляционной схемы из аннотации XSD. При необходимости пользователь должен изменить созданные таблицы вручную.  
  
-   Если между таблицами существует несколько связей, SchemaGen пытается создать единую связь, включающую все ключи, участвующие в двух таблицах. Это ограничение может вызвать ошибку [!INCLUDE[tsql](../../../includes/tsql-md.md)].  
  
-   При массовой загрузке XML-данных в базу по меньшей мере один атрибут или дочерний элемент в схеме сопоставления должен быть сопоставлен со столбцом базы данных.  
  
-   Если при массовой загрузке XML происходит вставка значений дат, эти значения должны быть заданы в формате (-)CCYY-MM-DD((+-)TZ). Это стандартный формат даты в XSD.  
  
-   Некоторые флаги свойств несовместимы друг с другом. Например, при выполнении групповой загрузки не поддерживается **Ignoreduplicatekeys = true** вместе с **KEEPIDENTITY = false**. Если **KEEPIDENTITY = false**, то при выполнении групповой загрузки требуется, чтобы сервер создавал значения ключей. Таблицы должны иметь ограничение **Identity** для ключа. Сервер не будет создавать дублирующиеся ключи. Это означает, что для **Ignoreduplicatekeys** не нужно устанавливать значение **true**. **Ignoreduplicatekeys** должен иметь значение **true** только при передаче значений первичного ключа из входящих данных в таблицу, которая содержит строки, и существует вероятность конфликта значений первичного ключа.  
  
  
