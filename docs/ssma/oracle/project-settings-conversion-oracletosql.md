---
title: Параметры проекта (преобразование) (OracleToSQL) | Документация Майкрософт
description: Узнайте, как использовать страницу Преобразование диалогового окна "Параметры проекта" для настройки способа преобразования синтаксиса SSMA Oracle в синтаксис SQL Server.
author: nahk-ivanov
ms.prod: sql
ms.custom: ''
ms.date: 12/17/2020
ms.reviewer: ''
ms.technology: ssma
ms.topic: conceptual
ms.assetid: a98a5e07-eb5e-47b9-a6f2-e2cb3a18309c
ms.author: alexiva
ms.openlocfilehash: a999bcde42029b50772f18925a1f24432d558a3f
ms.sourcegitcommit: 8fcee1bc2503bea81a0c9d02827193ab71d8ca32
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/18/2021
ms.locfileid: "98564233"
---
# <a name="project-settings-conversion-oracletosql"></a>Параметры проекта (преобразование) (OracleToSQL)

На странице **Преобразование** диалогового окна **Параметры проекта** содержатся параметры, которые позволяют настроить SSMA преобразование синтаксиса Oracle в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] синтаксис.

Панель **преобразования** доступна в диалоговых окнах **Параметры проекта** и **Параметры проекта по умолчанию** .

- Чтобы задать параметры для всех проектов SSMA, в меню **Сервис** выберите пункт **Параметры проекта по умолчанию**, выберите тип проекта миграции, для которого необходимо просмотреть или изменить параметры в раскрывающемся списке **версия целевого объекта миграции** , а затем щелкните **Общие** в нижней части левой панели, а затем нажмите кнопку **Преобразование**.

- Чтобы указать параметры для текущего проекта, в меню **Сервис** выберите пункт **Параметры проекта**, затем щелкните **Общие** в нижней части левой панели, а затем щелкните **Преобразование**.

## <a name="built-in-functions-and-supplied-packages"></a>Встроенные функции и предоставляемые пакеты

|Термин|Определение|
|-|-|
|**Преобразуйте функцию COUNT в COUNT_BIG**|Если `COUNT` функции, скорее всего, возвращают значения, превышающие 2 147 483 647, что равно 2<sup>31</sup>-1, функции следует преобразовать в `COUNT_BIG` .<br /><br />Если выбрано **значение Да**, SSMA будет преобразовывать все варианты использования `COUNT` в `COUNT_BIG` .<br /><br />Если выбрано значение **нет**, функции будут сохраняться как `COUNT` . [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Если функция возвращает значение, большее 2<sup>31</sup>-1, будет возвращена ошибка.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или полный режим:** Да<br />**Оптимистичный режим:** Нет|
|**Преобразование вызовов функции substr в вызовы функций подстроки**|SSMA может преобразовывать `SUBSTR` вызовы функций Oracle в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `substring` вызовы функций в зависимости от числа параметров. Если SSMA не может преобразовать `SUBSTR` вызов функции или число параметров не поддерживается, то SSMA преобразует `SUBSTR` вызов функции в пользовательский вызов функции SSMA.<br /><br />Если выбрано **значение Да**, SSMA преобразует `SUBSTR` вызовы функций, в которых используется три параметра [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `substring` . Другие `SUBSTR` функции будут преобразованы для вызова пользовательской функции SSMA.<br /><br />Если выбрано значение **нет**, SSMA преобразует `SUBSTR` вызов функции в пользовательский вызов функции SSMA.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Да<br />**Полный режим:** Нет|
|**Преобразование вызовов функций TO_CHAR (Дата, формат)**|SSMA может преобразовать Oracle `TO_CHAR(date, format)` в процедуры из `ssma_oracle` схемы.<br /><br />Если выбрать **с помощью функции TO_CHAR_DATE**, SSMA преобразует `TO_CHAR(date, format)` функцию INTO `TO_CHAR_DATE` с использованием английского языка для преобразования.<br /><br />Если выбрать **с помощью функции TO_CHAR_DATE_LS (поддержка NLS)**, SSMA преобразует `TO_CHAR(date, format)` функцию INTO `TO_CHAR_DATE_LS` с помощью языка сеанса для преобразования.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Использование функции TO_CHAR_DATE<br />**Полный режим:** Использование функции TO_CHAR_DATE_LS (поддержка NLS)|
|**Создать ошибку для DBMS_SQL. ПРОАНАЛИЗИРОВАТЬ**|При выборе **ошибки** SSMA создает ошибку при преобразовании `DBMS_SQL.PARSE` .<br /><br />При выборе **предупреждения** SSMA создает предупреждение при преобразовании `DBMS_SQL.PARSE` .<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br />**По умолчанию/оптимистичный/полный режим:** План|
|**Использование функции ISNULL в вызовах функций CONCAT**|`ISNULL` оператор используется в `CONCAT` вызовах функций для эмуляции поведения Oracle. Для этого параметра имеются следующие параметры:<br /><br />YES<br /><br />NO<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Нет<br />**Полный режим:** Да|
|**Использование функции ISNULL в вызовах функций Replace**|`ISNULL` оператор используется в `REPLACE` вызовах функций для эмуляции поведения Oracle. Для этого параметра имеются следующие параметры:<br /><br />YES<br /><br />NO<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Нет<br />**Полный режим:** Да|
|**По возможности используйте собственную функцию CONVERT.**|Если выбрано **значение Да**, SSMA по `TO_CHAR(date, format)` возможности преобразует в собственную функцию CONVERT.<br /><br />Если выбрано значение **нет**, SSMA преобразует `TO_CHAR(date, format)` в `TO_CHAR_DATE` или `TO_CHAR_DATE_LS` (оно определяется параметрами **Convert TO_CHAR (Дата, формат)** ).<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Да<br />**Полный режим:** Нет|

## <a name="conversion-messages"></a>Сообщения о преобразовании

|Термин|Определение|
|-|-|
|**Создание сообщений о проблемах**|Указывает, создает ли SSMA информационные сообщения во время преобразования, отображает их в области вывода и добавляет их в преобразованный код.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Нет<br />**Полный режим:** Нет|

## <a name="miscellaneous-options"></a>Прочие параметры

|Термин|Определение|
|-|-|
|**Приведение выражений ROWNUM в качестве целых чисел**|Когда SSMA преобразует `ROWNUM` выражения, выражение преобразуется в `TOP` предложение, за которым следует выражение. В следующем примере показано `ROWNUM` в инструкции Oracle `DELETE` :<br /><br />`DELETE FROM Table1`<br />`WHERE ROWNUM < expression and Field1 >= 2`<br /><br />В следующем примере показан итоговый результат [!INCLUDE[tsql](../../includes/tsql-md.md)] :<br /><br />`DELETE TOP (expression-1)`<br />`FROM Table1`<br />`WHERE Field1>=2`<br /><br />`TOP`Для требуется, `TOP` чтобы выражение предложений было результатом вычисления целого числа. Если целое число отрицательное, инструкция вызовет ошибку.<br /><br />При выборе значения **Да** SSMA преобразует выражение в целое число.<br /><br />Если выбрано значение **нет**, SSMA помечает все Нецелочисленные выражения как ошибки в преобразованном коде.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или полный режим:** Нет<br />**Оптимистичный режим:** Да|  
|**Сопоставление схемы по умолчанию**|Этот параметр указывает, как схемы Oracle сопоставляются со схемами SQL Server. В этом параметре доступны два параметра:<br /><br />Из **схемы в базу данных:** В этом режиме схема Oracle `sch1` будет сопоставляться по умолчанию с `dbo` SQL Server схемой в базе данных SQL Server `sch1` .<br /><br />**Схема к схеме:** В этом режиме схема Oracle `sch1` будет сопоставляться по умолчанию с `sch1` SQL Server схемой в базе данных SQL Server по умолчанию, указанной в диалоговом окне соединения.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Из схемы в базу данных|
|**Эмуляция поведения Oracle NULL в предложениях ORDER BY**|`NULL` значения упорядочиваются по-разному в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и Oracle:<br /><br />В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `NULL` значения — это наименьшие значения в упорядоченном списке. В возрастающем списке `NULL` значения будут отображаться первыми.<br /><br />В Oracle `NULL` значения — это максимальные значения в упорядоченном списке. По умолчанию `NULL` значения отображаются последними в порядке возрастания.<br /><br />Oracle содержит `NULLS FIRST` `NULLS LAST` предложения and, которые позволяют изменить порядок заказов Oracle `NULL` .<br /><br />SSMA может эмулировать поведение Oracle `ORDER BY` , проверяя `NULL` значения. Затем он сначала упорядочивает по `NULL` значениям в указанном порядке, а затем упорядочивает по другим значениям.<br /><br />Если выбрать **Да**, SSMA будет преобразовывать инструкцию Oracle таким образом, чтобы эмулировать поведение Oracle `ORDER BY` .<br /><br />Если выбрано значение **нет**, SSMA пропустит правила Oracle и выдаст сообщение об ошибке при обнаружении `NULLS FIRST` `NULLS LAST` предложений и.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Нет<br />**Полный режим:** Да|
|**Имитация числа исключений строк в SELECT**|Если `SELECT` инструкция с предложением INTO не возвращает никаких строк, Oracle создает `NO_DATA_FOUND` исключение. Если инструкция возвращает две или более строк, `TOO_MANY_ROWS` возникает исключение. Преобразованная инструкция в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не вызывает исключение, если число строк отличается от значения.<br /><br />Если выбрано **значение Да**, SSMA добавляет вызов специальной `db_error_exact_one_row_check` процедуры после каждой `SELECT` инструкции. Эта процедура эмулирует `NO_DATA_FOUND` `TOO_MANY_ROWS` исключения и. Это значение по умолчанию, которое позволяет воспроизвести поведение Oracle как можно ближе. Всегда выбирайте **Да** , если в исходном коде есть обработчики исключений, которые обрабатывают эти ошибки. Обратите внимание, что если `SELECT` инструкция выполняется внутри определяемой пользователем функции, этот модуль будет преобразован в хранимую процедуру, так как при выполнении хранимых процедур и вызове исключений он не совместим с [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] контекстом функции.<br /><br />Если выбрано значение **нет**, исключения не создаются. Это может быть полезно, когда SSMA преобразует определяемую пользователем функцию и требуется, чтобы она оставалась в функции [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Включить помощник по исправлению**|Если этот параметр включен, SSMA попытается изучить изменения, внесенные в целевой код T-SQL, и предложит потенциальные исправления кода в других местах, где можно применить аналогичную схему.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Создать псевдонимы столбцов константных выражений**|Если в выражении в `SELECT` списке отсутствует псевдоним, SSMA может создать константный псевдоним (например `expr1` , и `expr2` т. д.) или использовать само выражение в качестве псевдонима. Поскольку выражения могут иметь довольно много времени, а длина имени столбца ограничена, для таких псевдонимов безопаснее использовать постоянное базовое имя. Несмотря на то, что это более безопасный вариант, иногда это невозможно, так как в результирующем наборе данных могут быть внешние зависимости. В таких случаях может потребоваться именование столбцов в соответствии с выражениями значений, аналогично поведению Oracle.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Да<br />**Полный режим:** Нет|
|**Опустить расширенные свойства**|Если этот параметр включен, SSMA не будет добавлять расширенные свойства в объекты, создаваемые в целевой базе данных.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Нет|
|**Коды ошибок преобразования**|Если этот параметр включен, номер ошибки на целевой SQL Server стороне будет преобразован в код ошибки Oracle, если сопоставление найдено.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или полный режим:** Да<br />**Оптимистичный режим:** Нет|
|**Использовать полную спецификацию типа для ссылок на типы**|Если этот параметр включен, SSMA будет учитывать полную спецификацию типа (включая масштаб и точность) для параметров подпрограмм и возвращаемых значений. Oracle не допускает аргументы типа данных для параметров подпрограмм, но бывают случаи, когда они могут быть неявно производными, например при `%TYPE` `%ROWTYPE` использовании атрибутов и. В таких случаях SSMA может использовать полную спецификацию типа (включая точность и масштаб) при преобразовании в SQL Server.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Да<br />**Полный режим:** Нет|
|**Использование функции ISNULL при сцеплении строк**|Oracle и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] возвращают различные результаты, если сцепление строк включает `NULL` значения. Oracle воспринимает это `NULL` значение как пустой набор символов. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] возвращает `NULL`.<br /><br />Если выбрано **значение Да**, SSMA заменяет символ объединения Oracle (&#124;&#124;) [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] символом конкатенации (+). SSMA также проверяет выражения по обеим сторонам объединения `NULL` значений.<br /><br />Если выбрано значение **нет**, SSMA заменяет символы объединения, но не проверяет `NULL` значения.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|

## <a name="objects-conversion"></a>Преобразование объектов

|Термин|Определение|
|-|-|
|**Преобразование внешних ключей с ссылочным действием SET NULL для столбца, не имеющего значение NULL**|Oracle позволяет создавать ограничения внешнего ключа, в которых `SET NULL` действие, возможно, не было выполнено, так как в упоминаемом столбце не разрешены значения NULL. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не допускает такую конфигурацию внешнего ключа.<br /><br />Если выбрано **значение Да**, SSMA создаст ссылочные действия как в Oracle, но необходимо внести изменения вручную перед загрузкой ограничения на [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Например, можно выбрать `NO ACTION` вместо `SET NULL` .<br /><br />Если выбрано значение **нет**, ограничение будет отмечено как ошибка.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Нет|
|**Преобразовать подтипы**|SSMA может преобразовать подтипы PL/SQL двумя способами:<br /><br />Если выбрать **Да**, SSMA создаст [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] определяемый пользователем тип из подтипа и будет использовать его для каждой переменной этого подтипа.<br /><br />Если выбрано значение **нет**, SSMA заменит все исходные объявления подтипа базовым типом и преобразует результат как обычно. В этом случае дополнительные типы не создаются в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Нет|
|**Преобразовать синонимы**|Синонимы для следующих объектов Oracle можно перенести в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] :<br /><br />Таблицы и таблицы объектов<br /><br />Представления и представления объектов<br /><br />Хранимые процедуры и функции<br /><br />материализованные представления;<br /><br />**Синонимы для следующего** Объекты Oracle могут быть заменены прямыми ссылками на объекты:<br /><br />Последовательности<br /><br />Пакеты<br /><br />Объекты схемы классов Java<br /><br />Определяемые пользователем типы объектов<br /><br />Другие синонимы не могут быть перенесены. SSMA создаст сообщения об ошибках для синонима и всех ссылок, использующих этот синоним.<br /><br />Если выбрано **значение Да**, SSMA создаст [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] синонимы и прямые ссылки на объекты в соответствии с предыдущими списками.<br /><br />Если выбрано значение **нет**, SSMA создаст прямые ссылки на объекты для всех синонимов, перечисленных здесь.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Преобразование локальных модулей**|Определяет тип вложенной программы Oracle (объявленной в автономной хранимой процедуре или функции).<br /><br />Если выбрать **встроенное**, вложенные вызовы подпрограммы будут заменены текстом.<br /><br />При выборе **хранимых процедур** вложенная подпрограмма будет преобразована в SQL Server хранимая процедура, а ее вызовы будут заменены на этот вызов процедуры.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Встроенные|

## <a name="records-conversion"></a>Преобразование записей

|Термин|Определение|
|-|-|
|**Преобразовать запись в список разделенных переменных**|SSMA может преобразовать записи Oracle в отдельные переменные и в переменные XML с определенной структурой.<br /><br />Если выбрано **значение Да**, SSMA по возможности преобразует запись в список разделенных переменных.<br /><br />Если выбрано значение **нет**, SSMA преобразует запись в переменные XML с определенной структурой.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Используйте SELECT... FOR XML при преобразовании SELECT... В для переменной записи**|Указывает, следует ли создавать результирующий набор XML при выборе в переменной записи.<br /><br />При нажатии **кнопки Да** инструкция SELECT возвращает XML.<br /><br />Если выбрано значение **нет**, то инструкция SELECT возвращает результирующий набор.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Нет|

## <a name="returning-clause-conversion"></a>Преобразование предложения возврата

|Термин|Определение|
|-|-|
|**Преобразование ВОЗВРАЩАЕМого предложения в инструкцию DELETE для вывода**|Oracle предоставляет `RETURNING` предложение в качестве способа немедленного получения удаленных значений. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] предоставляет эту функциональность с помощью `OUTPUT` предложения.<br /><br />Если выбрать **Да**, SSMA будет преобразовывать `RETURNING` предложения в `DELETE` выражениях в `OUTPUT` предложения. Поскольку триггеры в таблице могут изменять значения, возвращаемое значение может отличаться в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сравнении с Oracle.<br /><br />Если выбрать **нет**, SSMA создаст `SELECT` инструкцию перед `DELETE` инструкциями для получения возвращаемых значений.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Преобразование предложения RETURN в инструкцию INSERT для вывода**|Oracle предоставляет `RETURNING` предложение как способ немедленного получения вставленных значений. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] предоставляет эту функциональность с помощью `OUTPUT` предложения.<br /><br />Если выбрать **Да**, то SSMA преобразует `RETURNING` предложение в `INSERT` операторе в `OUTPUT` . Поскольку триггеры в таблице могут изменять значения, возвращаемое значение может отличаться в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сравнении с Oracle.<br /><br />Если выбрано значение **нет**, SSMA эмулирует функциональность Oracle, вставляя и выбирая значения из ссылочной таблицы.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Преобразование предложения RETURN в инструкции UPDATE в OUTPUT**|Oracle предоставляет `RETURNING` предложение в качестве способа немедленного получения обновленных значений. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] предоставляет эту функциональность с помощью `OUTPUT` предложения.<br /><br />Если выбрать **Да**, SSMA будет преобразовывать `RETURNING` предложения в `UPDATE` выражениях в `OUTPUT` предложения. Поскольку триггеры в таблице могут изменять значения, возвращаемое значение может отличаться в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сравнении с Oracle.<br /><br />Если выбрано значение **нет**, SSMA СОЗДАСТ инструкции SELECT после `UPDATE` инструкций для получения возвращаемых значений.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|

## <a name="rowid-generation"></a>Создание ROWID

|Термин|Определение|
|-|-|
|**Создать столбец ROWID**|Когда SSMA создает таблицы в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , он может создать столбец ROWID. При переносе данных каждая строка получает новое `UNIQUEIDENTIFIER` значение, созданное `newid()` функцией.<br /><br />Если выбрано **значение Да**, `ROWID` столбец создается во всех таблицах и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] создает идентификаторы GUID при вставке значений. Всегда выбирайте **Да** , если вы планируете использовать тест-инженер SSMA.<br /><br />Если выбрано значение **нет**, столбцы ROWID не добавляются в таблицы.<br /><br />**Добавление СТОЛБЦА ROWID для таблиц с триггерами** добавить `ROWID` для таблиц, содержащих триггеры.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Добавление столбца ROWID для таблиц с триггерами<br /><br />**Полный режим:** Да|
|**Создать уникальный индекс для столбца ROWID**|Указывает, создает ли SSMA столбец уникального индекса в `ROWID` созданном столбце. Если для параметра задано значение "YES", создается уникальный индекс и, если для него задано значение "нет", для столбца не создается уникальный индекс `ROWID` .<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|

## <a name="sequence-and-identity-conversion"></a>Преобразование последовательности и удостоверения

|Термин|Определение|
|-|-|
|**Преобразовать удостоверение как**|Oracle предоставляет несколько параметров конфигурации для столбцов идентификаторов. Некоторые из этих параметров не поддерживаются функцией идентификации в SQL Server.<br /><br />Метод сохранения этих параметров заключается в преобразовании Identity в последовательность.<br /><br />Если выбрать **Sequence**, столбцы идентификаторов Oracle больше не будут преобразованы в столбцы идентификаторов SQL. Вместо этого создается последовательность, которая будет использоваться для создания значений по умолчанию для столбца.<br /><br />При выборе **Identity** столбцы Oracle Identity будут преобразованы в столбцы идентификаторов SQL. Неподдерживаемые параметры не будут преобразованы. <br /><br />Если выбрать вариант **оптимально**, SSMA определит оптимальный метод преобразования (идентификатор или последовательность) в зависимости от конфигурации столбца идентификаторов Oracle.|
|**Генератор последовательности преобразований**|В Oracle для создания уникальных идентификаторов можно использовать последовательность.<br /><br />SSMA может преобразовывать последовательности в следующие.<br /><br />Использование генератора последовательностей SQL Server.<br /><br />Использование генератора последовательностей SSMA.<br /><br />Использование удостоверения столбца.<br /><br />Параметр по умолчанию — использовать генератор последовательностей SQL Server. Однако SQL Server не поддерживает получение текущего значения последовательности (например, метода последовательности Oracle `CURRVAL` ). Инструкции по переносу метода последовательности Oracle см. на веб-сайте блогов группы SSMA `CURRVAL` .<br /><br />SSMA также предоставляет возможность преобразования последовательности Oracle в эмулятор SSMA Sequence. Этот параметр используется по умолчанию при преобразовании в SQL Server до 2012.<br /><br />Наконец, можно также преобразовать последовательность, назначенную столбцу в таблице, для SQL Server значений идентификаторов. Необходимо указать сопоставление между последовательностями и столбцом идентификаторов на вкладке **таблицы** Oracle.|
|**Преобразование КУРРВАЛ внешних триггеров**|Отображается, только если для **генератора последовательностей преобразования** задано **Использование удостоверения столбца**. Так как последовательности Oracle являются объектами, отделенными от таблиц, многие таблицы, использующие последовательности, используют триггер для создания и вставки нового значения последовательности. SSMA закомментируйте эти инструкции или помечает их как ошибки, когда комментарии будут формировать ошибки.<br /><br />Если выбрать **Да**, SSMA пометит все ссылки на внешние триггеры в преобразованной последовательности `CURRVAL` с предупреждением.<br /><br />Если выбрано значение **нет**, SSMA помечает все ссылки на внешние триггеры в преобразованной последовательности `CURRVAL` с ошибкой.|

## <a name="statements-conversion"></a>Преобразование операторов

|Термин|Определение|
|-|-|
|**Преобразование инструкции MERGE**|Если выбрать **Использование инструкций INSERT, Update, DELETE**, SSMA преобразует `MERGE` оператор в `INSERT` инструкции, `UPDATE` , `DELETE`<br /><br />При выборе **с помощью инструкции MERGE** инструкция SSMA преобразует `MERGE` оператор в `MERGE` инструкцию в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Использование инструкции MERGE|
|**Преобразовывать вызовы в подпрограммы, использующие аргументы по умолчанию**|[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] функции не поддерживают пропуск параметров в вызове функции. Кроме того, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] функции и процедуры не поддерживают выражения в качестве значений параметров по умолчанию.<br /><br />Если выбрано **значение Да** , а в вызове функции опущены параметры, SSMA вставит ключевое слово **Default** в функцию и выполнит вызов в правильном положении. После этого вызов будет помечен предупреждением.<br /><br />Если выбрано значение **нет**, SSMA помечает вызовы функции как ошибки.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Преобразование инструкции FORALL в инструкцию WHILE**|Определяет, как SSMA будет обрабатывать `FORALL` циклы в элементах коллекции PL/SQL.<br /><br />Если выбрано **значение Да**, SSMA создает `WHILE` цикл, где элементы коллекции извлекаются по одному.<br /><br />Если выбрано значение **нет**, SSMA создает набор строк из коллекции с помощью `nodes()` метода и использует его в качестве одной таблицы. Это более эффективно, но делает код более удобочитаемым.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию или оптимистичный режим:** Нет<br />**Полный режим:** Да|
|**Преобразование вызовов функций в вызовы процедур**|Некоторые функции Oracle определяются как автономные транзакции или содержат инструкции, которые не являются допустимыми в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . В этих случаях SSMA создает процедуру и функцию, которая является оболочкой для процедуры. Преобразованная функция вызывает реализацию процедуры.<br /><br />SSMA может преобразовывать вызовы функции-оболочки в вызовы процедуры. Это создает более удобочитаемый код и может повысить производительность. Однако контекст не всегда разрешает его; Например, нельзя заменить вызов функции в `SELECT` списке вызовом процедуры. SSMA имеет несколько вариантов для охвата распространенных случаев.<br /><br />Если выбрано значение **Always**, SSMA пытается преобразовать вызовы функции-оболочки в вызовы процедур. Если текущий контекст не допускает такого преобразования, выдается сообщение об ошибке. В этом случае вызовы функций не будут оставлены в созданном коде.<br /><br />Если вы выберете, **когда это возможно**, SSMA вызовет процедуру перехода к процедуре только в том случае, если функция имеет выходные параметры. Если перемещение невозможно, то выходной атрибут параметра удаляется. Во всех остальных случаях SSMA оставляет вызовы функций.<br /><br />Если выбрать значение **никогда**, SSMA оставляет все вызовы функций в виде вызовов функций. Иногда этот вариант может оказаться неприемлемым по соображениям производительности.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** По возможности|
|**Преобразовать операторы блокировки таблицы**|SSMA может преобразовать многие `LOCK TABLE` инструкции в Табличные указания. SSMA не может преобразовать `LOCK TABLE` инструкции, содержащие `PARTITION` `SUBPARTITION` предложения,, `@dblink` и `NOWAIT` , и будет помечать такие инструкции с сообщениями об ошибках преобразования.<br /><br />Если выбрать **Да**, SSMA будет преобразовывать поддерживаемые `LOCK TABLE` инструкции в Табличные указания.<br /><br />Если выбрано значение **нет**, SSMA помечает все `LOCK TABLE` инструкции с сообщениями об ошибках преобразования.<br /><br />В следующей таблице показано, как SSMA преобразует режимы блокировки Oracle.<br /><br />**Режим блокировки Oracle**<br /><br />`ROW SHARE`<br />`ROW EXCLUSIVE`<br />`SHARE UPDATE = ROW SHARE`<br />`SHARE`<br />`SHARE`<br />`EXCLUSIVE`<br /><br />**SQL Server табличное указание**<br /><br />`ROWLOCK, HOLDLOCK`<br />`ROWLOCK, XLOCK, HOLDLOCK`<br />`ROWLOCK, HOLDLOCK`<br />`TABLOCK, HOLDLOCK`<br />`TABLOCK, XLOCK, HOLDLOCK`<br />`TABLOCKX, HOLDLOCK`<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Преобразовать операторы OPEN-FOR для параметров OUT для REF CURSOR**|В Oracle `OPEN .. FOR` инструкция может быть использована для возвращения результирующего набора `OUT` параметру подпрограммы типа `REF CURSOR` . В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранимые процедуры непосредственно возвращают результаты `SELECT` инструкций.<br /><br />SSMA может преобразовать многие `OPEN .. FOR` инструкции в `SELECT` инструкции.<br /><br />Если выбрать **Да**, SSMA преобразует `OPEN .. FOR` инструкцию в `SELECT` инструкцию, которая возвращает результирующий набор клиенту.<br /><br />Если выбрано значение **нет**, SSMA выдаст сообщение об ошибке в преобразованном коде и в области вывода.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|
|**Преобразование инструкций обработки транзакций**|SSMA может преобразовывать инструкции обработки транзакций Oracle:<br /><br />Если выбрано **значение Да**, SSMA преобразует инструкции обработки транзакций Oracle в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] инструкции.<br /><br />Если выбрано значение **нет**, SSMA помечает инструкции обработки транзакций как ошибки преобразования.<br /><br />**Примечание.** Oracle открывает транзакции неявным образом. Чтобы эмулировать такое поведение в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , необходимо вручную добавить инструкции, в `BEGIN TRANSACTION` которых должны запускаться транзакции. Кроме того, можно выполнить `SET IMPLICIT_TRANSACTIONS ON` команду в начале сеанса. SSMA автоматически добавляется `SET IMPLICIT_TRANSACTIONS ON` при преобразовании подпрограмм с автономными транзакциями.<br /><br />При выборе режима преобразования в поле **режим** SSMA применяет следующий параметр:<br /><br />**По умолчанию/оптимистичный/полный режим:** Да|

## <a name="see-also"></a>См. также:

[Справочник по пользовательскому интерфейсу (OracleToSQL)](../../ssma/oracle/user-interface-reference-oracletosql.md)
