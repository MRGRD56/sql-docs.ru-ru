---
description: SELECT (команда SQL)
title: SELECT-SQL, команда | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
helpviewer_keywords:
- select [ODBC]
ms.assetid: 2149c3ca-3a71-446d-8d53-3d056e2f301a
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 3fc6ae552bc4e6e8bd681aa3d47ffadeaf81fd0a
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99153522"
---
# <a name="select---sql-command"></a>SELECT (команда SQL)
Извлекает данные из одной или нескольких таблиц.  
  
 Драйвер ODBC для Visual FoxPro поддерживает для этой команды собственный синтаксис языка Visual FoxPro. Сведения, относящиеся к драйверу, см. в разделе **Примечания к драйверам**.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SELECT [ALL | DISTINCT]  
   [Alias.] Select_Item [AS Column_Name]  
   [, [Alias.] Select_Item [AS Column_Name] ...]   
FROM [DatabaseName!]Table [Local_Alias]  
   [, [DatabaseName!]Table [Local_Alias] ...]   
[WHERE JoinCondition [AND JoinCondition  
...]  
   [AND | OR FilterCondition [AND | OR FilterCondition ...]]]  
[GROUP BY GroupColumn [, GroupColumn ...]]  
[HAVING FilterCondition]  
[UNION [ALL] SELECTCommand]  
[ORDER BY Order_Item [ASC | DESC] [, Order_Item [ASC | DESC] ...]]  
```  
  
## <a name="arguments"></a>Аргументы  
  
> [!NOTE]  
>  Вложенный *запрос*, который называется в следующих аргументах, является SELECT внутри SELECT и должен быть заключен в круглые скобки. В предложении WHERE можно использовать до двух вложенных запросов на одном и том же уровне. (См. Этот раздел аргументов.) Вложенные запросы могут содержать несколько условий объединения.  
  
 [ВСЕ &#124; DISTINCT]   [*Alias*.] *Select_Item* [как *Column_Name*] [, [*Alias*.] *Select_Item* [как *Column_Name*]...]  
 В предложении SELECT указываются поля, константы и выражения, отображаемые в результатах запроса.  
  
 По умолчанию все строки отображаются в результатах запроса.  
  
 DISTINCT исключает повторяющиеся строки из результатов запроса.  
  
> [!NOTE]  
>  Предложение DISTINCT можно использовать только один раз для каждого предложения SELECT.  
  
 *Псевдоним*. Определяет совпадающие имена элементов. Каждый элемент, указанный с помощью *Select_Item* , создает один столбец результатов запроса. Если два или более элемента имеют одно и то же имя, включите псевдоним таблицы и точку перед именем элемента, чтобы предотвратить дублирование столбцов.  
  
 *Select_Item* указывает элемент, включаемый в результаты запроса. Элемент может быть одним из следующих:  
  
-   Имя поля из таблицы в предложении FROM.  
  
-   Константа, указывающая, что одно и то же значение константы будет отображаться в каждой строке результатов запроса.  
  
-   Выражение, которое может быть именем определяемой пользователем функции.  
  
 **Определяемые пользователем функции с помощью SELECT**  
  
 Хотя использование определяемых пользователем функций в предложении SELECT имеет очевидные преимущества, следует учитывать следующие ограничения.  
  
-   Скорость операций, выполняемых с помощью инструкции SELECT, может быть ограничена скоростью, с которой выполняются такие определяемые пользователем функции. Большие объемы операций, включающие определяемые пользователем функции, могут быть лучше выполнены с помощью API и определяемых пользователем функций, написанных на языке C или языка ассемблера.  
  
-   Единственным надежным способом передачи значений определяемым пользователем функциям, вызываемым из SELECT, является список аргументов, передаваемый функции при ее вызове.  
  
-   Даже если вы поэкспериментируем и обнаружите предполагаемо запрещенную манипуляцию, которая правильно работает в определенной версии FoxPro, нет гарантии, что она будет продолжать работать в более поздних версиях.  
  
 Помимо этих ограничений, определяемые пользователем функции допустимы в предложении SELECT. Однако помните, что использование SELECT может привести к снижению производительности.  
  
 Следующие функции полей доступны для использования с элементом SELECT, который является полем или выражением, включающим поле:  
  
-   AVG (*Select_Item*) — среднее значение столбца числовых данных.  
  
-   COUNT (*Select_Item*) — подсчитывает количество выбранных элементов в столбце. COUNT (*) подсчитывает количество строк в выходных данных запроса.  
  
-   MIN (*Select_Item*) — определяет наименьшее значение *Select_Item* в столбце.  
  
-   MAX (*Select_Item*) — определяет наибольшее значение *Select_Item* в столбце.  
  
-   SUM (*Select_Item*) — суммирует столбец с числовыми данными.  
  
 Нельзя вкладывать функции полей.  
  
 КАК *Column_Name*  
 Задает заголовок для столбца в выходных данных запроса. Это полезно, если *Select_Item* является выражением или содержит функцию поля, и необходимо присвоить столбцу понятное имя. *Column_Name* может быть выражением, но не может содержать символы (например, пробелы), недопустимые в именах полей таблицы.  
  
 FROM [*DatabaseName*!] *Table* [*Local_Alias*] [, [*DatabaseName*!] *Таблица* [*Local_Alias*]...]  
 Список таблиц, содержащих данные, получаемые запросом. Если таблица не открыта, Visual FoxPro выводит диалоговое окно **Открыть** , чтобы можно было указать расположение файла. После открытия таблица остается открытой после завершения запроса.  
  
 *DatabaseName*! Указывает имя базы данных, отличной от указанной в источнике данных. Если база данных не указана в источнике данных, необходимо включить имя базы данных, содержащей таблицу. Включите разделитель восклицательного знака (!) после имени базы данных и перед именем таблицы.  
  
 *Local_Alias* указывает временное имя для таблицы с именем в *таблице*. При указании локального псевдонима в инструкции SELECT необходимо использовать локальный псевдоним вместо имени таблицы. Локальный псевдоним не влияет на среду Visual FoxPro.  
  
 ГДЕ *жоинкондитион* [и *жоинкондитион* ...]    [AND &#124; или *филтеркондитион* [and &#124; или *филтеркондитион* ...]]  
 Указывает Visual FoxPro включать в результаты запроса только определенные записи. ГДЕ требуется для получения данных из нескольких таблиц.  
  
 *Жоинкондитион* указывает поля, связывающие таблицы в предложении FROM. Если в запросе включено более одной таблицы, необходимо указать условие объединения для каждой таблицы после первой.  
  
> [!IMPORTANT]  
>  При создании условий объединения учитывайте следующие сведения.  
  
-   Если включить в запрос две таблицы и не указать условие соединения, каждая запись в первой таблице присоединяется к каждой записи во второй таблице при условии, что условия фильтра выполнены. Такой запрос может привести к созданию длительных результатов.  
  
-   Будьте внимательны при соединении таблиц с пустыми полями, так как Visual FoxPro соответствует пустым полям. Например, если вы присоединяетесь к CUSTOMER.ZIP и INVOICE.ZIP и если клиент содержит 100 пустых почтовых индексов, а счет содержит 400 пустых почтовых индексов, то выходные данные запроса содержат 40 000 лишние записи, полученные в результате пустых полей. Используйте функцию **Empty ()** для исключения пустых записей из выходных данных запроса.  
  
-   Для подключения нескольких условий соединения необходимо использовать оператор AND. Каждое условие объединения имеет следующий вид:  
  
     *Сравнение FieldName1 FieldName2*  
  
     *FieldName1* — это имя поля из одной таблицы, *FieldName2* — имя поля из другой таблицы, а *Сравнение* — один из операторов, описанных в следующей таблице.  
  
|Оператор|Сравнение|  
|--------------|----------------|  
|=|Равно|  
|==|Точно равно|  
|LIKE|SQL LIKE|  
|<>,! =, #|Не равно|  
|>|Более чем|  
|>=|Больше или равно|  
|<|Меньше чем|  
|<=|Меньше или равно|  
  
 При использовании оператора = со строками он действует по-разному, в зависимости от значения параметра SET ANSI. Если параметру SET ANSI присвоено значение OFF, Visual FoxPro обрабатывает сравнения строк способом, привычным для пользователей xbase. Если для параметра SET ANSI задано значение ON, то Visual FoxPro использует стандарты ANSI для сравнения строк. Дополнительные сведения о том, как Visual FoxPro выполняет сравнение строк, см. в разделе [Set ANSI](../../odbc/microsoft/set-ansi-command.md) и [Set СОВПАД](../../odbc/microsoft/set-exact-command.md) .  
  
 *Филтеркондитион* указывает критерии, которым должны соответствовать записи для включения в результаты запроса. В запрос можно включить любое количество условий фильтра, подключив их к оператору AND или or. Можно также использовать оператор NOT для изменения значения логического выражения или можно использовать **Empty ()** для проверки пустого поля. *Филтеркондитион* может принимать любую из форм в следующих примерах:  
  
 **Пример 1** . *Сравнение FieldName1 FieldName2*  
  
 `customer.cust_id = orders.cust_id`  
  
 **Пример 2** *выражение сравнения FieldName*  
  
 `payments.amount >= 1000`  
  
 **Пример 3** . *Сравнение с FieldName* ALL (*вложенный запрос*)  
  
 `company < ALL ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Если условие фильтра включает все значения, поле должно соответствовать условию сравнения для всех значений, созданных вложенным запросом, прежде чем его запись будет включена в результаты запроса.  
  
 **Пример 4** . *сравнение с FieldName* &#124; часть (*вложенный запрос*)  
  
 `company < ANY ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Если условие фильтра включает ANY или SOME, поле должно соответствовать условию сравнения по крайней мере для одного из значений, создаваемых вложенным запросом.  
  
 В следующем примере проверяется, находятся ли значения в поле в указанном диапазоне значений.  
  
 **Пример 5** *fieldname* [NOT] между *Start_Range* и *End_Range*  
  
 `customer.postalcode BETWEEN 90000 AND 99999`  
  
 В следующем примере проверяется, соответствует ли хотя бы одна строка критериям вложенного запроса. Если условие фильтра содержит, условие фильтра принимает значение true (. T.), если только вложенный запрос не возвращает пустой набор.  
  
 **Пример 6** [NOT] Exists (*вложенный запрос*)  
  
 `EXISTS ;`  
  
 `(SELECT * FROM orders WHERE customer.postalcode =`  
  
 `orders.postalcode)`  
  
 **Пример 7** *fieldname* [NOT] в *Value_Set*  
  
 `customer.postalcode NOT IN ("98052","98072","98034")`  
  
 Когда условие фильтра включает в, поле должно содержать одно из значений, прежде чем запись будет включена в результаты запроса.  
  
 **Пример 8** *fieldname* [не] in (*вложенный запрос*)  
  
 `customer.cust_id IN ;`  
  
 `(SELECT orders.cust_id FROM orders WHERE orders.city="Seattle")`  
  
 В этом случае поле должно содержать одно из значений, возвращаемых вложенным запросом, прежде чем его запись будет включена в результаты запроса.  
  
 **Пример 9** *fieldname* [NOT], например *цекспрессион*  
  
 `customer.country NOT LIKE "USA"`  
  
 Это условие фильтра выполняет поиск каждого поля, соответствующего *цекспрессион*. Можно использовать знак процента (%) и символы-шаблоны подчеркивания (_) в составе *цекспрессион*. Символ подчеркивания представляет один неизвестный символ в строке.  
  
 GROUP BY *граупколумн* [, *граупколумн* ...]  
 Группирует строки в запросе на основе значений в одном или нескольких столбцах. *Граупколумн* может быть одним из следующих:  
  
-   Имя регулярного поля таблицы.  
  
-   Поле, включающее функцию поля SQL.  
  
-   Числовое выражение, указывающее расположение столбца в таблице результатов. (Самый левый номер столбца — 1.)  
  
 НАЛИЧИЕ *филтеркондитион*  
 Указывает условие фильтра, которому должны соответствовать группы для включения в результаты запроса. HAVING следует использовать с оператором GROUP BY и может включать столько условий фильтра, сколько требуется, с соединением оператора AND или or. Можно также использовать NOT для отмены значения логического выражения.  
  
 *Филтеркондитион* не может содержать вложенный запрос.  
  
 Предложение HAVING без предложения GROUP BY ведет себя как предложение WHERE. В предложении HAVING можно использовать локальные псевдонимы и функции полей. Используйте предложение WHERE для повышения производительности, если предложение HAVING не содержит функций полей.  
  
 [UNION [все] *SELECTCommand*]  
 Объединяет окончательные результаты одного выбора с окончательными результатами другого выбора. По умолчанию объединение проверяет объединенные результаты и удаляет дублирующиеся строки. Используйте круглые скобки для объединения нескольких предложений UNION.  
  
 ВСЕ предотвращает удаление повторяющихся строк из Объединенных результатов.  
  
 Предложения UNION следуют следующим правилам.  
  
-   Нельзя использовать UNION для объединения вложенных запросов.  
  
-   Обе команды SELECT должны иметь одинаковое число столбцов в выходных данных запроса.  
  
-   Каждый столбец в результатах одного запроса SELECT должен иметь тот же тип данных и ширину, что и соответствующий столбец в другом запросе SELECT.  
  
-   Только окончательный вариант SELECT может иметь предложение ORDER BY, которое должно ссылаться на выходные столбцы по номеру. Если предложение ORDER BY включено, оно влияет на полный результат.  
  
 Можно также использовать предложение UNION для имитации внешнего соединения.  
  
 При соединении двух таблиц в запросе в выходные данные включаются только записи с совпадающими значениями в соединяемых полях. Если запись в родительской таблице не имеет соответствующей записи в дочерней таблице, то запись в родительской таблице не включается в выходные данные. Внешнее соединение позволяет включать в выходные данные все записи родительской таблицы вместе с соответствующими записями в дочерней таблице. Чтобы создать внешнее соединение в Visual FoxPro, необходимо использовать вложенную команду SELECT, как показано в следующем примере:  
  
```  
SELECT customer.company, orders.order_id, orders.emp_id ;  
FROM customer, orders ;  
WHERE customer.cust_id = orders.cust_id ;  
UNION ;  
SELECT customer.company, 0, 0 ;  
FROM customer ;  
WHERE customer.cust_id NOT IN ;  
(SELECT orders.cust_id FROM orders)  
```  
  
> [!NOTE]  
>  Убедитесь, что вы включили пробел, расположенный непосредственно перед каждой точкой с запятой. В противном случае появится сообщение об ошибке.  
  
 Раздел команды перед предложением UNION выбирает записи из обеих таблиц с совпадающими значениями. Клиентские компании, не имеющие связанных счетов, не включаются. Раздел команды после предложения UNION выбирает записи в таблице Customer, которые не имеют совпадающих записей в таблице Orders.  
  
 В отношении второго раздела команды Обратите внимание на следующее:  
  
-   Сначала обрабатывается инструкция SELECT в круглых скобках. Эта инструкция создает выборку всех номеров клиентов в таблице Orders.  
  
-   Предложение WHERE находит все номера клиентов в таблице Customer, которых нет в таблице Orders. Поскольку первый раздел команды предоставляет все компании с номером клиента в таблице Orders, все компании в таблице Customer теперь включаются в результаты запроса.  
  
-   Поскольку структуры таблиц, включаемых в объединение, должны быть идентичны, в второй инструкции SELECT есть два заполнителя для представления *Orders.order_id* и *Orders.emp_id* из первой инструкции SELECT.  
  
    > [!NOTE]  
    >  Заполнители должны быть того же типа, что и поля, которые они представляют. Если поле имеет тип Date, заполнитель должен быть {//}. Если поле является полем символов, заполнитель должен быть пустой строкой ("").  
  
 ORDER BY *Order_Item* [ASC &#124; desc] [, *Order_Item* [ASC &#124; desc]...]  
 Сортирует результаты запроса на основе данных в одном или нескольких столбцах. Каждый *Order_Item* должен соответствовать столбцу в результатах запроса и может быть одним из следующих:  
  
-   Поле в таблице из таблицы, которое также является элементом SELECT в главном предложении SELECT (не во вложенном запросе).  
  
-   Числовое выражение, указывающее расположение столбца в таблице результатов. (Крайний левый столбец — номер 1.)  
  
 ASC задает порядок возрастания результатов запроса в соответствии с элементом или элементами заказа и является значением по умолчанию для ORDER BY.  
  
 DESC задает порядок по убыванию для результатов запроса.  
  
 Результаты запроса отображаются неупорядоченными, если порядок не указан с помощью предложения ORDER BY.  
  
## <a name="remarks"></a>Замечания  
 SELECT — это команда SQL, встроенная в Visual FoxPro, как и любая другая команда Visual FoxPro. При использовании SELECT для представления запроса Visual FoxPro интерпретирует запрос и извлекает указанные данные из таблиц. Запрос SELECT можно создать либо в окне командной строки, либо в программе Visual FoxPro (как и в любой другой команде Visual FoxPro).  
  
> [!NOTE]  
>  SELECT не учитывает текущее условие фильтра, указанное с помощью SET FILTER.  
  
## <a name="driver-remarks"></a>Примечания к драйверам  
 Когда приложение отправляет инструкцию ODBC SQL SELECT в источник данных, драйвер ODBC для Visual FoxPro преобразует команду в команду Visual FoxPro SELECT без преобразования, если команда не содержит escape-последовательность ODBC. Элементы, заключенные в escape-последовательность ODBC, преобразуются в синтаксис Visual FoxPro. Дополнительные сведения об использовании escape-последовательностей ODBC см. в разделе [функции времени и даты](../../odbc/microsoft/time-and-date-functions-visual-foxpro-odbc-driver.md) , а также в *справочнике программиста Microsoft ODBC* см. [в разделе Escape-последовательности в ODBC](../../odbc/reference/develop-app/escape-sequences-in-odbc.md).  
  
## <a name="see-also"></a>См. также:  
 [CREATE TABLE-SQL](../../odbc/microsoft/create-table-sql-command.md)   
 [INSERT-SQL](../../odbc/microsoft/insert-sql-command.md)   
 [ЗАДАТЬ ANSI](../../odbc/microsoft/set-ansi-command.md)   
 [ЗАДАТЬ ТОЧНОЕ ЗНАЧЕНИЕ](../../odbc/microsoft/set-exact-command.md)
