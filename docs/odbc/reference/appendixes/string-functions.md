---
description: Строковые функции
title: Строковые функции | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
helpviewer_keywords:
- functions [ODBC], string functions
- string functions [ODBC]
ms.assetid: 270f669e-8aab-4db0-95a4-f2b3c69538b3
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: fe6c50c7ad96f1025b27f60e2de74ba31f60698f
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99202521"
---
# <a name="string-functions"></a>Строковые функции
В следующей таблице перечислены функции обработки строк. Приложение может определить, какие строковые функции поддерживаются драйвером, вызвав **SQLGetInfo** с *типом данных* SQL_STRING_FUNCTIONS.  
  
## <a name="remarks"></a>Замечания  
 Аргументами, обозначенными как *string_exp* , может быть имя столбца, *символьная строка-литерал* или результат другой скалярной функции, где базовый тип данных может быть представлен как SQL_CHAR, SQL_VARCHAR или SQL_LONGVARCHAR.  
  
 Аргументы, обозначенные как *character_exp* , являются строкой символов переменной длины.  
  
 Аргументы, обозначенные как *Start*, *length* или *Count* , могут быть *числовым литералом* или результатом другой скалярной функции, где базовый тип данных может быть представлен как SQL_TINYINT, SQL_SMALLINT или SQL_INTEGER.  
  
 Строковые функции, перечисленные здесь, основаны на 1; то есть первым символом в строке является символ 1.  
  
 Скалярные функции BIT_LENGTH, CHAR_LENGTH, CHARACTER_LENGTH, OCTET_LENGTH и ПОЗИЦИОНИРОВАНИЯ были добавлены в ODBC 3,0 для согласования с SQL-92.  
  
|Функция|Описание|  
|--------------|-----------------|  
|**ASCII (** _string_exp_ **)**  (ODBC 1,0)|Возвращает кодовое значение ASCII крайнего левого символа *string_exp* в виде целого числа.|  
|**BIT_LENGTH (** _string_exp_ **)**  (ODBC 3,0)|Возвращает длину строкового выражения в битах.<br /><br /> Не работает только для строковых типов данных, поэтому не будет неявно преобразовывать *string_exp* в строку, а вместо этого будет возвращать (внутренний) размер любого типа данных, который он получает.|  
|**Char (** _Code_ **)**  (ODBC 1,0)|Возвращает символ, который имеет значение ASCII Code, заданное в *коде*. Значение *Code* должно находиться в диапазоне от 0 до 255; в противном случае возвращаемое значение зависит от источника данных.|  
|**CHAR_LENGTH (** _string_exp_ **)**  (ODBC 3,0)|Возвращает длину в символах строкового выражения, если строковое выражение имеет символьный тип данных; в противном случае возвращает длину строкового выражения в байтах (наименьшее целое число не меньше числа бит, деленного на 8). (Эта функция аналогична функции CHARACTER_LENGTH.)|  
|**CHARACTER_LENGTH (** _string_exp_ **)**  (ODBC 3,0)|Возвращает длину в символах строкового выражения, если строковое выражение имеет символьный тип данных; в противном случае возвращает длину строкового выражения в байтах (наименьшее целое число не меньше числа бит, деленного на 8). (Эта функция аналогична функции CHAR_LENGTH.)|  
|**Concat (** _string_exp1_,_string_exp2_**)**  (ODBC 1,0)|Возвращает строку символов, являющуюся результатом сцепления *string_exp2* с *string_exp1*. Полученная в результате строка зависит от СУБД. Например, если столбец, представленный *string_exp1* , СОДЕРЖАЛ значение null, то DB2 ВОЗВРАТИТ значение null, но SQL Server вернет строку, отличную от NULL.|  
|**Разница (** _string_exp1_,_string_exp2_**)**  (ODBC 2,0)|Возвращает целочисленное значение, указывающее разницу между значениями, возвращаемыми функцией SOUNDEX для *string_exp1* и *string_exp2*.|  
|**INSERT (** _string_exp1_, *Начало*, *Длина*, _string_exp2_**)**  (ODBC 1,0)|Возвращает строку символов, в которой символы *длины* были удалены из *string_exp1*, начиная с *начала* и где *string_exp2* вставлен в *string_exp,* начиная с *Start*.|  
|**Лкасе (** _string_exp_ **)** (ODBC 1,0)|Возвращает строку, равную *string_exp*, в которой все символы верхнего регистра преобразуются в нижний регистр.|  
|**Left (** _string_exp_, _число_**)** (ODBC 1,0)|Возвращает крайний левый *Счетчик* символов *string_exp*.|  
|**Длина (** _string_exp_ **)** (ODBC 1,0)|Возвращает количество символов в *string_exp,* исключая конечные пробелы.<br /><br /> **Длина** принимает только строки. Таким образом, неявно преобразует *string_exp* в строку и возвращает длину этой строки (а не внутренний размер типа данных).|  
|**Обнаружение (** _string_exp1_, *string_exp2*[, *Start*]**)** (ODBC 1,0)|Возвращает начальную точку первого вхождения *string_exp1* в *string_exp2*. Поиск первого вхождения *string_exp1* начинается с позиции первого символа в *string_exp2* , если не указан необязательный аргумент *Start*. Если указан параметр *Start* , поиск начинается с позиции символа, обозначенной значением *Start*. Первая символьная позиции в *string_exp2* обозначена значением 1. Если *string_exp1* не найден в *string_exp2*, возвращается значение 0.<br /><br /> Если приложение может вызвать скалярную функцию "Открыть" с аргументами *string_exp1*, *string_exp2* и *Start* , драйвер возвращает SQL_FN_STR_LOCATE при вызове **SQLGetInfo** с *параметром* SQL_STRING_FUNCTIONS. Если приложение может вызвать скалярную функцию «нахождение» только с аргументами *string_exp1* и *string_exp2* , драйвер возвращает SQL_FN_STR_LOCATE_2 при вызове **SQLGetInfo** с *параметром* SQL_STRING_FUNCTIONS. Драйверы, поддерживающие вызов функции "разместить" с двумя или тремя аргументами, возвращают как SQL_FN_STR_LOCATE, так и SQL_FN_STR_LOCATE_2.|  
|**LTRIM (** _string_exp_ **)** (ODBC 1,0)|Возвращает символы *string_exp* с удаленными начальными пробелами.|  
|**OCTET_LENGTH (** _string_exp_ **)** (ODBC 3,0)|Возвращает длину строкового выражения в байтах. Результатом является наименьшее целочисленное значение, не меньшее, чем число битов, разделенное на 8.<br /><br /> Не работает только для строковых типов данных, поэтому не будет неявно преобразовывать *string_exp* в строку, а вместо этого будет возвращать (внутренний) размер любого типа данных, который он получает.|  
|**Расположение (** _character_exp_ **в** _character_exp_**)** (ODBC 3,0)|Возвращает позиции первого символьного выражения во втором символьном выражении. Результат представляет собой точное числовое значение с точностью, определяемой реализацией, и масштабом 0.|  
|**Повтор (** _string_exp,_ _количество_**)** (ODBC 1,0)|Возвращает строку символов, состоящую  из string_exp *повторяющихся значений* времени.|  
|**Replace (** _string_exp1_, *string_exp2*, _string_exp3_**)** (ODBC 1,0)|Выполните поиск *string_exp1* фороккурренцес *string_exp2* и замените на *string_exp3*.|  
|**Right (** _string_exp_, _количество_**)** (ODBC 1,0)|Возвращает крайний правый *Счетчик* символов *string_exp*.|  
|**RTRIM (** _string_exp_ **)** (ODBC 1,0)|Возвращает символы *string_exp* с удаленными замыкающими пробелами.|  
|**SOUNDEX (** _string_exp_ **)** (ODBC 2,0)|Возвращает строку символов, зависящую от источника данных, представляющую звук слов в *string_exp*. Например, SQL Server возвращает 4-значный код SOUNDEX. Oracle возвращает фонетическое представление каждого слова.|  
|**Пробел (** _число_ **)** (ODBC 2,0)|Возвращает строку *символов, состоящую из пробелов* .|  
|**ПОДстрока (** _string_exp_, *Начало*, длина **)** (ODBC 1,0)|Возвращает строку символов, которая является производной от *string_exp*, начиная с позиции символа, указанной параметром *Start* для символов *длины* .|  
|**Укасе (** _string_exp_ **)** (ODBC 1,0)|Возвращает строку, равную *string_exp*, в которой все символы нижнего регистра преобразуются в верхний регистр.|
