---
description: SQLFetchScroll (библиотека курсоров)
title: SQLFetchScroll (библиотека курсоров) | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function [ODBC], Cursor Library
ms.assetid: 4417e57c-31dd-475e-8fe9-eab00a459c80
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 719504a6e1e412439314ee6971cf41e05805f592
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99202846"
---
# <a name="sqlfetchscroll-cursor-library"></a>SQLFetchScroll (библиотека курсоров)
> [!IMPORTANT]  
>  Эта функция будет удалена в следующей версии Windows. Избегайте использования этой функции в новых разработках и запланируйте изменение приложений, которые в настоящее время используют эту функцию. Корпорация Майкрософт рекомендует использовать функцию курсора драйвера.  
  
 В этом разделе обсуждается использование функции **SQLFetchScroll** в библиотеке курсоров. Общие сведения о **SQLFetchScroll** см. в разделе [Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md).  
  
 Библиотека курсоров реализует **SQLFetchScroll** путем многократного вызова **SQLFetch** в драйвере. Он передает получаемые им данные из драйвера в буферы набора строк, предоставляемые приложением. Он также кэширует данные в памяти и дисковых файлах. Когда приложение запрашивает новый набор строк, Библиотека курсоров извлекает его по мере необходимости из драйвера (если он не был предварительно выбран) или кэша (если он был ранее извлечен). Наконец, Библиотека курсоров поддерживает состояние кэшированных данных и возвращает эти сведения в приложение в массиве состояния строки.  
  
 При использовании библиотеки курсоров вызовы **SQLFetchScroll** не могут смешиваться с вызовами либо **SQLFetch** , либо **SQLExtendedFetch**.  
  
 При использовании библиотеки курсоров вызовы **SQLFetchScroll** поддерживаются как для ODBC 2. *x* и ODBC 3. драйверы *x* .  
  
## <a name="rowset-buffers"></a>Буферы наборов строк  
 Библиотека курсоров оптимизирует перенос данных из драйвера в буфер набора строк, предоставляемый приложением, если:  
  
-   Приложение использует привязку на уровне строк.  
  
-   Между полями в структуре нет неиспользуемых байтов, которые объявляются приложением для хранения строки данных.  
  
-   Поля, в которых **SQLFetch** или **SQLFetchScroll** возвращает длину или индикатор для столбца, следуют за буфером для этого столбца и перед буфером для следующего столбца. Эти поля необязательные.  
  
 Когда приложение запрашивает новый набор строк, Библиотека курсоров получает данные из своего кэша и из драйвера по мере необходимости. Если новые и старые наборы строк перекрываются, Библиотека курсоров может оптимизировать свою производительность, повторно используя данные из перекрывающихся разделов буферов наборов строк. Поэтому несохраненные изменения в буферах наборов строк теряются, если новые и старые наборы строк перекрываются, а изменения находятся в перекрывающимися разделах буферов наборов строк. Чтобы сохранить изменения, приложение отправляет инструкцию позиционированного обновления.  
  
 Обратите внимание, что библиотека курсоров всегда обновляет буферы наборов строк данными из кэша, когда приложение вызывает **SQLFetchScroll** с аргументом *фетчориентатион* , для которого задано значение SQL_FETCH_RELATIVE а аргумент *фетчоффсет* имеет значение 0.  
  
 Библиотека курсоров поддерживает вызов **SQLSetStmtAttr** с *атрибутом* SQL_ATTR_ROW_ARRAY_SIZE для изменения размера набора строк, пока курсор открыт. Новый размер набора строк вступит в силу при следующем вызове **SQLFetchScroll** .  
  
## <a name="result-set-membership"></a>Членство в результирующем наборе  
 Библиотека курсоров извлекает данные из драйвера только по мере того, как приложение запрашивает его. В зависимости от источника данных и значения атрибута SQL_CONCURRENCY оператора, это имеет следующие последствия.  
  
-   Данные, извлекаемые библиотекой курсоров, могут отличаться от данных, которые были доступны во время выполнения инструкции. Например, после открытия курсора строки, вставленные в точку за пределами текущего положения курсора, могут быть получены некоторыми драйверами.  
  
-   Данные в результирующем наборе могут быть заблокированы источником данных для библиотеки курсоров и поэтому недоступны другим пользователям.  
  
 После того как библиотека курсоров кэширует строку данных, она не может обнаружить изменения в этой строке в базовом источнике данных (за исключением позиционированных обновлений и удалений, работающих в кэше одного и того же курсора). Это происходит потому, что для вызовов **SQLFetchScroll** библиотека курсоров никогда не извлекает данные из источника данных. Вместо этого он повторно извлекает данные из своего кэша.  
  
## <a name="scrolling"></a>Прокрутка  
 Библиотека курсоров поддерживает следующие типы выборки в **SQLFetchScroll**.  
  
|Тип курсора|Типы выборки|  
|-----------------|-----------------|  
|Однонаправленный|SQL_FETCH_NEXT|  
|Статические|SQL_FETCH_NEXT<br /><br /> SQL_FETCH_PRIOR<br /><br /> SQL_FETCH_FIRST<br /><br /> SQL_FETCH_LAST<br /><br /> SQL_FETCH_RELATIVE<br /><br /> SQL_FETCH_ABSOLUTE<br /><br /> SQL_FETCH_BOOKMARK|  
  
## <a name="errors"></a>ошибки  
 Когда вызывается **SQLFetchScroll** и один из вызовов **SQLFetch** возвращает SQL_ERROR, Библиотека курсоров продолжается следующим образом. После выполнения этих действий библиотека курсоров продолжит обработку.  
  
1.  Вызывает **SQLGetDiagRec** для получения сведений об ошибке из драйвера и отправляет его в качестве диагностической записи в диспетчере драйверов.  
  
2.  Задает для поля SQL_DIAG_ROW_NUMBER в диагностической записи соответствующее значение.  
  
3.  Задает для поля SQL_DIAG_COLUMN_NUMBER в диагностической записи соответствующее значение (если применимо). в противном случае устанавливается значение 0.  
  
4.  Задает для строки с ошибкой значение SQL_ROW_ERROR в массиве состояния строки.  
  
 После того как библиотека курсоров вызывала **SQLFetch** несколько раз в своей реализации **SQLFetchScroll**, любая ошибка или предупреждение, возвращаемые одним из вызовов **SQLFetch** , будут находиться в диагностической записи и могут быть получены вызовом **SQLGetDiagRec**. Если данные были усечены при выборке, то усеченные данные будут находиться в кэше библиотеки курсоров. Последующие вызовы **SQLFetchScroll** для прокрутки до строки с усеченными данными будут возвращать усеченные данные, и предупреждение не будет выдано, так как данные будут получены из кэша библиотеки курсоров. Чтобы контролировать длину возвращаемых данных, чтобы определить, были ли данные, возвращенные в буфере, обрезаны, приложение должно привязать буфер длины или индикатора.  
  
## <a name="bookmark-operations"></a>Операции с закладками  
 Библиотека курсоров поддерживает вызов **SQLFetchScroll** с *фетчориентатион* SQL_FETCH_BOOKMARK. Он также поддерживает указание смещения в аргументе *фетчоффсет* , который может использоваться в операции Bookmark. Это единственная операция с закладками, которую поддерживает библиотека курсоров. Библиотека курсоров не поддерживает вызов **SQLBulkOperations**.  
  
 Если приложение установило атрибут инструкции SQL_ATTR_USE_BOOKMARKS и привязывается к столбцу Bookmark, Библиотека курсоров создает закладку фиксированной длины и возвращает ее в приложение. Библиотека курсоров создает и поддерживает используемые им закладки. Он не использует закладки, поддерживаемые в источнике данных. При вызове **SQLFetchScroll** для получения блока данных, который уже был извлечен из источника данных, он извлекает данные из кэша библиотеки курсора. В результате Закладка, используемая в вызове **SQLFetchScroll** с *фетчориентатион* SQL_FETCH_BOOKMARK, должна создаваться и поддерживаться библиотекой курсоров.  
  
## <a name="interaction-with-other-functions"></a>Взаимодействие с другими функциями  
 Приложение должно вызвать **SQLFetch** или **SQLFetchScroll** перед подготовкой или выполнением любых позиционированных инструкций UPDATE или DELETE.
