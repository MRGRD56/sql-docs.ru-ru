---
description: Приложение Б. Таблицы перехода состояния ODBC
title: Приложение б. таблицы перехода состояния ODBC | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
helpviewer_keywords:
- state transitions [ODBC]
- transitioning states [ODBC], about state transitions
- state transitions [ODBC], about state transitions
ms.assetid: 15088dbe-896f-4296-b397-02bb3d0ac0fb
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 67c14205590ccdf9d20a30f44c13aa2da5abbe8d
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99212565"
---
# <a name="appendix-b-odbc-state-transition-tables"></a>Приложение Б. Таблицы перехода состояния ODBC
В таблицах этого приложения показано, как функции ODBC вызывают переходы между состояниями среды, соединения, инструкции и дескриптора. Состояние среды, соединения, инструкции или дескриптора обычно определяет, когда могут быть вызваны функции, использующие соответствующий тип дескриптора (среда, соединение, инструкция или дескриптор). Состояния среды, соединения, инструкции и дескриптора перекрываются примерно так, как показано на следующих иллюстрациях. Например, точное перекрытие состояний соединения C5 и C6 и состояний инструкций S1 – S12 зависит от источника данных, так как транзакции начинаются в разное время в разных источниках данных, а состояние дескриптора D1i (неявно выделенный дескриптор) зависит от состояния инструкции, с которой связан дескриптор, а State D1e (явно выделенный дескриптор) не зависит от состояния любой инструкции. Описание каждого состояния см. в подразделе [переходы среды](../../../odbc/reference/appendixes/environment-transitions.md), [переходы соединений](../../../odbc/reference/appendixes/connection-transitions.md), [переходы инструкций](../../../odbc/reference/appendixes/statement-transitions.md)и [переходы по дескрипторам](../../../odbc/reference/appendixes/descriptor-transitions.md)далее в этом приложении.  
  
 Состояние окружения и подключения перекрывается следующим образом:  
  
 ![Перекрытие состояний среды и соединения](../../../odbc/reference/appendixes/media/app01.gif "app01")  
  
 Состояние соединения и инструкции перекрывается следующим образом:  
  
 ![Перекрытие состояний инструкции и соединения](../../../odbc/reference/appendixes/media/app02.gif "app02")  
  
 Состояние инструкции и дескриптора перекрывается следующим образом:  
  
 ![Перекрытие состояний инструкции и дескриптора](../../../odbc/reference/appendixes/media/app03.gif "app03")  
  
 Состояние подключения и дескриптора перекрывается следующим образом:  
  
 ![Перекрытие состояний соединения и дескриптора](../../../odbc/reference/appendixes/media/app04.gif "app04")  
  
 Каждая запись в таблице переходов может принимать одно из следующих значений:  
  
-   **--** — Состояние не изменяется после выполнения функции.  
  
-   **E**  

     **_n_** , **C_n_**, **S_n_** или **D_n_** — среда, соединение, инструкция или состояние дескриптора перемещается в указанное состояние.  
 
-   **(IH)** — в функцию был передан недопустимый маркер. Если маркер был маркером null или является допустимым маркером неверного типа, например, был передан маркер соединения, когда требуется маркер инструкции — функция возвращает SQL_INVALID_HANDLE; в противном случае поведение не определено и, возможно, неустранимо. Эта ошибка отображается только в том случае, если это единственный возможный результат вызова функции в указанном состоянии. Эта ошибка не изменяет состояние и всегда обнаруживается диспетчером драйверов, как указано в круглых скобках.  
  
-   Состояние **NS** -Next. Переход оператора аналогичен условию, если инструкция не прошла через асинхронные состояния. Например, предположим, что инструкция, создающая результирующий набор, вводит State S11 из состояния S1, так как **SQLExecDirect** вернул SQL_STILL_EXECUTING. Нотация NS в состоянии S11 означает, что переходы для инструкции одинаковы для инструкции в состоянии S1, которая создает результирующий набор. Если **SQLExecDirect** возвращает ошибку, инструкция остается в состоянии S1; в случае успешности инструкция переходит в состояние S5; Если требуются данные, инструкция перемещается в состояние S8; и если он по-прежнему выполняется, он остается в состоянии S11.  

-   **_XXXXX_**  или **(*XXXXX*)** — значение SQLSTATE, связанное с таблицей переходов; SQLSTATE, обнаруженный диспетчером драйверов, заключен в круглые скобки. Функция вернула SQL_ERROR и указанное значение SQLSTATE, но состояние не меняется. Например, если **SQLExecute** вызывается перед **SQLPrepare**, он возвращает SQLSTATE HY010 (ошибка последовательности функций).  

> [!NOTE]  
>  В таблицах не отображаются ошибки, не связанные с таблицами перехода, которые не изменяют состояние. Например, если **функцию SQLAllocHandle** вызывается в окружении State E1 и ВОЗВРАЩАЕТ значение SQLSTATE HY001 (ошибка выделения памяти), среда остается в состоянии E1; Это не показано в таблице переходов окружения для **функцию SQLAllocHandle**.  
  
 Если среда, соединение, инструкция или дескриптор могут быть перемещены в несколько состояний, отображается каждое возможное состояние, а в одной или нескольких сносках поясняются условия, при которых происходит каждый переход. В любой таблице могут присутствовать следующие сноски.  
  
|Нижни|Значение|  
|--------------|-------------|  
|b|До или после. Курсор был помещен перед началом результирующего набора или после конца результирующего набора.|  
|с|Текущая функция. Текущая функция выполнялась асинхронно.|  
|d|Требуются данные. Функция вернула SQL_NEED_DATA.|  
|й|Ошибка. Функция вернула SQL_ERROR.|  
|i|Недопустимая строка. Курсор был помещен на строку в результирующем наборе, и либо была удалена строка, либо произошла ошибка в операции в строке. Если массив состояния строки существовал, значение в массиве состояния строки для строки было SQL_ROW_DELETED или SQL_ROW_ERROR. (На массив состояния строк указывает атрибут инструкции SQL_ATTR_ROW_STATUS_PTR.)|  
|nf|Не найдено. Функция вернула SQL_NO_DATA. Это неприменимо, если **SQLExecDirect**, **SQLExecute** или **метод SQLParamData** возвращает SQL_NO_DATA после выполнения инструкции UPDATE или DELETE, в которой выполняется поиск.|  
|np|Не подготовлено. Инструкция не была подготовлена.|  
|nr|Результаты отсутствуют. Инструкция не создаст результирующий набор или не создаст его.|  
|o|Другая функция. Другая функция выполнялась асинхронно.|  
|p|Аварий. Инструкция была подготовлена.|  
|r|Результаты. Инструкция будет или создана (возможно, пуста) результирующий набор.|  
|s|Успешно. Функция вернула SQL_SUCCESS_WITH_INFO или SQL_SUCCESS.|  
|v|Допустимая строка. Курсор был помещен на строку в результирующем наборе, и строка была успешно вставлена, успешно обновлена или была успешно выполнена другая операция в строке. Если массив состояния строки существовал, значение в массиве состояния строки для строки было SQL_ROW_ADDED, SQL_ROW_SUCCESS или SQL_ROW_UPDATED. (На массив состояния строк указывает атрибут инструкции SQL_ATTR_ROW_STATUS_PTR.)|  
|x|Выполняющиеся. Функция вернула SQL_STILL_EXECUTING.|  
  
## <a name="sqlfreehandle"></a>SQLFreeHandle  
 В этом примере строка в таблице перехода состояния среды для **SQLFreeHandle** , когда *параметром handletype* имеет значение SQL_HANDLE_ENV, выглядит следующим образом.  
  
|E0<br /><br /> Не выделено|E1<br /><br /> Allocated|E2<br /><br /> Подключение|  
|------------------------|----------------------|-----------------------|  
|IH|E0|(HY010)|  
  
 Если **SQLFreeHandle** вызывается в состоянии среды E0 с параметром *параметром handletype* , для которого задано значение SQL_HANDLE_ENV, диспетчер драйверов возвращает SQL_INVALID_HANDLE. Если метод вызывается в состоянии E1 с *параметром handletype* , для которого задано значение SQL_HANDLE_ENV, среда переходит в состояние E0, если функция завершается успешно, и остается в состоянии E1 при сбое функции. Если он вызывается в состоянии E2 с параметром *параметром handletype* со значением SQL_HANDLE_ENV, диспетчер драйверов всегда возвращает SQL_ERROR и SQLSTATE HY010 (ошибка последовательности функций), и среда остается в состоянии E2.  
  
 Для понимания таблиц смены состояния необходимо понять, какой элемент (среда, соединение, инструкция или дескриптор) они ссылаются. Предположим, что функция принимает маркер элемента типа X. Таблица переходов состояния X для этой функции описывает, как вызов функции с маркером элемента типа X влияет на этот элемент. Например, **SQLDisconnect** принимает маркер подключения. Таблица переходов состояния соединения для **SQLDisconnect** описывает, как **SQLDisconnect** влияет на состояние соединения, для которого оно вызвано.  
  
 Предположим, что функция принимает маркер элемента типа Y, где Y не равно X. Таблица переходов состояния X для этой функции описывает, как вызов функции с маркером типа X, связанным с элементом типа Y, влияет на элемент типа Y. Например, таблица перехода состояния инструкции для **SQLDisconnect** описывает, как **SQLDisconnect** влияет на состояние инструкции при вызове с помощью маркера соединения, с которым связана инструкция.  
  
 Это приложение содержит следующие разделы.  
  
-   [Переходы среды](../../../odbc/reference/appendixes/environment-transitions.md)  
  
-   [Переходы подключения](../../../odbc/reference/appendixes/connection-transitions.md)  
  
-   [Переходы инструкций](../../../odbc/reference/appendixes/statement-transitions.md)  
  
-   [Переходы дескрипторов](../../../odbc/reference/appendixes/descriptor-transitions.md)
