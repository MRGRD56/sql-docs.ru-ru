---
description: Функция SQLPrepare
title: Функция SQLPrepare | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLPrepare
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLPrepare
helpviewer_keywords:
- SQLPrepare function [ODBC]
ms.assetid: 332e1b4b-b0ed-4e7a-aa4d-4f35f4f4476b
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ce0348f2161def7dabc4941f088b883b286d2969
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99192602"
---
# <a name="sqlprepare-function"></a>Функция SQLPrepare
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLPrepare** подготавливает строку SQL для выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLPrepare(  
     SQLHSTMT      StatementHandle,  
     SQLCHAR *     StatementText,  
     SQLINTEGER    TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *статементтекст*  
 Входной Текстовая строка SQL.  
  
 *TextLength*  
 Входной Длина **статементтекст* в символах.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLPrepare** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLPrepare** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Значение параметра изменено|Указанный атрибут инструкции был недопустимым из-за рабочих условий реализации, поэтому было временно заменено аналогичное значение. (**SQLGetStmtAttr** можно вызвать, чтобы определить, что такое временно заменяющий параметр.) Заменяющее значение допустимо для *статеменсандле* до закрытия курсора. Атрибуты инструкции, которые могут быть изменены: SQL_ATTR_CONCURRENCY SQL_ATTR_CURSOR_TYPE SQL_ATTR_KEYSET_SIZE SQL_ATTR_MAX_LENGTH SQL_ATTR_MAX_ROWS SQL_ATTR_QUERY_TIMEOUT SQL_ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|21S01|Список вставляемых значений не соответствует списку столбцов|\**Статементтекст* содержит инструкцию **INSERT** , а число вставляемых значений не соответствует степени производной таблицы.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|\**Статементтекст* содержал инструкцию **Create View** , а указанное число имен не совпадает с производной таблицей, определенной спецификацией запроса.|  
|22018|Недопустимое символьное значение для спецификации приведения|**Статементтекст* содержит инструкцию SQL, содержащую литерал или параметр, и значение несовместимо с типом данных связанного столбца таблицы.|  
|22019|Недопустимый escape-символ|Аргумент *статементтекст* содержит предикат **Like** с **escape** -символом в предложении **WHERE** , а длина escape-символа, следующего за **escape** -выражением, не равна 1.|  
|22025|Недопустимая escape-последовательность|Аргумент *статементтекст* содержал «**Like** **escape-** _символ_- _значение шаблона_ » в предложении **WHERE** , а символ, следующий за escape-символом в значении шаблона, не был ни «%» ни ни «_».|  
|24 000|Недопустимое состояние курсора|(DM) курсор был открыт в *статеменсандле*, и был вызван **SQLFetch** или **SQLFetchScroll** .<br /><br /> В *статеменсандле* был открыт курсор, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|34000|Недопустимое имя курсора|\**Статементтекст* содержал позиционированное **Удаление** или позиционированное **Обновление**, а курсор, на который ссылается подготовленная инструкция, не был открыт.|  
|3D000|Недопустимое имя каталога|В *статементтекст* указано недопустимое имя каталога.|  
|3F000|Недопустимое имя схемы|В *статементтекст* указано недопустимое имя схемы.|  
|42000|Синтаксическая ошибка или нарушение прав доступа|\**Статементтекст* содержал инструкцию SQL, которая не была доступныйа, или не содержала синтаксическую ошибку.<br /><br /> **Статементтекст* содержал инструкцию, для которой пользователь не имеет необходимых привилегий.|  
|42S01|Базовая таблица или представление уже существует|\**Статементтекст* содержит инструкцию **CREATE TABLE** или **Create View** , а указанное имя таблицы или представления уже существует.|  
|42S02|Базовая таблица или представление не найдены|\**Статементтекст* содержит инструкцию **DROP TABLE** или **DROP VIEW** , а указанное имя таблицы или представления не существует.<br /><br /> \**Статементтекст* содержит инструкцию **ALTER TABLE** , а указанное имя таблицы не существует.<br /><br /> \**Статементтекст* содержал инструкцию **Create View** , а имя таблицы или представления, определенное спецификацией запроса, не существовало.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE INDEX** , а указанное имя таблицы не существует.<br /><br /> \**Статементтекст* содержит инструкцию **Grant** или **REVOKE** , а указанное имя таблицы или представления не существует.<br /><br /> \**Статементтекст* содержит инструкцию **SELECT** , а указанное имя таблицы или представления не существует.<br /><br /> \**Статементтекст* содержит инструкцию **Delete**, **INSERT** или **Update** , а указанное имя таблицы не существует.<br /><br /> \**Статементтекст* содержит оператор **CREATE TABLE** , а таблица, указанная в ограничении (ссылающаяся на таблицу, отличную от создаваемой), не существует.|  
|42S11|Индекс уже существует|\**Статементтекст* содержит инструкцию **CREATE INDEX** , а указанное имя индекса уже существует.|  
|42S12|Индекс не найден|\**Статементтекст* содержит инструкцию **DROP INDEX** , а указанное имя индекса не существует.|  
|42S21|Столбец уже существует|\**Статементтекст* содержит инструкцию **ALTER TABLE** , а столбец, указанный в предложении **Add** , не уникален или определяет существующий столбец в базовой таблице.|  
|42S22|Столбец не найден|\**Статементтекст* содержит инструкцию **CREATE INDEX** , а одно или несколько имен столбцов, указанных в списке столбцов, не существуют.<br /><br /> \**Статементтекст* содержит инструкцию **Grant** или **REVOKE** , и указанное имя столбца не существует.<br /><br /> \**Статементтекст* содержит инструкцию **SELECT**, **Delete**, **INSERT** или **Update** , а указанное имя столбца не существует.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE TABLE** , а столбец, указанный в ограничении (ссылающийся на таблицу, отличную от создаваемой), не существует.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *Статеменсандле*, а затем в *статеменсандле* был вызвана функция.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) *статементтекст* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLPrepare** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) аргумент *TextLength* был меньше или равен 0, но не равен SQL_NTS.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Параметр параллелизма недопустим для определенного типа курсора.<br /><br /> Атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_VARIABLE, а атрибуту инструкции SQL_ATTR_CURSOR_TYPE задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLPrepare** , чтобы отправить инструкцию SQL в источник данных для подготовки. Дополнительные сведения о подготовленном выполнении см. в разделе [подготовленное выполнение](../../../odbc/reference/develop-app/prepared-execution-odbc.md). Приложение может включать один или несколько маркеров параметров в инструкцию SQL. Чтобы включить маркер параметра, приложение внедряет вопросительный знак (?) в строку SQL в соответствующей позиции. Дополнительные сведения о параметрах см. в разделе [Параметры инструкции](../../../odbc/reference/develop-app/statement-parameters.md).  
  
> [!NOTE]  
>  Если приложение использует **SQLPrepare** для подготовки и **SQLExecute** для отправки инструкций **commit** или **ROLLBACK** , оно не будет взаимодействовать между продуктами СУБД. Чтобы зафиксировать или откатить транзакцию, вызовите **SQLEndTran**.  
  
 Драйвер может изменить инструкцию для использования формы SQL, используемой источником данных, а затем передать ее в источник данных для подготовки. В частности, драйвер изменяет escape-последовательности, используемые для определения синтаксиса SQL для определенных функций. (Описание грамматики инструкции SQL см. в разделе [escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md) и [приложении C: грамматика SQL](../../../odbc/reference/appendixes/appendix-c-sql-grammar.md).) Для драйвера маркер инструкции похож на идентификатор инструкции в внедренном коде SQL. Если источник данных поддерживает идентификаторы операторов, драйвер может отправить в источник данных идентификатор инструкции и значения параметров.  
  
 После подготовки инструкции приложение использует маркер инструкции для ссылки на инструкцию в последующих вызовах функций. Подготовленная инструкция, связанная с маркером инструкции, может быть повторно выполнена путем вызова **SQLExecute** , пока приложение не освободит инструкцию вызовом **SQLFreeStmt** с помощью параметра SQL_DROP или до тех пор, пока не будет использован маркер инструкции в вызове **SQLPrepare**, **SQLExecDirect** или одной из функций каталога (**SQLColumns**, **SQLTables** и т. д.). Когда приложение подготавливает инструкцию, оно может запросить сведения о формате результирующего набора. Для некоторых реализаций вызов **SQLDescribeCol** или **SQLDescribeParam** после **SQLPrepare** может быть не таким эффективным, как вызов функции после **SQLExecute** или **SQLExecDirect**.  
  
 Некоторые драйверы не могут возвращать синтаксические ошибки или нарушения прав доступа, когда приложение вызывает **SQLPrepare**. Драйвер может выполнять синтаксические ошибки и нарушения прав доступа, только синтаксические ошибки или ни синтаксические ошибки, ни нарушения прав доступа. Поэтому приложение должно иметь возможность обрабатывать эти условия при вызове последующих связанных функций, таких как **SQLNumResultCols**, **SQLDescribeCol**, **SQLColAttribute** и **SQLExecute**.  
  
 В зависимости от возможностей драйвера и источника данных сведения о параметрах (например, типы данных) могут быть проверены при подготовке инструкции (если все параметры привязаны) или при их выполнении (если все параметры не привязаны). Для обеспечения максимальной совместимости приложение должно отменить привязку всех параметров, примененных к старой инструкции SQL, перед тем как подготовить новую инструкцию SQL к той же инструкции. Это предотвращает ошибки, вызванные устаревшими сведениями о параметрах, которые применяются к новой инструкции.  
  
> [!IMPORTANT]  
>  Фиксация транзакции путем явного вызова **SQLEndTran** или работы в режиме автоматической фиксации может привести к тому, что источник данных удалит планы доступа для всех инструкций в соединении. Дополнительные сведения см. в статьях типы сведений SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR в [SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) и [воздействие транзакций на курсоры и подготовленные инструкции](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md).  
  
## <a name="code-example"></a>Пример кода  
 См. раздел [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение маркера инструкции|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка буфера к параметру|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращение количества строк, затронутых инструкцией|[Функция SQLRowCount](../../../odbc/reference/syntax/sqlrowcount-function.md)|  
|Задание имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
