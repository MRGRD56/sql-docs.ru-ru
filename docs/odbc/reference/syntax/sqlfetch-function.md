---
description: Функция SQLFetch
title: Функция SQLFetch | Документация Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLFetch
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLFetch
helpviewer_keywords:
- SQLFetch function [ODBC]
ms.assetid: 6c6611d2-bc6a-4390-87c9-1c5dd9cfe07c
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 095a1ca4a67122344926d9ca363dd9f05205c48b
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99209796"
---
# <a name="sqlfetch-function"></a>Функция SQLFetch
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLFetch** извлекает следующий набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLFetch(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLFetch** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE можно получить путем вызова [функции SQLGetDiagRec](../../../odbc/reference/syntax/sqlgetdiagrec-function.md) с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLFetch** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное. Если в одном столбце возникает ошибка, [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md) можно вызвать с *диагидентифиер* из SQL_DIAG_COLUMN_NUMBER, чтобы определить столбец, в котором произошла ошибка. и **SQLGetDiagField** можно вызвать с *диагидентифиер* SQL_DIAG_ROW_NUMBER, чтобы определить строку, содержащую этот столбец.  
  
 Для всех этих SQLSTATE, которые могут возвращать SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением 01XXX SQLSTATE), SQL_SUCCESS_WITH_INFO возвращается в случае возникновения ошибки в одной или нескольких строках операции многострочные, а SQL_ERROR возвращается в случае возникновения ошибки в операции с одной строкой.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Строковые или двоичные данные, возвращаемые для столбца, привели к усечению непустого символа или двоичных данных, отличных от NULL. Если это строковое значение, оно было усечено по правому краю.|  
|01S01|Ошибка в строке|Произошла ошибка при выборке одной или нескольких строк.<br /><br /> (Если это значение SQLSTATE возвращается, когда приложение ODBC 3 *. x* работает с драйвером ODBC 2 *. x* , его можно игнорировать.)|  
|01S07|Усечение дробной части|Данные, возвращаемые для столбца, были усечены. Для числовых типов данных дробная часть числа была усечена. Для типов данных времени, временных меток и интервалов, содержащих компонент времени, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных столбца в результирующем наборе не может быть преобразовано в тип данных, указанный в *TargetType* в **SQLBindCol**.<br /><br /> Столбец 0 был привязан к типу данных SQL_C_BOOKMARK, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS задано значение SQL_UB_VARIABLE.<br /><br /> Столбец 0 был привязан к типу данных SQL_C_VARBOOKMARK, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS не было задано значение SQL_UB_VARIABLE.|  
|07009|Недопустимый индекс дескриптора|Драйвер был драйвером ODBC 2 *. x* , который не поддерживает **SQLExtendedFetch**, а номер столбца, указанный в привязке для столбца, равен 0.<br /><br /> Столбец 0 был привязан, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_OFF.|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|22001|Строковые данные, усеченные справа|Закладка переменной длины, возвращаемая для столбца, усечена.|  
|22002|Требуемая, но не определенная переменная индикатора|Данные NULL были получены в столбец, *StrLen_or_IndPtr* которого задается параметром **SQLBindCol** (или SQL_DESC_INDICATOR_PTR Set by **SQLSetDescField** или **SQLSetDescRec**), является пустым указателем.|  
|22003|Числовое значение вне допустимого диапазона|Возврат числового значения как числового или строки для одного или нескольких привязанных столбцов привело бы к усечению всего (в отличие от дробной части) числа.<br /><br /> Дополнительные сведения см. в разделе [Преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложении г: типы данных.|  
|22007|Недопустимый формат даты и времени|Символьный столбец в результирующем наборе был привязан к структуре даты, времени или метки времени C, а значение в столбце является, соответственно, недействительной датой, временем или меткой времени.|  
|22012|Деление на ноль|Возвращено значение из арифметического выражения, результатом которого является деление на ноль.|  
|22015|Переполнение поля интервала|Назначение типа SQL с точным числовым или интервалом до типа Interval C привело к утере значащих цифр в начальном поле.<br /><br /> При выборке данных в тип C Interval не было представления значения типа SQL в типе Interval C.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе был привязан к символьному буферу C, а столбец содержал символ, для которого в наборе символов буфера отсутствует представление.<br /><br /> Тип C был точным или приблизительным числовым, типом данных DateTime или интервалом. тип SQL столбца имеет символьный тип данных; и значение в столбце не было допустимым литералом привязанного типа C.|  
|24 000|Недопустимое состояние курсора|*Статеменсандле* был в выполненном состоянии, но с *статеменсандле* не связан ни один результирующий набор.|  
|40001|Сбой сериализации|Транзакция, в которой выполнялась выборка, была прервана во избежание взаимоблокировки.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Была вызвана функция **SQLFetch** , и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле*. Затем в *статеменсандле* вызывается функция **SQLFetch** .<br /><br /> Или была вызвана функция  **SQLFetch** , и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLFetch** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) указанный *статеменсандле* не находится в выполненном состоянии. Функция была вызвана без предварительного вызова **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) **SQLFetch** был вызван для *статеменсандле* после того, как был вызван **SQLExtendedFetch** , и перед вызовом **SQLFreeStmt** с параметром SQL_CLOSE.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Атрибуту инструкции SQL_ATTR_USE_BOOKMARK было присвоено значение SQL_UB_VARIABLE, а столбец 0 был привязан к буферу, длина которого не равна максимальной длине закладки для этого результирующего набора. (Эта длина доступна в поле SQL_DESC_OCTET_LENGTH IRD и может быть получено путем вызова **SQLDescribeCol**, **SQLColAttribute** или **SQLGetDescField**.)|  
|HY107|Значение строки вне допустимого диапазона|Значение, указанное в атрибуте оператора SQL_ATTR_CURSOR_TYPE, было SQL_CURSOR_KEYSET_DRIVENо, но значение, указанное в атрибуте инструкции SQL_ATTR_KEYSET_SIZE, было больше 0 и меньше значения, указанного в атрибуте инструкции SQL_ATTR_ROW_ARRAY_SIZE.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает преобразование, заданное сочетанием *TargetType* в **SQLBindCol** и типом данных SQL соответствующего столбца.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул запрошенный результирующий набор. Период ожидания задается через SQLSetStmtAttr, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 **SQLFetch** возвращает следующий набор строк в результирующем наборе. Его можно вызывать только во время существования результирующего набора: после вызова, создающего результирующий набор и до закрытия курсора над этим результирующим набором. Если какие бы то ни было столбцы связаны, они возвращают данные в этих столбцах. Если приложение указало указатель на массив состояний строк или буфер, в котором возвращается число извлекаемых строк, **SQLFetch** также возвращает эти сведения. Вызовы **SQLFetch** можно смешивать с вызовами **SQLFetchScroll** , но не могут смешиваться с вызовами **SQLExtendedFetch**. Дополнительные сведения см. в разделе [выборка строки данных](../../../odbc/reference/develop-app/fetching-a-row-of-data.md).  
  
 Если приложение ODBC 3 *. x* работает с драйвером ODBC 2 *. x* , диспетчер драйверов сопоставляет вызовы **SQLFETCH** с **SQLExtendedFetch** для драйвера ODBC 2 *. x* , поддерживающего **SQLExtendedFetch**. Если драйвер ODBC 2 *. x* не поддерживает **SQLExtendedFetch**, диспетчер драйверов сопоставляет вызовы **SQLFetch** с **SQLFetch** в драйвере ODBC 2 *. x* , который может получить только одну строку.  
  
 Дополнительные сведения см. в разделе [блочные курсоры, прокручиваемые курсоры и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: рекомендации по драйверам для обеспечения обратной совместимости.  
  
## <a name="positioning-the-cursor"></a>Размещение курсора  
 При создании результирующего набора курсор располагается перед началом результирующего набора. **SQLFetch** извлекает следующий набор строк. Он эквивалентен вызову **SQLFetchScroll** с *фетчориентатион* , для которого задано значение SQL_FETCH_NEXT. Дополнительные сведения о курсорах см. в разделе [курсоры](../../../odbc/reference/develop-app/cursors.md) и [блочные курсоры](../../../odbc/reference/develop-app/block-cursors.md).  
  
 Атрибут инструкции SQL_ATTR_ROW_ARRAY_SIZE указывает количество строк в наборе строк. Если набор строк, который извлекается с помощью **SQLFetch** , пересекается с концом результирующего набора, **SQLFetch** возвращает частичный набор строк. То есть, если S + R-1 больше, чем L, где S — Начальная строка извлекаемого набора строк, R — это размер набора строк, а L — Последняя строка в результирующем наборе, то допустимы только первые L-S + 1 строки набора строк. Оставшиеся строки пусты и имеют состояние SQL_ROW_NOROW.  
  
 После возврата **SQLFetch** текущая строка является первой строкой набора строк.  
  
 Правила, перечисленные в следующей таблице, описывают позиционирование курсора после вызова **SQLFetch** на основе условий, перечисленных во второй таблице этого раздела.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|Перед началом работы|1|  
| \< Куррровсетстарт =  *Ластресултров-ровсетсизе*[1]|*Куррровсетстарт*  +  *Ровсетсизе*[2]|  
|*Куррровсетстарт*  >  *Ластресултров-ровсетсизе*[1]|После окончания|  
|После окончания|После окончания|  
  
 [1] при изменении размера набора строк между выборками это размер набора строк, который был использован с предыдущей выборкой.  
  
 [2] при изменении размера набора строк между выборками это размер набора строк, который использовался с новой выборке.  
  
|Notation|Значение|  
|--------------|-------------|  
|Перед началом работы|Курсор блока располагается перед началом результирующего набора. Если первая строка нового набора строк находится перед началом результирующего набора, **SQLFetch** возвращает SQL_NO_DATA.|  
|После окончания|Курсор блока располагается после конца результирующего набора. Если первая строка нового набора строк находится после конца результирующего набора, **SQLFetch** возвращает SQL_NO_DATA.|  
|*куррровсетстарт*|Номер первой строки в текущем наборе строк.|  
|*ластресултров*|Номер последней строки в результирующем наборе.|  
|*ровсетсизе*|Размер набора строк.|  
  
 Например, предположим, что результирующий набор содержит 100 строк, а размер набора строк равен 5. В следующей таблице показан набор строк и код возврата, возвращаемый функцией **SQLFetch** для различных начальных позиций.  
  
|Текущий набор строк|Код возврата|Новый набор строк|число извлекаемых строк|  
|--------------------|-----------------|----------------|------------------------|  
|Перед началом работы|SQL_SUCCESS|от 1 до 5|5|  
|от 1 до 5|SQL_SUCCESS|от 6 до 10|5|  
|от 52 до 56|SQL_SUCCESS|от 57 до 61|5|  
|от 91 до 95|SQL_SUCCESS|от 96 до 100|5|  
|от 93 до 97|SQL_SUCCESS|98 до 100. Строки 4 и 5 массива состояния строки имеют значение SQL_ROW_NOROW.|3|  
|от 96 до 100|SQL_NO_DATA|Нет.|0|  
|от 99 до 100|SQL_NO_DATA|Нет.|0|  
|После окончания|SQL_NO_DATA|Нет.|0|  
  
## <a name="returning-data-in-bound-columns"></a>Возврат данных в связанных столбцах  
 Поскольку **SQLFetch** возвращает каждую строку, она помещает данные для каждого привязанного столбца в буфере, привязанном к этому столбцу. Если ни один из столбцов не привязан, **SQLFetch** не возвращает никаких данных, но перемещает блоковый курсор вперед. Данные можно по-прежнему получать с помощью **SQLGetData**. Если курсор является многострочные курсором (то есть SQL_ATTR_ROW_ARRAY_SIZE больше 1), **SQLGetData** можно вызвать только в том случае, если при вызове **SQLGetInfo** с *инфотипе* SQL_GETDATA_EXTENSIONS был возвращен SQL_GD_BLOCK. (Дополнительные сведения см. в разделе [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md).)  
  
 Для каждого привязанного столбца в строке **SQLFetch** выполняет следующие действия:  
  
1.  Задает SQL_NULL_DATA буфера длины или индикатора и переходит к следующему столбцу, если данные имеют значение NULL. Если данные имеют значение NULL и ни один буфер индикатора не был привязан, **SQLFetch** ВОЗВРАЩАЕТ значение SQLSTATE 22002 (для переменной индикатора требуется, но не указано) для строки и переходит к следующей строке. Сведения о том, как определить адрес буфера длины и индикатора, см. в разделе "буферные адреса" в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
     Если данные для столбца не равны NULL, **SQLFetch** переходит к шагу 2.  
  
2.  Если атрибуту инструкции SQL_ATTR_MAX_LENGTH присвоено ненулевое значение, а столбец содержит символьные или двоичные данные, данные усекаются до SQL_ATTR_MAX_LENGTH байтов.  
  
    > [!NOTE]  
    >  Атрибут инструкции SQL_ATTR_MAX_LENGTH предназначен для уменьшения сетевого трафика. Обычно он реализуется с помощью источника данных, который усекает данные перед их возвратом по сети. Драйверы и источники данных не обязательно должны поддерживать их. Таким образом, чтобы гарантировать усечение данных до определенного размера, приложение должно выделить буфер этого размера и указать размер в аргументе *кбвалуемакс* в **SQLBindCol**.  
  
3.  Преобразует данные в тип, указанный *TargetType* в **SQLBindCol**.  
  
4.  Если данные были преобразованы в тип данных переменной длины, например символьный или двоичный, **SQLFetch** проверяет, превышает ли длина данных длину буфера данных. Если длина символьных данных (включая завершающий символ null) превышает длину буфера данных, **SQLFetch** усекает данные до длины буфера данных, чем длина символа завершения null. Затем значение NULL завершает данные. Если длина двоичных данных превышает длину буфера данных, **SQLFetch** усекает его до длины буфера данных. Длина буфера данных указывается с помощью *BufferLength* в **SQLBindCol**.  
  
     **SQLFetch** никогда не усекает данные, преобразованные в типы данных фиксированной длины; всегда предполагается, что длина буфера данных равна размеру типа данных.  
  
5.  Помещает в буфер данных преобразованные (и, возможно, усеченные) данные. Сведения о том, как определить адрес буфера данных, см. в разделе "буферные адреса" в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
6.  Помещает длину данных в буфер длины или индикатора. Если указатель индикатора и указатель длины были установлены в один и тот же буфер (как вызов **SQLBindCol** ), то длина записывается в буфер для допустимых данных, а SQL_NULL_DATA записывается в буфер для данных null. Если ни один буфер индикатора не был привязан, **SQLFetch** не возвращает длину.  
  
    -   Для символьных или двоичных данных это длина данных после преобразования и до усечения из-за того, что буфер данных слишком мал. Если драйвер не может определить длину данных после преобразования, как это иногда бывает в случае с длинными данными, то длина задает SQL_NO_TOTAL. Если данные были усечены из-за атрибута SQL_ATTR_MAX_LENGTH инструкции, значение этого атрибута помещается в буфер длины или индикатора, а не на фактическую длину. Это обусловлено тем, что этот атрибут предназначен для усечения данных на сервере до преобразования, поэтому драйвер не может определить фактическую длину.  
  
    -   Для всех других типов данных это длина данных после преобразования. то есть это размер типа, в который были преобразованы данные.  
  
     Сведения о том, как определить адрес буфера длины и индикатора, см. в разделе "буферные адреса" в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
7.  Если данные усекаются во время преобразования без потери значащих цифр (например, вещественное число 1,234 усекается до целого числа после преобразования), **SQLFetch** ВОЗВРАЩАЕТ значение SQLSTATE 01S07 (усечение дробной части) и SQL_SUCCESS_WITH_INFO. Если данные усечены из-за слишком маленького размера буфера данных (например, строка «abcdef» помещается в 4-байтовый буфер), **SQLFetch** ВОЗВРАЩАЕТ значение SQLSTATE 01004 (усечение данных) и SQL_SUCCESS_WITH_INFO. Если данные усекаются из-за атрибута SQL_ATTR_MAX_LENGTH инструкции, **SQLFetch** возвращает SQL_SUCCESS и не ВОЗВРАЩАЕТ значение SQLSTATE 01S07 (Частичное усечение) или SQLSTATE 01004 (усечение данных). Если данные усекаются во время преобразования с потерей значащих цифр (например, если SQL_INTEGER значение больше 100 000 были преобразованы в SQL_C_TINYINT), **SQLFetch** возвращает SQLSTATE 22003 (числовое значение за пределами диапазона) и SQL_ERROR (если размер набора строк равен 1) или SQL_SUCCESS_WITH_INFO (если размер набора строк больше 1).  
  
 Содержимое привязанного буфера данных и буфера длины и индикатора не определено, если **SQLFetch** или **SQLFetchScroll** не возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
## <a name="row-status-array"></a>Массив статусов строк  
 Массив состояния строк используется для возврата состояния каждой строки в наборе строк. Адрес этого массива указывается с помощью атрибута инструкции SQL_ATTR_ROW_STATUS_PTR. Массив выделяется приложением и должен иметь столько же элементов, сколько указано в атрибуте инструкции SQL_ATTR_ROW_ARRAY_SIZE. Его значения задаются с помощью **SQLFetch**, **SQLFetchScroll** и **SQLBulkOperations** или **SQLSetPos** (за исключением случаев, когда они были вызваны после того, как курсор был помещен в **SQLExtendedFetch**). Если значение атрибута инструкции SQL_ATTR_ROW_STATUS_PTR является пустым указателем, эти функции не возвращают состояние строки.  
  
 Содержимое буфера массива строк состояния не определено, если **SQLFetch** или **SQLFetchScroll** не возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 В массиве состояния строк возвращаются следующие значения.  
  
|Значение массива состояния строки|Описание|  
|----------------------------|-----------------|  
|SQL_ROW_SUCCESS|Строка была успешно получена и не изменилась со времени последней выборки из этого результирующего набора.|  
|SQL_ROW_SUCCESS_WITH_INFO|Строка была успешно получена и не изменилась со времени последней выборки из этого результирующего набора. Однако в строке было возвращено предупреждение.|  
|SQL_ROW_ERROR|Произошла ошибка при выборке строки.|  
|SQL_ROW_UPDATED [1], [2] и [3]|Строка была успешно получена и изменилась со времени последней выборки из этого результирующего набора. Если строка извлекается из этого результирующего набора или обновляется с помощью функции **SQLSetPos**, состояние изменяется на новое состояние строки.|  
|SQL_ROW_DELETED [3]|Строка была удалена с момента последней выборки из этого результирующего набора.|  
|SQL_ROW_ADDED [4]|Строка была вставлена с помощью **SQLBulkOperations**. Если строка извлекается из этого результирующего набора или обновляется с помощью функции **SQLSetPos**, ее состояние — SQL_ROW_SUCCESS.|  
|SQL_ROW_NOROW|Набор строк, перекрывающийся с концом результирующего набора, и ни одна строка не была возвращена, соответствующая этому элементу массива состояния строки.|  
  
 [1] для набора ключей, смешанных и динамических курсоров, если значение ключа Обновлено, строка данных считается удаленной и добавляется новая строка.  
  
 [2] некоторые драйверы не могут обнаруживать обновления данных и поэтому не могут возвращать это значение. Чтобы определить, может ли драйвер обнаружить обновления для повторной выборки строк, приложение вызывает **SQLGetInfo** с параметром SQL_ROW_UPDATES.  
  
 [3]   **SQLFetch** может возвращать это значение только в том случае, если оно смешано с вызовами **SQLFetchScroll**. Это происходит потому, что **SQLFetch** перемещается вперед по результирующему набору, а когда он используется исключительно, не выполняет повторное извлечение строк. Так как ни одна строка не перегружается, **SQLFetch** не обнаруживает изменения, внесенные в ранее полученные строки. Однако если **SQLFetchScroll** помещает курсор перед любыми ранее полученными строками, а **SQLFetch** используется для выборки этих строк, **SQLFetch** может обнаружить изменения в этих строках.  
  
 [4] возвращается только с помощью SQLBulkOperations. Не задается **SQLFetch** или **SQLFetchScroll**.  
  
### <a name="rows-fetched-buffer"></a>Буфер выборки строк  
 Буфер с извлечением строк используется для возврата количества извлекаемых строк, включая строки, для которых не было возвращено никаких данных из-за ошибки, произошедшей при их выборке. Иными словами, это число строк, для которых значение в массиве состояния строки не SQL_ROW_NOROW. Адрес этого буфера указывается с помощью атрибута инструкции SQL_ATTR_ROWS_FETCHED_PTR. Буфер выделяется приложением. Он задается **SQLFetch** и **SQLFetchScroll**. Если значение атрибута оператора SQL_ATTR_ROWS_FETCHED_PTR является пустым указателем, эти функции не возвращают число извлекаемых строк. Чтобы определить номер текущей строки в результирующем наборе, приложение может вызвать **SQLGetStmtAttr** с помощью атрибута SQL_ATTR_ROW_NUMBER.  
  
 Содержимое буфера, полученного в результате строк, не определено, если **SQLFetch** или **SQLFetchScroll** не возвращают SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, за исключением случаев, когда возвращается SQL_NO_DATA, в этом случае значение в буфере, выбранном в качестве буфера, устанавливается равным 0.  
  
### <a name="error-handling"></a>Обработка ошибок  
 Ошибки и предупреждения могут применяться к отдельным строкам или ко всей функции. Дополнительные сведения о диагностических записях см. в разделе [Diagnostics](../../../odbc/reference/develop-app/diagnostics.md) and [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
#### <a name="errors-and-warnings-on-the-entire-function"></a>Ошибки и предупреждения для всей функции  
 Если ошибка применяется ко всей функции, например SQLSTATE HYT00 (время ожидания истекло) или SQLSTATE 24000 (недопустимое состояние курсора), **SQLFetch** возвращает SQL_ERROR и применимое значение SQLSTATE. Содержимое буферов наборов строк не определено, а позиции курсора не меняются.  
  
 Если предупреждение применяется ко всей функции, **SQLFetch** возвращает SQL_SUCCESS_WITH_INFO и применимое значение SQLSTATE. Записи о состоянии для предупреждений, применимых ко всей функции, возвращаются перед записями состояния, которые применяются к отдельным строкам.  
  
#### <a name="errors-and-warnings-in-individual-rows"></a>Ошибки и предупреждения в отдельных строках  
 Если ошибка (например, SQLSTATE 22012 (деление на ноль)) или предупреждение (например, SQLSTATE 01004 (усечение данных)) применяется к одной строке, **SQLFetch** выполняет следующие действия:  
  
-   Устанавливает соответствующий элемент массива состояния строки для SQL_ROW_ERROR ошибок или SQL_ROW_SUCCESS_WITH_INFO для предупреждений.  
  
-   Добавляет ноль или более записей состояния, содержащих SQLSTATE для ошибки или предупреждения.  
  
-   Задает поля номера строки и столбца в записях состояния. Если **SQLFetch** не может определить номер строки или столбца, он устанавливает это число в SQL_ROW_NUMBER_UNKNOWN или SQL_COLUMN_NUMBER_UNKNOWN соответственно. Если запись Status не относится к определенному столбцу, **SQLFetch** устанавливает номер столбца в значение SQL_NO_COLUMN_NUMBER.  
  
 **SQLFetch** возобновляет выборку строк до тех пор, пока не будут получены все строки в наборе строк. Он возвращает SQL_SUCCESS_WITH_INFO, если только ошибка не возникает в каждой строке набора строк (не включая строки с состоянием SQL_ROW_NOROW). в этом случае возвращается SQL_ERROR. В частности, если размер набора строк равен 1, а в этой строке возникает ошибка, **SQLFetch** возвращает SQL_ERROR.  
  
 **SQLFetch** возвращает записи состояния в порядке номеров строк. То есть он возвращает все записи состояния для неизвестных строк (если они есть); Затем он возвращает все записи состояния для первой строки (если таковой имеется), а затем возвращает все записи состояния для второй строки (если есть) и т. д. Записи состояния для каждой строки упорядочиваются в соответствии с обычными правилами упорядочения записей о состоянии. Дополнительные сведения см. в разделе "последовательность записей состояния" в [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
### <a name="descriptors-and-sqlfetch"></a>Дескрипторы и SQLFetch  
 В следующих разделах описывается взаимодействие **SQLFetch** с дескрипторами.  
  
#### <a name="argument-mappings"></a>Сопоставления аргументов  
 Драйвер не устанавливает никакие поля дескриптора на основе аргументов **SQLFetch**.  
  
#### <a name="other-descriptor-fields"></a>Другие поля дескриптора  
 **SQLFetch** использует следующие поля дескрипторов.  
  
|Поле дескриптора|Desc.|Поле в|Задать через|  
|----------------------|-----------|--------------|-----------------|  
|SQL_DESC_ARRAY_SIZE|ард|заголовок|Атрибут инструкции SQL_ATTR_ROW_ARRAY_SIZE|  
|SQL_DESC_ARRAY_STATUS_PTR|IRD|заголовок|Атрибут инструкции SQL_ATTR_ROW_STATUS_PTR|  
|SQL_DESC_BIND_OFFSET_PTR|ард|заголовок|Атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR|  
|SQL_DESC_BIND_TYPE|ард|заголовок|Атрибут инструкции SQL_ATTR_ROW_BIND_TYPE|  
|SQL_DESC_COUNT|ард|заголовок|Аргумент *columnNumber* объекта **SQLBindCol**|  
|SQL_DESC_DATA_PTR|ард|records|Аргумент *таржетвалуептр* объекта **SQLBindCol**|  
|SQL_DESC_INDICATOR_PTR|ард|records|*StrLen_or_IndPtr* аргумент в **SQLBindCol**|  
|SQL_DESC_OCTET_LENGTH|ард|records|Аргумент *BufferLength* в **SQLBindCol**|  
|SQL_DESC_OCTET_LENGTH_PTR|ард|records|*StrLen_or_IndPtr* аргумент в **SQLBindCol**|  
|SQL_DESC_ROWS_PROCESSED_PTR|IRD|заголовок|Атрибут инструкции SQL_ATTR_ROWS_FETCHED_PTR|  
|SQL_DESC_TYPE|ард|records|Аргумент *TargetType* в **SQLBindCol**|  
  
 Все поля дескриптора также можно задать с помощью **SQLSetDescField**.  
  
#### <a name="separate-length-and-indicator-buffers"></a>Отдельные буферы длины и индикатора  
 Приложения могут привязывать один буфер или два отдельных буфера, которые можно использовать для хранения значений длины и индикатора. Когда приложение вызывает **SQLBindCol**, драйвер задает для полей SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR объекта АРД тот же адрес, который передается в аргументе *StrLen_or_IndPtr* . Когда приложение вызывает **SQLSetDescField** или **SQLSetDescRec**, оно может установить для этих двух полей разные адреса.  
  
 **SQLFetch** определяет, задается ли в приложении отдельные буферы длины и индикатора. В этом случае, если данные не равны NULL, **SQLFetch** устанавливает буфер индикатора равным 0 и возвращает длину в буфере длины. Если данные имеют значение NULL, **SQLFetch** устанавливает буфер индикатора в значение SQL_NULL_DATA и не изменяет буфер длины.  
  
### <a name="code-example"></a>Пример кода  
 См. раздел [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md), [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)и [SQLProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md).  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующем наборе|[SQLDescribeCol, функция](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Закрытие курсора в операторе|[SQLFreeStmt, функция](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Выборка части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращение количества столбцов результирующего набора|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
