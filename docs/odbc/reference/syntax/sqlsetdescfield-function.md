---
description: Функция SQLSetDescField
title: Функция SQLSetDescField | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLSetDescField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetDescField
helpviewer_keywords:
- SQLSetDescField function [ODBC]
ms.assetid: 8c544388-fe9d-4f94-a0ac-fa0b9c9c88a5
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: bd48da2caec1acba5cfe775a2baa1efaaf886aab
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99200969"
---
# <a name="sqlsetdescfield-function"></a>Функция SQLSetDescField

**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 3,0: ISO 92  
  
 **Сводка**  
 **SQLSetDescField** задает значение одного поля записи дескриптора.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
SQLRETURN SQLSetDescField(  
     SQLHDESC      DescriptorHandle,  
     SQLSMALLINT   RecNumber,  
     SQLSMALLINT   FieldIdentifier,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    BufferLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *DescriptorHandle*  
 Входной Дескриптор дескриптора.  
  
 *RecNumber*  
 Входной Указывает запись дескриптора, содержащей поле, которое задает приложение. Записи дескрипторов нумеруются с 0, а номер записи 0 — запись закладки. Аргумент *рекнумбер* игнорируется для полей заголовка.  
  
 *FieldIdentifier*  
 Входной Указывает поле дескриптора, значение которого должно быть задано. Дополнительные сведения см. в разделе "аргумент *фиелдидентифиер* " раздела "Комментарии".  
  
 *ValuePtr*  
 Входной Указатель на буфер, содержащий сведения о дескрипторе, или целочисленное значение. Тип данных зависит от значения *фиелдидентифиер*. Если *ValuePtr* имеет целочисленное значение, его можно считать 8 байтами (SQLLEN), 4 байтами (SQLINTEGER) или 2 байтами (SQLSMALLINT) в зависимости от значения аргумента *фиелдидентифиер* .  
  
 *BufferLength*  
 Входной Если *фиелдидентифиер* является определяемым ODBC полем, а *ValuePtr* указывает на символьную строку или двоичный буфер, этот аргумент должен иметь длину **ValuePtr*. Для символьных строковых данных этот аргумент должен содержать число байтов в строке.  
  
 Если *фиелдидентифиер* является определяемым ODBC полем, а *ValuePtr* — целым числом, *BufferLength* игнорируется.  
  
 Если *фиелдидентифиер* является полем, определенным драйвером, приложение указывает природу поля в диспетчере драйверов, установив аргумент *BufferLength* . *BufferLength* могут иметь следующие значения:  
  
-   Если *ValuePtr* является указателем на символьную строку, *BufferLength* — это длина строки или SQL_NTS.  
  
-   Если *ValuePtr* является указателем на двоичный буфер, приложение помещает результат макроса SQL_LEN_BINARY_ATTR (*length*) в *BufferLength*. Это помещает отрицательное значение в *BufferLength*.  
  
-   Если *ValuePtr* является указателем на значение, отличное от символьной строки или двоичной строки, *BufferLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение фиксированной длины, то *BufferLength* является либо SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT, либо SQL_IS_USMALLINT, соответственно.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetDescField** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_DESC и *маркером* *дескрипторхандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLSetDescField** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Значение параметра изменено|Драйвер не поддерживал значение, указанное в *\* ValuePtr* (если *ValuePtr* был указателем), или значение в *ValuePtr* (если *ValuePtr* было целочисленным значением) или *\* ValuePtr* было недопустимым из-за работы условий реализации, поэтому драйвер подставляет аналогичное значение. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07009|Недопустимый индекс дескриптора|Аргумент *фиелдидентифиер* был полем записи, аргументом *рекнумбер* было 0, а аргумент *дескрипторхандле* ссылается на обработчик IPD.<br /><br /> Аргумент *рекнумбер* меньше 0, а аргумент *ДЕСКРИПТОРХАНДЛЕ* ссылается на АРД или APD.<br /><br /> Аргумент *рекнумбер* больше максимального числа столбцов или параметров, поддерживаемых источником данных, и аргумент *дескрипторхандле* , на который ссылается APD или АРД.<br /><br /> (DM) аргумент *фиелдидентифиер* был SQL_DESC_COUNT, а аргумент *\* ValuePtr* был меньше 0.<br /><br /> Аргумент *рекнумбер* равен 0, а аргумент *дескрипторхандле* ссылается на неявно выделенный APD. (Эта ошибка не возникает при явно выделенном дескрипторе приложения, так как неизвестно, является ли явно выделенный дескриптор приложения APD или АРД до времени выполнения.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|22001|Строковые данные, усеченные справа|Аргумент *фиелдидентифиер* был SQL_DESC_NAME, а аргумент *BufferLength* — значение, превышающее SQL_MAX_IDENTIFIER_LEN.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) *дескрипторхандле* был связан с *статеменсандле* , для которого была вызвана асинхронно исполняемая функция (а не эта одна) и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* , с которым связан *дескрипторхандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *дескрипторхандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLSetDescField** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для одного из дескрипторов инструкций, связанных с *дескрипторхандле* и возвращаемых SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY016|Невозможно изменить дескриптор строки реализации|Аргумент *дескрипторхандле* был связан с IRD, а аргумент *фиелдидентифиер* не SQL_DESC_ARRAY_STATUS_PTR или SQL_DESC_ROWS_PROCESSED_PTR.|  
|HY021|Непоследовательные сведения о дескрипторе|Поля SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE не формируют допустимый тип SQL ODBC или допустимый тип SQL для конкретного драйвера (для ИПДС) или допустимый тип ODBC C (для Апдс или АРДС).<br /><br /> Сведения о дескрипторе, проверенные во время проверки согласованности, не были согласованы. (См. раздел "Проверка согласованности" в **SQLSetDescRec**.)|  
|HY090|Недопустимая длина строки или буфера|(DM) *\* ValuePtr* является символьной строкой, а *BufferLength* имеет меньше нуля, но не равен SQL_NTS.<br /><br /> (DM) драйвер был драйвером ODBC 2 *. x* , дескриптор был АРД, аргумент *columnNumber* был установлен в 0, а значение, заданное для аргумента *BufferLength* , не равно 4.|  
|HY091|Недопустимый идентификатор поля дескриптора|Значение, указанное для аргумента *фиелдидентифиер* , не является полем, определяемым ODBC, и не является значением, определенным реализацией.<br /><br /> Аргумент *фиелдидентифиер* недопустим для аргумента *дескрипторхандле* .<br /><br /> Аргумент *фиелдидентифиер* был определяемым ODBC-полем только для чтения.|  
|HY092|Недопустимый идентификатор атрибута или параметра|Значение в *\* ValuePtr* недопустимо для аргумента *фиелдидентифиер* .<br /><br /> Аргумент *фиелдидентифиер* был SQL_DESC_UNNAMED, а *ValuePtr* — SQL_NAMED.|  
|HY105|Недопустимый тип параметра|(DM) указано недопустимое значение поля SQL_DESC_PARAMETER_TYPE. (Дополнительные сведения см. в разделе "аргумент *инпутаутпуттипе* " в **SQLBindParameter**.)|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. [в разделе новые возможности ODBC 3,8](../../../odbc/reference/what-s-new-in-odbc-3-8.md).|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *дескрипторхандле* , не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение может вызвать **SQLSetDescField** , чтобы задать любое поле дескриптора по одному за раз. Один вызов **SQLSetDescField** задает одно поле в одном дескрипторе. Эта функция может быть вызвана для установки любого поля любого типа дескриптора при условии, что поле может быть установлено. (См. таблицу далее в этом разделе.)  
  
> [!NOTE]  
>  Если вызов **SQLSetDescField** завершается неудачей, содержимое записи дескриптора, определяемой аргументом *рекнумбер* , не определено.  
  
 Другие функции могут быть вызваны для задания нескольких полей дескриптора с помощью одного вызова функции. Функция **SQLSetDescRec** устанавливает различные поля, которые влияют на тип данных и буфер, привязанные к столбцу или параметру (поля SQL_DESC_TYPE, SQL_DESC_DATETIME_INTERVAL_CODE, SQL_DESC_OCTET_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE, SQL_DESC_DATA_PTR, SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR). **SQLBindCol** или **SQLBindParameter** можно использовать для создания полной спецификации привязки столбца или параметра. Эти функции задают определенную группу полей дескриптора одним вызовом функции.  
  
 **SQLSetDescField** можно вызвать для изменения буфера привязки, добавив смещение к указателям привязки (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR или SQL_DESC_OCTET_LENGTH_PTR). Это изменяет буферы привязки без вызова **SQLBindCol** или **SQLBindParameter**, что позволяет приложению изменять SQL_DESC_DATA_PTR без изменения других полей, таких как SQL_DESC_DATA_TYPE.  
  
 Если приложение вызывает **SQLSetDescField** для установки любого поля, кроме SQL_DESC_COUNT или отложенных полей SQL_DESC_DATA_PTR, SQL_DESC_OCTET_LENGTH_PTR или SQL_DESC_INDICATOR_PTR, запись преобразуется в несвязанную.  
  
 Поля заголовков дескрипторов задаются путем вызова **SQLSetDescField** с соответствующим *фиелдидентифиер*. Многие поля заголовков также являются атрибутами операторов, поэтому их также можно задать с помощью вызова **SQLSetStmtAttr**. Это позволяет приложениям устанавливать поле дескриптора без предварительного получения дескриптора дескриптора. При вызове **SQLSetDescField** для задания поля заголовка аргумент *рекнумбер* игнорируется.  
  
 Для установки полей закладки используется *рекнумбер* , равный 0.  
  
> [!NOTE]  
>  Перед вызовом **SQLSetDescField** для установки полей закладок всегда следует задавать атрибут инструкции SQL_ATTR_USE_BOOKMARKS. Хотя это и не является обязательным, настоятельно рекомендуется.  
  
## <a name="sequence-of-setting-descriptor-fields"></a>Последовательность полей дескриптора параметров  
 При установке полей дескриптора путем вызова **SQLSetDescField** приложение должно следовать определенной последовательности:  
  
1.  Приложение должно сначала задать поле SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE или SQL_DESC_DATETIME_INTERVAL_CODE.  
  
2.  После установки одного из этих полей приложение может задать атрибут типа данных, а для полей атрибутов типа данных — соответствующие значения по умолчанию для типа данных. Автоматическое значение по умолчанию для полей атрибутов типа гарантирует, что дескриптор всегда готов к использованию после того, как приложение указало тип данных. Если приложение явно задает атрибут типа данных, он переопределяет атрибут по умолчанию.  
  
3.  После установки одного из полей, перечисленных в шаге 1, и установки атрибутов типа данных приложение может задать SQL_DESC_DATA_PTR. При этом запрашивается проверка согласованности полей дескриптора. Если приложение изменяет тип данных или атрибуты после установки поля SQL_DESC_DATA_PTR, драйвер устанавливает SQL_DESC_DATA_PTR в пустой указатель, отменяя привязку записи. Это заставляет приложение выполнять необходимые шаги последовательно, прежде чем использовать запись дескриптора.  
  
## <a name="initialization-of-descriptor-fields"></a>Инициализация полей дескриптора  
 При выделении дескриптора поля в дескрипторе могут быть инициализированы значением по умолчанию, инициализированы без значения по умолчанию или быть неопределенными для типа дескриптора. В следующих таблицах указывается инициализация каждого поля для каждого типа дескриптора с "D", указывающим на то, что поле инициализируется значением по умолчанию, а "ND" означает, что поле инициализировано без значения по умолчанию. Если число отображается, значением поля по умолчанию является это число. Таблицы также указывают, доступно ли поле для чтения и записи (R/W) или только для чтения (R).  
  
 Поля объекта IRD имеют значение по умолчанию только после подготовки или выполнения инструкции и заполнения IRD, а не при выделении дескриптора или дескриптора инструкции. До заполнения IRD любая попытка получить доступ к полю IRD будет возвращать ошибку.  
  
 Некоторые поля дескриптора определены для одного или нескольких (но не всех) типов дескрипторов (АРДС и Ирдс, а также Апдс и ИПДС). Если поле не определено для типа дескриптора, оно не требуется ни для одной из функций, использующих этот дескриптор.  
  
 Поля, к которым может получить доступ **SQLGetDescField** , не могут быть заданы с помощью **SQLSetDescField**. Поля, которые могут быть заданы **SQLSetDescField** , перечислены в следующих таблицах.  
  
 Инициализация полей заголовка описана в следующей таблице.  
  
|Имя поля заголовка|Тип|Чтение-запись|По умолчанию|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_ALLOC_TYPE|SQLSMALLINT|АРД: R APD: R IRD: R IPD: R|АРД: SQL_DESC_ALLOC_AUTO для явного или неявного SQL_DESC_ALLOC_USER<br /><br /> APD: SQL_DESC_ALLOC_AUTO для явного или неявного SQL_DESC_ALLOC_USER<br /><br /> IRD: SQL_DESC_ALLOC_AUTO<br /><br /> IPD: SQL_DESC_ALLOC_AUTO|  
|SQL_DESC_ARRAY_SIZE|SQLULEN|АРД: R/W APD: R/W IRD: неиспользуемая IPD: не используется|АРД: [1] APD: [1] IRD: неиспользуемая IPD: не используется|  
|SQL_DESC_ARRAY_STATUS_PTR|СКЛУСМАЛЛИНТ *|АРД: R/W APD: R/W IRD: R/W IPD: R/W|АРД: NULL PTR APD: NULL PTR IRD: NULL PTR IPD: NULL PTR|  
|SQL_DESC_BIND_OFFSET_PTR|SQLLEN|АРД: R/W APD: R/W IRD: неиспользуемая IPD: не используется|АРД: NULL PTR APD: NULL PTR IRD: неиспользуемая IPD: не используется|  
|SQL_DESC_BIND_TYPE|SQLINTEGER|АРД: R/W APD: R/W IRD: неиспользуемая IPD: не используется|АРД: SQL_BIND_BY_COLUMN<br /><br /> APD: SQL_BIND_BY_COLUMN<br /><br /> IRD: не используется<br /><br /> IPD: не используется|  
|SQL_DESC_COUNT|SQLSMALLINT|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: 0 APD: 0 IRD: D IPD: 0|  
|SQL_DESC_ROWS_PROCESSED_PTR|SQLULEN|АРД: неиспользуемый APD: неиспользуемый IRD: R/W IPD: R/W|АРД: неиспользуемая APD: неиспользуемая IRD: NULL PTR IPD: NULL PTR|  
  
 [1] эти поля определяются только при автоматическом заполнении IPD драйвером. В противном случае они не определены. Если приложение пытается установить эти поля, будет возвращено значение SQLSTATE HY091 (недопустимый идентификатор поля дескриптора).  
  
 Инициализация полей записей выполняется так же, как показано в следующей таблице.  
  
|Имя поля записи|Тип|Чтение-запись|По умолчанию|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_AUTO_UNIQUE_VALUE|SQLINTEGER|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_BASE_COLUMN_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_BASE_TABLE_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_CASE_SENSITIVE|SQLINTEGER|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: D [1]|  
|SQL_DESC_CATALOG_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_CONCISE_TYPE|SQLSMALLINT|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: SQL_C_ ПО УМОЛЧАНИЮ APD: SQL_C_ ПО УМОЛЧАНИЮ IRD: D IPD: ND|  
|SQL_DESC_DATA_PTR|склпоинтер|АРД: R/W APD: R/W IRD: неиспользуемая IPD: не используется|АРД: NULL PTR APD: NULL PTR IRD: неиспользуемая IPD: неиспользуемая [2]|  
|SQL_DESC_DATETIME_INTERVAL_CODE|SQLSMALLINT|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_DATETIME_INTERVAL_PRECISION|SQLINTEGER|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_DISPLAY_SIZE|SQLLEN|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_FIXED_PREC_SCALE|SQLSMALLINT|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: D [1]|  
|SQL_DESC_INDICATOR_PTR|SQLLEN|АРД: R/W APD: R/W IRD: неиспользуемая IPD: не используется|АРД: NULL PTR APD: NULL PTR IRD: неиспользуемая IPD: не используется|  
|SQL_DESC_LABEL|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_LENGTH|SQLULEN|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_LITERAL_PREFIX|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_LITERAL_SUFFIX|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_LOCAL_TYPE_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: D [1]|  
|SQL_DESC_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_NULLABLE|SQLSMALLINT|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_NUM_PREC_RADIX|SQLINTEGER|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_OCTET_LENGTH|SQLLEN|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_OCTET_LENGTH_PTR|SQLLEN|АРД: R/W APD: R/W IRD: неиспользуемая IPD: не используется|АРД: NULL PTR APD: NULL PTR IRD: неиспользуемая IPD: не используется|  
|SQL_DESC_PARAMETER_TYPE|SQLSMALLINT|АРД: неиспользуемая APD: неиспользуемая IRD: неиспользуемая IPD: R/W|АРД: неиспользуемый APD: неиспользуемый IRD: неиспользуемая IPD: D = SQL_PARAM_INPUT|  
|SQL_DESC_PRECISION|SQLSMALLINT|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_ROWVER|SQLSMALLINT|АРД: не используется<br /><br /> APD: не используется<br /><br /> IRD: R<br /><br /> IPD: R|АРД: не используется<br /><br /> APD: не используется<br /><br /> IRD: ND<br /><br /> IPD: ND|  
|SQL_DESC_SCALE|SQLSMALLINT|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_SCHEMA_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_SEARCHABLE|SQLSMALLINT|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_TABLE_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
|SQL_DESC_TYPE|SQLSMALLINT|АРД: R/W APD: R/W IRD: R IPD: R/W|АРД: SQL_C_DEFAULT APD: SQL_C_DEFAULT IRD: D IPD: ND|  
|SQL_DESC_TYPE_NAME|SQLCHAR|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: D [1]|  
|SQL_DESC_UNNAMED|SQLSMALLINT|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R/W|АРД: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_UNSIGNED|SQLSMALLINT|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: R|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: D [1]|  
|SQL_DESC_UPDATABLE|SQLSMALLINT|АРД: неиспользуемый APD: неиспользуемый IRD: R IPD: не используется|АРД: неиспользуемый APD: неиспользуемый IRD: D IPD: не используется|  
  
 [1] эти поля определяются только при автоматическом заполнении IPD драйвером. В противном случае они не определены. Если приложение пытается установить эти поля, будет возвращено значение SQLSTATE HY091 (недопустимый идентификатор поля дескриптора).  
  
 [2] SQL_DESC_DATA_PTR поле в IPD может быть настроено для принудительной проверки согласованности. В последующем вызове метода **SQLGetDescField** или **SQLGetDescRec** драйверу не требуется возвращать значение, которое SQL_DESC_DATA_PTR было задано как.  
  
## <a name="fieldidentifier-argument"></a>Фиелдидентифиер, аргумент  
 Аргумент *фиелдидентифиер* указывает поле дескриптора, которое необходимо задать. Дескриптор содержит *заголовок дескриптора,* состоящий из полей заголовка, описанных в следующем разделе, «поля заголовка» и ноль или более *записей дескрипторов,* состоящих из полей записей, описанных в разделе, приведенном ниже в разделе «поля заголовка».  
  
## <a name="header-fields"></a>Поля заголовка  
 Каждый дескриптор имеет заголовок, состоящий из следующих полей:  
  
 **SQL_DESC_ALLOC_TYPE [все]**  
 Это поле заголовка SQLSMALLINT только для чтения указывает, был ли дескриптор выделен автоматически драйвером или явным образом приложением. Это поле может быть получено, но не изменено приложением. Поле устанавливается в SQL_DESC_ALLOC_AUTO драйвером, если дескриптор был автоматически выделен драйвером. Он устанавливается в SQL_DESC_ALLOC_USER драйвером, если дескриптор был явно выделен приложением.  
  
 **SQL_DESC_ARRAY_SIZE [дескрипторы приложений]**  
 В АРДС это поле заголовка SQLULEN указывает количество строк в наборе строк. Это число строк, возвращаемых вызовом **SQLFetch** или **SQLFetchScroll** или для работы с помощью вызова **SQLBulkOperations** или **SQLSetPos**.  
  
 В Апдс в этом поле заголовка SQLULEN указывается количество значений для каждого параметра.  
  
 Значение этого поля по умолчанию равно 1. Если SQL_DESC_ARRAY_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR точки APD или АРД указывают на массивы. Количество элементов массива равно значению этого поля.  
  
 Это поле в АРД можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_ARRAY_SIZE. Это поле в APD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAMSET_SIZE.  
  
 **SQL_DESC_ARRAY_STATUS_PTR [все]**  
 Для каждого типа дескриптора это поле заголовка СКЛУСМАЛЛИНТ * указывает на массив значений СКЛУСМАЛЛИНТ. Эти массивы называются следующим образом: массив состояний строк (IRD), массив состояния параметра (IPD), массив операций со строками (АРД) и массив операций с параметрами (APD).  
  
 В IRD это поле заголовка указывает на массив состояний строк, содержащий значения состояния после вызова **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll** или **SQLSetPos**. Массив содержит столько элементов, сколько строк в наборе строк. Приложение должно выделить массив Склусмаллинтс и установить это поле, чтобы оно указывало на массив. По умолчанию для поля задан пустой указатель. Драйвер заполнит массив, если в поле SQL_DESC_ARRAY_STATUS_PTR не задан пустой указатель, в этом случае значения состояния не создаются и массив не заполняется.  
  
> [!CAUTION]  
>  Поведение драйвера не определено, если приложение задает элементы массива состояния строки, на который указывает SQL_DESC_ARRAY_STATUS_PTR поле IRD.  
  
 Массив первоначально заполняется вызовом **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll** или **SQLSetPos**. Если вызов не вернул SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на которое указывает это поле, не определено. Элементы в массиве могут содержать следующие значения:  
  
-   SQL_ROW_SUCCESS: строка была успешно получена и не изменилась со времени последней выборки.  
  
-   SQL_ROW_SUCCESS_WITH_INFO: строка была успешно получена и не изменилась со времени последней выборки. Однако в строке было возвращено предупреждение.  
  
-   SQL_ROW_ERROR: произошла ошибка при выборке строки.  
  
-   SQL_ROW_UPDATED: строка была успешно получена и была обновлена с момента последней выборки. Если строка выбирается снова, ее состояние — SQL_ROW_SUCCESS.  
  
-   SQL_ROW_DELETED: строка была удалена с момента последней выборки.  
  
-   SQL_ROW_ADDED: строка была вставлена с помощью **SQLBulkOperations**. Если строка выбирается снова, ее состояние — SQL_ROW_SUCCESS.  
  
-   SQL_ROW_NOROW: набор строк, перекрывающийся с концом результирующего набора, и ни одна строка не была возвращена, соответствующая этому элементу массива состояния строки.  
  
 Это поле в IRD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_STATUS_PTR.  
  
 Поле SQL_DESC_ARRAY_STATUS_PTR IRD допустимо только после возврата SQL_SUCCESS или SQL_SUCCESS_WITH_INFO. Если код возврата не является одним из указанных, расположение, на которое указывает SQL_DESC_ROWS_PROCESSED_PTR, не определено.  
  
 В поле "IPD" Этот заголовок указывает на массив состояний параметров, содержащий сведения о состоянии для каждого набора значений параметров после вызова **SQLExecute** или **SQLExecDirect**. Если вызов **SQLExecute** или **SQLExecDirect** не вернул SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на которое указывает это поле, не определено. Приложение должно выделить массив Склусмаллинтс и установить это поле, чтобы оно указывало на массив. Драйвер заполнит массив, если в поле SQL_DESC_ARRAY_STATUS_PTR не задан пустой указатель, в этом случае значения состояния не создаются и массив не заполняется. Элементы в массиве могут содержать следующие значения:  
  
-   SQL_PARAM_SUCCESS: инструкция SQL успешно выполнена для этого набора параметров.  
  
-   SQL_PARAM_SUCCESS_WITH_INFO: инструкция SQL успешно выполнена для этого набора параметров; Однако сведения о предупреждениях доступны в структуре диагностических данных.  
  
-   SQL_PARAM_ERROR: произошла ошибка при обработке этого набора параметров. Дополнительные сведения об ошибке доступны в структуре диагностических данных.  
  
-   SQL_PARAM_UNUSED: этот набор параметров был неиспользованным, возможно, из-за того, что некоторые из предыдущих наборов параметров привели к ошибке, которая прекратила дальнейшую обработку, или потому, что SQL_PARAM_IGNORE был задан для этого набора параметров в массиве, указанном в поле SQL_DESC_ARRAY_STATUS_PTR APD.  
  
-   SQL_PARAM_DIAG_UNAVAILABLE: диагностические сведения недоступны. Примером этого является то, что драйвер обрабатывает массивы параметров как монолитную единицу и поэтому не создает этот уровень сведений об ошибках.  
  
 Это поле в IPD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_STATUS_PTR.  
  
 В АРД это поле заголовка указывает на массив значений строк, которые могут быть заданы приложением, чтобы указать, будет ли эта строка пропускаться для операций **SQLSetPos** . Элементы в массиве могут содержать следующие значения:  
  
-   SQL_ROW_PROCEED: строка включается в групповые операции с помощью функции **SQLSetPos**. (Этот параметр не гарантирует, что операция будет выполняться в строке. Если строка имеет состояние SQL_ROW_ERROR в массиве состояния строки IRD, драйвер не может выполнить операцию в строке.)  
  
-   SQL_ROW_IGNORE: строка исключается из групповой операции с помощью функции **SQLSetPos**.  
  
 Если ни один элемент массива не задан, в операцию групповой операции включаются все строки. Если значение в поле SQL_DESC_ARRAY_STATUS_PTR АРД является пустым указателем, все строки включаются в состав групповой операции. Интерпретация будет такой же, как если бы указатель указывал на допустимый массив, а все элементы массива были SQL_ROW_PROCEED. Если элемент массива имеет значение SQL_ROW_IGNORE, значение в массиве состояния строки для игнорируемой строки не изменяется.  
  
 Это поле в АРД можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_OPERATION_PTR.  
  
 В поле заголовка APD указывает на массив операций с параметрами, который может быть задан приложением, чтобы указать, следует ли игнорировать этот набор параметров при вызове **SQLExecute** или **SQLExecDirect** . Элементы в массиве могут содержать следующие значения:  
  
-   SQL_PARAM_PROCEED: набор параметров включается в вызов **SQLExecute** или **SQLExecDirect** .  
  
-   SQL_PARAM_IGNORE: набор параметров исключается из вызова **SQLExecute** или **SQLExecDirect** .  
  
 Если элементы массива не заданы, все наборы параметров в массиве используются в вызовах **SQLExecute** или **SQLExecDirect** . Если значение в поле SQL_DESC_ARRAY_STATUS_PTR APD является пустым указателем, используются все наборы параметров; Интерпретация будет такой же, как если бы указатель указывал на допустимый массив, а все элементы массива были SQL_PARAM_PROCEED.  
  
 Это поле в APD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_OPERATION_PTR.  
  
 **SQL_DESC_BIND_OFFSET_PTR [дескрипторы приложений]**  
 Это поле заголовка SQLLEN * указывает на смещение привязки. По умолчанию задан пустой указатель. Если это поле не является пустым указателем, драйвер удаляет ссылку на указатель и добавляет значение разыменования в каждое из отложенных полей, имеющих значение, отличное от NULL, в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) во время выборки и использует новые значения указателя при привязке.  
  
 Смещение привязки всегда добавляется непосредственно к значениям в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется на другое значение, новое значение по-прежнему добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется к значению поля и любому предыдущему смещению.  
  
 Это *Отложенное поле*: оно не используется во время его установки, но используется в дальнейшем драйвером, когда ему необходимо определить адреса для буферов данных.  
  
 Это поле в АРД можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_BIND_OFFSET_PTR. Это поле в АРД можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_BIND_OFFSET_PTR.  
  
 Дополнительные сведения см. в описании привязки на уровне строки в [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md) и [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md).  
  
 **SQL_DESC_BIND_TYPE [дескрипторы приложений]**  
 Это поле заголовка SQLUINTEGER задает ориентацию привязки, которая будет использоваться для привязки столбцов или параметров.  
  
 В АРДС это поле Указывает ориентацию привязки при вызове **SQLFetchScroll** или **SQLFetch** в соответствующем обработчике инструкции.  
  
 Чтобы выбрать привязку на уровне столбца для столбцов, этому полю присваивается значение SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Это поле в АРД можно также задать, вызвав **SQLSetStmtAttr** с *атрибутом* SQL_ATTR_ROW_BIND_TYPE.  
  
 В Апдс это поле Указывает ориентацию привязки, используемую для динамических параметров.  
  
 Чтобы выбрать привязку на уровне столбца для параметров, этому полю присваивается значение SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Это поле в APD можно также задать, вызвав **SQLSetStmtAttr** с *атрибутом* SQL_ATTR_PARAM_BIND_TYPE.  
  
 **SQL_DESC_COUNT [все]**  
 Это поле заголовка SQLSMALLINT Указывает отсчитываемый от 1 индекс записи с наибольшим номером, содержащей данные. Когда драйвер задает структуру данных для дескриптора, она также должна установить поле SQL_DESC_COUNT, чтобы увидеть, сколько записей имеет большое значение. Когда приложение выделяет экземпляр этой структуры данных, ему не нужно указывать количество записей для резервирования комнаты. Так как приложение указывает содержимое записей, драйвер выполняет все необходимые действия, чтобы дескриптор дескриптора ссылался на структуру данных соответствующего размера.  
  
 SQL_DESC_COUNT не является счетчиком всех связанных столбцов данных (если поле находится в АРД) или всех связанных с ним параметров (если поле находится в APD), но число с наибольшим числом записей. Если столбец или параметр с самым высоким номером не привязан, то SQL_DESC_COUNT меняется на номер следующего самого высокого или параметра с наибольшим номером. Если столбец или параметр с числом, меньшим, чем число столбцов с наибольшим номером, не привязано (путем вызова **SQLBindCol** с аргументом *таржетвалуептр* , для которого задан пустой указатель, или **SQLBindParameter** с аргументом *параметервалуептр* , для которого задан пустой указатель), SQL_DESC_COUNT не изменяется. Если дополнительные столбцы или параметры связаны с числами больше, чем самая длинная запись, содержащая данные, драйвер автоматически увеличивает значение в поле SQL_DESC_COUNT. Если все столбцы не связаны путем вызова **SQLFreeStmt** с параметром SQL_UNBIND, SQL_DESC_COUNT полям АРД и IRD присваивается значение 0. Если **SQLFreeStmt** вызывается с параметром SQL_RESET_PARAMS, SQL_DESC_COUNT полям APD и IPD присваивается значение 0.  
  
 Значение в SQL_DESC_COUNT может быть задано явным образом приложением путем вызова **SQLSetDescField**. Если значение в SQL_DESC_COUNT явно уменьшилось, то все записи с числами, превышающими новое значение в SQL_DESC_COUNT, фактически удаляются. Если значение в SQL_DESC_COUNT явно равно 0 и поле находится в АРД, освобождаются все буферы данных, за исключением привязанного столбца закладки.  
  
 Число записей в этом поле АРД не включает в себя связанный столбец закладки. Единственный способ отменить привязку к столбцу закладки — задать поле SQL_DESC_DATA_PTR равным пустому указателю.  
  
 **SQL_DESC_ROWS_PROCESSED_PTR [дескрипторы реализации]**  
 В IRD это \* поле заголовка SQLULEN указывает на буфер, содержащий количество строк, выбранных после вызова **SQLFetch** или **SQLFetchScroll**, или количество строк, затронутых в ходе выполнения групповой операции, выполненных вызовом функции **SQLBulkOperations** или **SQLSetPos**, включая строки ошибок.  
  
 В этом поле заголовков IPD это SQLUINTEGER * указывает на буфер, содержащий количество обработанных параметров, включая наборы ошибок. Если это указатель null, число не будет возвращено.  
  
 SQL_DESC_ROWS_PROCESSED_PTR допустимы только после того, как SQL_SUCCESS или SQL_SUCCESS_WITH_INFO возвращены после вызова **SQLFetch** или **SQLFetchScroll** (для поля IRD) или **SQLExecute**, **SQLExecDirect** или **метод SQLParamData** (для поля IPD). Если вызов, который заполняет буфер, на который указывает это поле, не возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено, если оно не возвращает SQL_NO_DATA, в противном случае значение в буфере задается равным 0.  
  
 Это поле в АРД можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROWS_FETCHED_PTR. Это поле в APD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAMS_PROCESSED_PTR.  
  
 Буфер, на который указывает это поле, выделяется приложением. Это отложенный выходной буфер, заданный драйвером. По умолчанию задан пустой указатель.  
  
## <a name="record-fields"></a>Поля записей  
 Каждый дескриптор содержит одну или несколько записей, состоящих из полей, которые определяют либо данные столбца, либо динамические параметры в зависимости от типа дескриптора. Каждая запись является полным определением одного столбца или параметра.  
  
 **SQL_DESC_AUTO_UNIQUE_VALUE [Ирдс]**  
 Это поле записи SQLINTEGER только для чтения содержит SQL_TRUE, если столбец является столбцом с автоматическим приращением, или SQL_FALSE, если столбец не является автоматически увеличивающимся столбцом. Это поле доступно только для чтения, но базовый столбец с автоматическим приращением не обязательно должен быть доступен только для чтения.  
  
 **SQL_DESC_BASE_COLUMN_NAME [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит имя базового столбца для столбца результирующего набора. Если имя базового столбца не существует (как в случае столбцов, которые являются выражениями), эта переменная содержит пустую строку.  
  
 **SQL_DESC_BASE_TABLE_NAME [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит имя базовой таблицы для столбца результирующего набора. Если имя базовой таблицы не может быть определено или неприменимо, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CASE_SENSITIVE [дескрипторы реализации]**  
 Это поле записи SQLINTEGER, доступное только для чтения, содержит SQL_TRUE, если столбец или параметр обрабатывается как регистр для параметров сортировки и сравнений, или SQL_FALSE, если столбец не обрабатывается как регистр для параметров сортировки и сравнений или является несимвольным столбцом.  
  
 **SQL_DESC_CATALOG_NAME [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит каталог для базовой таблицы, содержащей столбец. Возвращаемое значение зависит от драйвера, если столбец является выражением или если столбец является частью представления. Если источник данных не поддерживает каталоги или не удается определить каталог, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CONCISE_TYPE [все]**  
 В этом поле заголовка SQLSMALLINT указан краткий тип данных для всех типов данных, включая типы данных DateTime и Interval.  
  
 Значения в полях SQL_DESC_CONCISE_TYPE, SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE являются взаимозависимыми. При каждом задании одного из полей также должно быть задано другое. SQL_DESC_CONCISE_TYPE можно задать с помощью вызова **SQLBindCol** или **SQLBindParameter** или **SQLSetDescField**. SQL_DESC_TYPE можно задать с помощью вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Если SQL_DESC_CONCISE_TYPE имеет тип данных краткая, отличный от типа данных Interval или DateTime, то в поле SQL_DESC_TYPE задается то же значение, а в поле SQL_DESC_DATETIME_INTERVAL_CODE устанавливается значение 0.  
  
 Если для SQL_DESC_CONCISE_TYPE задан тип данных Краткая дата и время или интервал, в поле SQL_DESC_TYPE устанавливается соответствующий подробный тип (SQL_DATETIME или SQL_INTERVAL), а в поле SQL_DESC_DATETIME_INTERVAL_CODE устанавливается соответствующий код.  
  
 **SQL_DESC_DATA_PTR [дескрипторы приложений и ИПДС]**  
 Это поле записи СКЛПОИНТЕР указывает на переменную, которая будет содержать значение параметра (для Апдс) или значение столбца (для АРДС). Это *Отложенное поле*. Он не используется в тот момент, когда он задан, но используется в дальнейшем драйвером для получения данных.  
  
 Столбец, указанный в поле SQL_DESC_DATA_PTR АРД, не привязан, если аргумент *таржетвалуептр* в вызове **SQLBindCol** является пустым указателем или если поле SQL_DESC_DATA_PTR в АРД задается вызовом **SQLSetDescField** или **SQLSetDescRec** в указатель null. Другие поля не затрагиваются, если в поле SQL_DESC_DATA_PTR задан пустой указатель.  
  
 Если вызов **SQLFetch** или **SQLFetchScroll** , который заполняет буфер, на который указывает это поле, не вернул SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.  
  
 Всякий раз, когда задается поле SQL_DESC_DATA_PTR APD, АРД или IPD, драйвер проверяет, что значение в поле SQL_DESC_TYPE содержит один из допустимых типов данных ODBC C или конкретного типа данных драйвера, и что все остальные поля, влияющие на типы данных, являются согласованными. Запрос проверки согласованности является единственным использованием SQL_DESC_DATA_PTR поля IPD. В частности, если приложение задает SQL_DESC_DATA_PTR поле для IPD и позднее вызывает **SQLGetDescField** для этого поля, оно не обязательно возвращает значение, которое было задано. Дополнительные сведения см. в разделе "проверки согласованности" в [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
 **SQL_DESC_DATETIME_INTERVAL_CODE [все]**  
 Это поле записи SQLSMALLINT содержит код для конкретного типа данных DateTime или Interval, когда SQL_DESC_TYPE поле SQL_DATETIME или SQL_INTERVAL. Это справедливо для типов данных SQL и C. Код состоит из имени типа данных с "CODE", подставляемого для "TYPE" или "C_TYPE" (для типов DateTime), или "CODE", который подставляется для "INTERVAL" или "C_INTERVAL" (для типов интервалов).  
  
 Если SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE в дескрипторе приложения установлены на SQL_C_DEFAULT и дескриптор не связан с дескриптором инструкции, содержимое SQL_DESC_DATETIME_INTERVAL_CODE не определено.  
  
 Это поле можно задать для типов данных DateTime, перечисленных в следующей таблице.  
  
|Типы даты и времени|DATETIME_INTERVAL_CODE|  
|--------------------|------------------------------|  
|SQL_TYPE_DATE И SQL_C_TYPE_DATE|SQL_CODE_DATE|  
|SQL_TYPE_TIME И SQL_C_TYPE_TIME|SQL_CODE_TIME|  
|SQL_TYPE_TIMESTAMP И SQL_C_TYPE_TIMESTAMP|SQL_CODE_TIMESTAMP|  
  
 Это поле можно задать для типов данных интервалов, перечисленных в следующей таблице.  
  
|Тип интервала|DATETIME_INTERVAL_CODE|  
|-------------------|------------------------------|  
|SQL_INTERVAL_DAY И SQL_C_INTERVAL_DAY|SQL_CODE_DAY|  
|SQL_INTERVAL_DAY_TO_HOUR И SQL_C_INTERVAL_DAY_TO_HOUR|SQL_CODE_DAY_TO_HOUR|  
|SQL_INTERVAL_DAY_TO_MINUTE И SQL_C_INTERVAL_DAY_TO_MINUTE|SQL_CODE_DAY_TO_MINUTE|  
|SQL_INTERVAL_DAY_TO_SECOND И SQL_C_INTERVAL_DAY_TO_SECOND|SQL_CODE_DAY_TO_SECOND|  
|SQL_INTERVAL_HOUR И SQL_C_INTERVAL_HOUR|SQL_CODE_HOUR|  
|SQL_INTERVAL_HOUR_TO_MINUTE И SQL_C_INTERVAL_HOUR_TO_MINUTE|SQL_CODE_HOUR_TO_MINUTE|  
|SQL_INTERVAL_HOUR_TO_SECOND И SQL_C_INTERVAL_HOUR_TO_SECOND|SQL_CODE_HOUR_TO_SECOND|  
|SQL_INTERVAL_MINUTE И SQL_C_INTERVAL_MINUTE|SQL_CODE_MINUTE|  
|SQL_INTERVAL_MINUTE_TO_SECOND И SQL_C_INTERVAL_MINUTE_TO_SECOND|SQL_CODE_MINUTE_TO_SECOND|  
|SQL_INTERVAL_MONTH И SQL_C_INTERVAL_MONTH|SQL_CODE_MONTH|  
|SQL_INTERVAL_SECOND И SQL_C_INTERVAL_SECOND|SQL_CODE_SECOND|  
|SQL_INTERVAL_YEAR И SQL_C_INTERVAL_YEAR|SQL_CODE_YEAR|  
|SQL_INTERVAL_YEAR_TO_MONTH И SQL_C_INTERVAL_YEAR_TO_MONTH|SQL_CODE_YEAR_TO_MONTH|  
  
 Дополнительные сведения о интервалах данных и этом поле см. в разделе [идентификаторы и дескрипторы типов данных](../../../odbc/reference/appendixes/data-type-identifiers-and-descriptors.md).  
  
 **SQL_DESC_DATETIME_INTERVAL_PRECISION [все]**  
 Это поле записи SQLINTEGER содержит начальную точность интервала, Если SQL_DESC_TYPE поле SQL_INTERVAL. Если для поля SQL_DESC_DATETIME_INTERVAL_CODE задан тип данных Interval, для этого поля устанавливается значение по умолчанию, равное заданному интервалу.  
  
 **SQL_DESC_DISPLAY_SIZE [Ирдс]**  
 Это поле записи SQLINTEGER только для чтения содержит максимальное число символов, необходимых для вывода данных из столбца.  
  
 **SQL_DESC_FIXED_PREC_SCALE [дескрипторы реализации]**  
 Это поле записи SQLSMALLINT только для чтения имеет значение SQL_TRUE, если столбец является точным числовым столбцом и имеет фиксированную точность и масштаб ненулевого значения, или для SQL_FALSE, если столбец не является точным числовым столбцом с фиксированной точностью и масштабом.  
  
 **SQL_DESC_INDICATOR_PTR [дескрипторы приложений]**  
 В АРДС это поле записи SQLLEN * указывает на переменную индикатора. Эта переменная содержит SQL_NULL_DATA, если значение столбца равно NULL. Для Апдс переменная индикатора имеет значение SQL_NULL_DATA, чтобы указать динамические аргументы NULL. В противном случае переменная равна нулю (если значения в SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR не являются одним и тем же указателем).  
  
 Если поле SQL_DESC_INDICATOR_PTR в АРД является пустым указателем, драйвер не сможет возвратить сведения о том, имеет ли столбец значение NULL. Если столбец имеет значение NULL, а SQL_DESC_INDICATOR_PTR является пустым указателем, то при попытке драйвера заполнить буфер после вызова **SQLFetch** или **SQLFETCHSCROLL** возвращается значение SQLSTATE 22002 (необходимая переменная индикатора, но не указана). Если вызов **SQLFetch** или **SQLFetchScroll** не вернул SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.  
  
 Поле SQL_DESC_INDICATOR_PTR определяет, задано ли поле, на которое указывает SQL_DESC_OCTET_LENGTH_PTR. Если значение данных для столбца равно NULL, драйвер задает для переменной индикатора SQL_NULL_DATA. Поле, на которое указывает SQL_DESC_OCTET_LENGTH_PTR, не устанавливается. Если значение NULL не обнаруживается во время выборки, буферу, на который указывает SQL_DESC_INDICATOR_PTR, присваивается значение 0, а буферу, на который указывает SQL_DESC_OCTET_LENGTH_PTR, присваивается длина данных.  
  
 Если поле SQL_DESC_INDICATOR_PTR в APD является пустым указателем, приложение не может использовать эту запись дескриптора для указания аргументов NULL.  
  
 Это *Отложенное поле*: оно не используется во время его установки, но используется в дальнейшем драйвером для указания допустимости значений NULL (для АРДС) или для определения допустимости значений NULL (для апдс).  
  
 **SQL_DESC_LABEL [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит метку или заголовок столбца. Если столбец не имеет метки, эта переменная содержит имя столбца. Если столбец имеет имя без имени и не имеет метки, эта переменная содержит пустую строку.  
  
 **SQL_DESC_LENGTH [все]**  
 Это поле записи SQLULEN является либо максимальной, либо действительной длиной символьной строки в символах, либо двоичным типом данных в байтах. Это максимальная длина для типа данных фиксированной длины или фактическая длина для типа данных переменной длины. Его значение всегда исключает символ завершения null, который завершает строку символов. Для значений, тип которых — SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP или один из типов данных интервала SQL, это поле содержит длину в символах символьной строки представления значения DateTime или Interval.  
  
 Значение в этом поле может отличаться от значения "Длина", как определено в ODBC 2 *. x*. Дополнительные сведения см. в разделе [Приложение D. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_LITERAL_PREFIX [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит символ или символы, распознаваемые драйвером как префикс литерала этого типа данных. Эта переменная содержит пустую строку для типа данных, для которого не применим префикс литерала.  
  
 **SQL_DESC_LITERAL_SUFFIX [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит символ или символы, распознаваемые драйвером в качестве суффикса для литерала этого типа данных. Эта переменная содержит пустую строку для типа данных, для которого литеральный суффикс неприменим.  
  
 **SQL_DESC_LOCAL_TYPE_NAME [дескрипторы реализации]**  
 Это поле SQLCHAR, доступное только для чтения, содержит любое локализованное (собственное) имя для типа данных, которое может отличаться от обычного имени типа данных. Если локализованное имя отсутствует, возвращается пустая строка. Это поле предназначено исключительно для просмотра.  
  
 **SQL_DESC_NAME [дескрипторы реализации]**  
 Это поле SQLCHAR * Record в дескрипторе строки содержит псевдоним столбца, если он применяется. Если псевдоним столбца не применяется, возвращается имя столбца. В любом случае драйвер задает поле SQL_DESC_UNNAMED для SQL_NAMED, когда задается поле SQL_DESC_NAME. Если имя столбца или псевдоним столбца отсутствуют, драйвер возвращает пустую строку в поле SQL_DESC_NAME и задает для поля SQL_DESC_UNNAMED значение SQL_UNNAMED.  
  
 Приложение может задать в поле SQL_DESC_NAME IPD имя параметра или псевдоним, чтобы указать параметры хранимой процедуры по имени. (Дополнительные сведения см. в разделе [Привязка параметров по имени (именованные параметры)](../../../odbc/reference/develop-app/binding-parameters-by-name-named-parameters.md).) Поле SQL_DESC_NAME IRD является полем только для чтения. Значение SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) будет возвращено, если приложение попытается установить его.  
  
 В ИПДС это поле не определено, если драйвер не поддерживает именованные параметры. Если драйвер поддерживает именованные параметры и может описывать параметры, в этом поле возвращается имя параметра.  
  
 **SQL_DESC_NULLABLE [дескрипторы реализации]**  
 В Ирдс это поле SQLSMALLINT, доступное только для чтения, SQL_NULLABLE, если столбец может иметь значения NULL, SQL_NO_NULLS, если столбец не имеет значений NULL, или SQL_NULLABLE_UNKNOWN, если неизвестно, допускает ли столбец значения NULL. Это поле относится к столбцу результирующего набора, а не к базовому столбцу.  
  
 В ИПДС это поле всегда имеет значение SQL_NULLABLE, так как динамические параметры всегда допускают значения NULL и не могут быть заданы приложением.  
  
 **SQL_DESC_NUM_PREC_RADIX [все]**  
 Это поле SQLINTEGER содержит значение 2, если тип данных в поле SQL_DESC_TYPE является приблизительным числовым типом данных, поскольку поле SQL_DESC_PRECISION содержит количество битов. Это поле содержит значение 10, если тип данных в поле SQL_DESC_TYPE является точным числовым типом данных, поскольку поле SQL_DESC_PRECISION содержит число десятичных цифр. Это поле имеет значение 0 для всех нечисловых типов данных.  
  
 **SQL_DESC_OCTET_LENGTH [все]**  
 Это поле записи SQLLEN содержит длину (в байтах) символьной строки или двоичного типа данных. Для символьных или двоичных типов фиксированной длины это фактическая длина в байтах. Для символьных или двоичных типов с переменной длиной это максимальная длина в байтах. Это значение всегда исключает пробел для символа завершения null для дескрипторов реализации и всегда включает пробел для символа завершения null для дескрипторов приложений. Для данных приложения это поле содержит размер буфера. Для Апдс это поле определено только для параметров OUTPUT или input/output.  
  
 **SQL_DESC_OCTET_LENGTH_PTR [дескрипторы приложений]**  
 Это поле записи SQLLEN * указывает на переменную, которая будет содержать общую длину (в байтах) динамического аргумента (для дескрипторов параметров) или значения привязанного столбца (для дескрипторов строк).  
  
 Для APD это значение игнорируется для всех аргументов, кроме символьной строки и двоичного файла. Если это поле указывает на SQL_NTS, динамический аргумент должен завершаться нулем. Чтобы указать, что связанный параметр будет параметром данных при выполнении, приложение устанавливает это поле в соответствующей записи APD в переменную, которая во время выполнения будет содержать значение SQL_DATA_AT_EXEC или результат макроса SQL_LEN_DATA_AT_EXEC. Если имеется более одного такого поля, SQL_DESC_DATA_PTR можно задать значение, однозначно определяющее параметр, чтобы приложение определило, какой параметр запрашивается.  
  
 Если OCTET_LENGTH_PTR поле АРД является пустым указателем, драйвер не возвращает сведения о длине столбца. Если SQL_DESC_OCTET_LENGTH_PTR поле APD является пустым указателем, драйвер предполагает, что символьные строки и двоичные значения завершаются нулем. (Двоичные значения не должны завершаться нулем, но для них следует указать длину, чтобы избежать усечения.)  
  
 Если вызов **SQLFetch** или **SQLFetchScroll** , который заполняет буфер, на который указывает это поле, не вернул SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено. Это *Отложенное поле*. Он не используется в тот момент, когда он задан, но используется в дальнейшем драйвером для определения или указания длины октета данных.  
  
 **SQL_DESC_PARAMETER_TYPE [ИПДС]**  
 Это поле записи SQLSMALLINT имеет значение SQL_PARAM_INPUT для входного параметра, SQL_PARAM_INPUT_OUTPUT для параметра ввода-вывода, SQL_PARAM_OUTPUT для выходного параметра, SQL_PARAM_INPUT_OUTPUT_STREAM для входного или выходного параметра или SQL_PARAM_OUTPUT_STREAM для выходного потокового параметра. По умолчанию он имеет значение SQL_PARAM_INPUT.  
  
 Для IPD поле имеет значение SQL_PARAM_INPUT по умолчанию, если драйвер IPD не заполняется автоматически (атрибутом инструкции SQL_ATTR_ENABLE_AUTO_IPD является SQL_FALSE). Приложение должно установить это поле в IPD для параметров, которые не являются входными параметрами.  
  
 **SQL_DESC_PRECISION [все]**  
 Это поле записи SQLSMALLINT содержит количество цифр для точного числового типа, число битов в мантисса (двоичная точность) для приблизительного числового типа или количество цифр в компоненте доли секунды для типа данных SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP или SQL_INTERVAL_SECOND. Это поле не определено для всех других типов данных.  
  
 Значение в этом поле может отличаться от значения "точность", как определено в ODBC 2 *. x*. Дополнительные сведения см. в разделе [Приложение D. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_ROWVER [дескрипторы реализации]**  
 Это поле Склсмаллинтрекорд указывает, будет ли автоматически изменен столбец СУБД при обновлении строки (например, столбец типа "timestamp" в SQL Server). Значение этого поля записи устанавливается равным SQL_TRUE, если столбец является столбцом управления версиями строк, и для SQL_FALSE в противном случае. Этот атрибут столбца аналогичен вызову **SQLSpecialColumns** с идентифиертипе SQL_ROWVER, чтобы определить, обновляется ли столбец автоматически.  
  
 **SQL_DESC_SCALE [все]**  
 Это поле записи SQLSMALLINT содержит определенную шкалу для типов данных Decimal и numeric. Поле не определено для всех других типов данных.  
  
 Значение в этом поле может отличаться от значения для параметра "Масштаб", как определено в ODBC 2 *. x*. Дополнительные сведения см. в разделе [Приложение D. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_SCHEMA_NAME [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит имя схемы базовой таблицы, содержащей столбец. Возвращаемое значение зависит от драйвера, если столбец является выражением или если столбец является частью представления. Если источник данных не поддерживает схемы или не удается определить имя схемы, эта переменная содержит пустую строку.  
  
 **SQL_DESC_SEARCHABLE [Ирдс]**  
 Для этого поля записи SQLSMALLINT только для чтения задается одно из следующих значений:  
  
-   SQL_PRED_NONE, если столбец не может быть использован в предложении **WHERE** . (Это то же самое, что SQL_UNSEARCHABLE значение в ODBC 2 *. x*.)  
  
-   SQL_PRED_CHAR, если столбец может использоваться в предложении **WHERE** , но только с предикатом **Like** . (Это то же самое, что SQL_LIKE_ONLY значение в ODBC 2 *. x*.)  
  
-   SQL_PRED_BASIC, если столбец может использоваться в предложении **WHERE** со всеми операторами сравнения, кроме **Like**. (Это то же самое, что SQL_EXCEPT_LIKE значение в ODBC 2 *. x*.)  
  
-   SQL_PRED_SEARCHABLE, если столбец может использоваться в предложении **WHERE** с любым оператором сравнения.  
  
 **SQL_DESC_TABLE_NAME [Ирдс]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит имя базовой таблицы, содержащей этот столбец. Возвращаемое значение зависит от драйвера, если столбец является выражением или если столбец является частью представления.  
  
 **SQL_DESC_TYPE [все]**  
 В этом поле записи SQLSMALLINT указан краткий тип данных SQL или C для всех типов данных, кроме типов данных DateTime и Interval. Для типов данных DateTime и Interval в этом поле указывается подробный тип данных, который SQL_DATETIME или SQL_INTERVAL.  
  
 Если в этом поле содержится SQL_DATETIME или SQL_INTERVAL, то поле SQL_DESC_DATETIME_INTERVAL_CODE должно содержать соответствующий код для краткого типа. Для типов данных DateTime SQL_DESC_TYPE содержит SQL_DATETIME, а поле SQL_DESC_DATETIME_INTERVAL_CODE содержит подпрограмму для конкретного типа данных DateTime. Для типов данных интервала SQL_DESC_TYPE содержит SQL_INTERVAL, а поле SQL_DESC_DATETIME_INTERVAL_CODE содержит подпрограмму для конкретного типа данных Interval.  
  
 Значения в полях SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE являются взаимозависимыми. При каждом задании одного из полей также должно быть задано другое. SQL_DESC_TYPE можно задать с помощью вызова **SQLSetDescField** или **SQLSetDescRec**. SQL_DESC_CONCISE_TYPE можно задать с помощью вызова **SQLBindCol** или **SQLBindParameter** или **SQLSetDescField**.  
  
 Если SQL_DESC_TYPE имеет тип данных краткая, отличный от типа данных Interval или DateTime, то в поле SQL_DESC_CONCISE_TYPE задается то же значение, а в поле SQL_DESC_DATETIME_INTERVAL_CODE устанавливается значение 0.  
  
 Если SQL_DESC_TYPE имеет значение подробный тип данных DateTime или Interval (SQL_DATETIME или SQL_INTERVAL), а для поля SQL_DESC_DATETIME_INTERVAL_CODE задан соответствующий код, в поле SQL_DESC_CONCISE тип устанавливается соответствующий сокращенный тип. При попытке установить SQL_DESC_TYPE в один из типов данных типа DateTime или Interval будет возвращено значение SQLSTATE HY021 (непоследовательная информация дескриптора).  
  
 Когда поле SQL_DESC_TYPE задается вызовом **SQLBindCol**, **SQLBindParameter** или **SQLSetDescField**, для следующих полей задаются следующие значения по умолчанию, как показано в таблице ниже. Значения оставшихся полей одной и той же записи не определены.  
  
|Значение SQL_DESC_TYPE|Другие поля неявно устанавливаются|  
|------------------------------|---------------------------------|  
|SQL_CHAR, SQL_VARCHAR, SQL_C_CHAR, SQL_C_VARCHAR|SQL_DESC_LENGTH имеет значение 1. SQL_DESC_PRECISION имеет значение 0.|  
|SQL_DATETIME|Если SQL_DESC_DATETIME_INTERVAL_CODE имеет значение SQL_CODE_DATE или SQL_CODE_TIME, SQL_DESC_PRECISION имеет значение 0. Если задано значение SQL_DESC_TIMESTAMP, SQL_DESC_PRECISION имеет значение 6.|  
|SQL_DECIMAL, SQL_NUMERIC SQL_C_NUMERIC|SQL_DESC_SCALE имеет значение 0. Для SQL_DESC_PRECISION задана точность, определенная реализацией для соответствующего типа данных.<br /><br /> Сведения о привязке SQL_C_NUMERIC значения вручную см. в разделе [SQL to C: numeric](../../../odbc/reference/appendixes/sql-to-c-numeric.md) .|  
|SQL_FLOAT, SQL_C_FLOAT|SQL_DESC_PRECISION задана точность, определенная реализацией по умолчанию для SQL_FLOAT.|  
|SQL_INTERVAL|Если для SQL_DESC_DATETIME_INTERVAL_CODE задан тип данных Interval, SQL_DESC_DATETIME_INTERVAL_PRECISION имеет значение 2 (начальная точность по умолчанию). Если интервал имеет компонент секунд, SQL_DESC_PRECISION имеет значение 6 (значение интервала в секундах по умолчанию).|  
  
 Когда приложение вызывает **SQLSetDescField** для задания полей дескриптора вместо вызова **SQLSetDescRec**, приложение должно сначала объявить тип данных. При этом другие поля, указанные в предыдущей таблице, устанавливаются неявно. Если любое из значений неявно задано как неприемлемое, приложение может вызвать **SQLSetDescField** или **SQLSetDescRec** , чтобы задать неприемлемое значение явным образом.  
  
 **SQL_DESC_TYPE_NAME [дескрипторы реализации]**  
 Это поле SQLCHAR * записи, доступное только для чтения, содержит имя типа, зависящее от источника данных (например, "CHAR", "VARCHAR" и т. д.). Если имя типа данных неизвестно, эта переменная содержит пустую строку.  
  
 **SQL_DESC_UNNAMED [дескрипторы реализации]**  
 Это поле записи SQLSMALLINT в дескрипторе строки задается драйвером либо SQL_NAMED, либо SQL_UNNAMED, когда задается поле SQL_DESC_NAME. Если поле SQL_DESC_NAME содержит псевдоним столбца или если псевдоним столбца не применяется, драйвер задает для поля SQL_DESC_UNNAMED значение SQL_NAMED. Если приложение устанавливает SQL_DESC_NAME поле IPD в имя параметра или псевдоним, драйвер задает для поля SQL_DESC_UNNAMED IPD значение SQL_NAMED. Если имя столбца или псевдоним столбца отсутствуют, драйвер задает для поля SQL_DESC_UNNAMED значение SQL_UNNAMED.  
  
 Приложение может задать SQL_DESC_UNNAMED поле IPD для SQL_UNNAMED. Драйвер возвращает значение SQLSTATE HY091 (недопустимый идентификатор поля дескриптора), если приложение пытается задать SQL_DESC_UNNAMED поле IPD для SQL_NAMED. Поле SQL_DESC_UNNAMED IRD доступно только для чтения; Значение SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) будет возвращено, если приложение попытается установить его.  
  
 **SQL_DESC_UNSIGNED [дескрипторы реализации]**  
 Это поле записи SQLSMALLINT только для чтения имеет значение SQL_TRUE, если тип столбца имеет неподписанный или нечисловой, или SQL_FALSE, если тип столбца подписан.  
  
 **SQL_DESC_UPDATABLE [Ирдс]**  
 Для этого поля записи SQLSMALLINT только для чтения задается одно из следующих значений:  
  
-   SQL_ATTR_READ_ONLY, если столбец результирующего набора доступен только для чтения.  
  
-   SQL_ATTR_WRITE, если столбец результирующего набора доступен для чтения и записи.  
  
-   SQL_ATTR_READWRITE_UNKNOWN, если неизвестно, является ли столбец результирующего набора обновляемым или нет.  
  
 SQL_DESC_UPDATABLE описывает возможность обновления столбца в результирующем наборе, а не столбца в базовой таблице. Возможность обновления столбца в базовой таблице, на которой основан данный столбец результатов, может отличаться от значения в этом поле. Может ли столбец быть основан на типе данных, привилегиях пользователя и определении самого результирующего набора. Если неясно, является ли столбец обновляемым, возвращается SQL_ATTR_READWRITE_UNKNOWN.  
  
## <a name="consistency-checks"></a>Проверки согласованности  
 Драйвер выполняет проверку согласованности автоматически каждый раз, когда приложение передает значение для SQL_DESC_DATA_PTR поля АРД, APD или IPD. Если какое-либо из полей не согласуется с другими полями, **SQLSetDescField** вернет SQLSTATE HY021 (непоследовательные сведения о дескрипторе). Дополнительные сведения см. в разделе "Проверка согласованности" в [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка столбца|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка параметра|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Получение поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)
