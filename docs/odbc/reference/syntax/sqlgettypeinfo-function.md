---
description: Функция SQLGetTypeInfo
title: Функция SQLGetTypeInfo | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLGetTypeInfo
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetTypeInfo
helpviewer_keywords:
- SQLGetTypeInfo function [ODBC]
ms.assetid: bdedb044-8924-4ca4-85f3-8b37578e0257
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 55de323b6eace8fa2aa8b138f30ee93938122bc0
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99189714"
---
# <a name="sqlgettypeinfo-function"></a>Функция SQLGetTypeInfo
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLGetTypeInfo** возвращает сведения о типах данных, поддерживаемых источником данных. Драйвер возвращает сведения в виде результирующего набора SQL. Типы данных предназначены для использования в инструкциях языка описания данных (DDL).  
  
> [!IMPORTANT]  
>  Приложения должны использовать имена типов, возвращенные в столбце TYPE_NAME результирующего набора **SQLGetTypeInfo** в инструкциях **ALTER TABLE** и **CREATE TABLE** . **SQLGetTypeInfo** может возвращать более одной строки с одинаковым значением в столбце DATA_TYPE.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetTypeInfo(  
     SQLHSTMT      StatementHandle,  
     SQLSMALLINT   DataType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции для результирующего набора.  
  
 *DataType*  
 Входной Тип данных SQL. Это должно быть одно из значений в разделе [типы данных SQL](../../../odbc/reference/appendixes/sql-data-types.md) приложения D: типы данных или тип данных SQL, зависящий от драйвера. SQL_ALL_TYPES указывает, что должны возвращаться сведения обо всех типах данных.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLGetTypeInfo** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLGetTypeInfo** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Значение параметра изменено|Указанный атрибут инструкции был недопустимым из-за рабочих условий реализации, поэтому было временно заменено аналогичное значение. (Вызовите **SQLGetStmtAttr** , чтобы определить временно заменяющее значение.) Заменяющее значение допустимо для *статеменсандле* до закрытия курсора. Атрибуты инструкции, которые могут быть изменены: SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_KEYSET_SIZE, SQL_ATTR_MAX_LENGTH, SQL_ATTR_MAX_ROWS, SQL_ATTR_QUERY_TIMEOUT и SQL_ATTR_SIMULATE_CURSOR. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|В Статеменсандле был открыт курсор *,* а также был вызван **SQLFetch** или **SQLFetchScroll** . Эта ошибка возвращается диспетчером драйверов, если **SQLFetch** или **SQLFetchScroll** не вернул SQL_NO_DATA, и возвращается драйвером, если **SQLFetch** или **SQLFetchScroll** вернул SQL_NO_DATA.<br /><br /> Результирующий набор был открыт в *статеменсандле*, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|40001|Сбой сериализации|Произошел откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное подключение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY004|Недопустимый тип данных SQL|Значение, заданное *для типа данных аргумента* , не было допустимым идентификатором типа данных SQL ODBC или идентификатором определенного для драйвера типа данных, поддерживаемым драйвером.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *статеменсандле*, затем была вызвана функция и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *статеменсандле*. Затем функция была вызвана в *статеменсандле*.<br /><br /> Функция была вызвана, и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLGetTypeInfo** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Сочетание текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживалось драйвером или источником данных.<br /><br /> Атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_VARIABLE, а атрибуту инструкции SQL_ATTR_CURSOR_TYPE задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, соответствующий *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 **SQLGetTypeInfo** возвращает результаты в виде стандартного результирующего набора, упорядоченного по data_type, а затем по степени соответствия типа данных соответствующему типу данных ODBC SQL. Типы данных, определенные источником данных, имеют приоритет над определяемыми пользователем типами данных. Следовательно, порядок сортировки не всегда является последовательным, но его можно обобщить как DATA_TYPE сначала, а затем TYPE_NAME как по возрастанию. Например, предположим, что источник данных определил ЦЕЛОЧИСЛЕНные типы данных и СЧЕТЧИКи, где счетчик автоматически увеличивается, а также что определен определяемый пользователем тип данных ВХОЛЕНУМ. Они будут возвращены в порядке INTEGER, ВХОЛЕНУМ и COUNTER, так как ВХОЛЕНУМ сопоставляется с типом данных ODBC SQL SQL_INTEGER, а тип данных с автоматическим приращением, даже несмотря на то, что поддерживается источником данных, не соответствует типу данных ODBC SQL. Сведения об использовании этих сведений см. в разделе [инструкции DDL](../../../odbc/reference/develop-app/ddl-statements.md).  
  
 Если аргумент *DataType* указывает тип данных, допустимый для версии ODBC, поддерживаемой драйвером, но не поддерживается драйвером, то он вернет пустой результирующий набор.  
  
> [!NOTE]  
>  Дополнительные сведения об общем использовании, аргументах и возвращаемых данных функций каталога ODBC см. в разделе [функции каталога](../../../odbc/reference/develop-app/catalog-functions.md).  
  
 Следующие столбцы были переименованы для ODBC 3. *x*. Изменения имени столбца не влияют на обратную совместимость, так как приложения привязаны по номеру столбца.  
  
|Столбец ODBC 2,0|ODBC 3. *x* , столбец|  
|---------------------|-----------------------|  
|PRECISION|COLUMN_SIZE|  
|MONEY|FIXED_PREC_SCALE|  
|AUTO_INCREMENT|AUTO_UNIQUE_VALUE|  
  
 В набор результатов, возвращенный функцией **SQLGetTypeInfo** для ODBC 3, были добавлены следующие столбцы. *x*:  
  
-   SQL_DATA_TYPE  
  
-   INTERVAL_PRECISION  
  
-   SQL_DATETIME_SUB  
  
-   NUM_PREC_RADIX  
  
 В следующей таблице перечислены столбцы результирующего набора. Дополнительные столбцы, которые выходят за пределы столбца 19 (INTERVAL_PRECISION), могут быть определены драйвером. Приложение должно получить доступ к столбцам, относящимся к драйверу, выполнив подсчет с конца результирующего набора, а не указав явную порядковую точку. Дополнительные сведения см. в разделе [данные, возвращаемые функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
> [!NOTE]  
>  **SQLGetTypeInfo** может не возвращать все типы данных. Например, драйвер может не возвращать определяемые пользователем типы данных. Приложения могут использовать любой допустимый тип данных независимо от того, возвращается ли он с помощью **SQLGetTypeInfo**. Типы данных, возвращаемые **SQLGetTypeInfo** , являются поддерживаемыми источником данных. Они предназначены для использования в инструкциях языка описания данных (DDL). Драйверы могут возвращать данные результирующих наборов с помощью типов данных, отличных от типов, возвращаемых **SQLGetTypeInfo**. При создании результирующего набора для функции каталога драйвер может использовать тип данных, который не поддерживается источником данных.  
  
|Имя столбца|Столбец<br /><br /> Число|Тип данных|Комментарии|  
|-----------------|-----------------------|---------------|--------------|  
|TYPE_NAME (ODBC 2,0)|1|Varchar, не РАВНый NULL|Имя типа данных, зависящее от источника данных; Например, «CHAR ()», «VARCHAR ()», «MONEY», «LONG VARBINARY» или «CHAR () для данных BIT». Приложения должны использовать это имя в инструкциях **CREATE TABLE** и **ALTER TABLE** .|  
|DATA_TYPE (ODBC 2,0)|2|Smallint, не NULL|Тип данных SQL. Это может быть тип данных ODBC SQL или тип данных SQL, зависящий от драйвера. Для типов данных DateTime или Interval этот столбец возвращает тип данных краткая (например, SQL_TYPE_TIME или SQL_INTERVAL_YEAR_TO_MONTH). Список допустимых типов данных ODBC SQL см. в разделе [типы данных SQL](../../../odbc/reference/appendixes/sql-data-types.md) в приложении г: типы данных. Дополнительные сведения о типах данных SQL, относящихся к драйверам, см. в документации по драйверу.|  
|COLUMN_SIZE (ODBC 2,0)|3|Целое число|Максимальный размер столбца, поддерживаемый сервером для этого типа данных. Для числовых данных это максимальная точность. Для строковых данных это длина в символах. Для типов данных DateTime это длина в символах строкового представления (предполагая максимально допустимую точность компонента доли секунды). Значение NULL возвращается для типов данных, в которых размер столбца неприменим. Для типов данных интервала это число символов в символьном представлении литерала интервала (как определено в параметре "начальная точность в интервале"; см. раздел " [Длина типа данных интервала](../../../odbc/reference/appendixes/interval-data-type-length.md) " в приложении г: типы данных).<br /><br /> Дополнительные сведения о размере столбцов см. в разделе [размер столбца, десятичные цифры, длина октета и размер дисплея](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) в приложении г: типы данных.|  
|LITERAL_PREFIX (ODBC 2,0)|4|Varchar|Символ или символы, используемые для префикса литерала; Например, одинарная кавычка (') для символьных типов данных или 0x для двоичных типов данных; Значение NULL возвращается для типов данных, в которых префикс литерала неприменим.|  
|LITERAL_SUFFIX (ODBC 2,0)|5|Varchar|Символ или символы, используемые для завершения литерала; Например, одинарная кавычка (') для символьных типов данных; Значение NULL возвращается для типов данных, в которых литеральный суффикс неприменим.|  
|CREATE_PARAMS (ODBC 2,0)|6|Varchar|Список ключевых слов, разделенных запятыми, соответствующий каждому параметру, который приложение может указать в круглых скобках при использовании имени, возвращаемого в поле TYPE_NAME. Ключевыми словами в списке могут быть любые из следующих значений: длина, точность или масштаб. Они отображаются в том порядке, в котором они необходимы для использования синтаксиса. Например, CREATE_PARAMS для DECIMAL будет иметь значение "точность, масштаб"; CREATE_PARAMS для VARCHAR будет равно "Length". Если отсутствуют параметры для определения типа данных, возвращается значение NULL. Например, INTEGER.<br /><br /> Драйвер предоставляет CREATE_PARAMS текст на языке страны или региона, где он используется.|  
|NULLABLE (ODBC 2,0)|7|Smallint, не NULL|Принимает ли тип данных значение NULL:<br /><br /> SQL_NO_NULLS, если тип данных не принимает значения NULL.<br /><br /> SQL_NULLABLE, если тип данных принимает значения NULL.<br /><br /> SQL_NULLABLE_UNKNOWN, если неизвестно, допускает ли столбец значения NULL.|  
|CASE_SENSITIVE (ODBC 2,0)|8|Smallint, не NULL|Учитывается ли регистр символьного типа данных в параметрах сортировки и сравнениях:<br /><br /> SQL_TRUE, если тип данных является символьным типом данных и учитывает регистр.<br /><br /> SQL_FALSE, если тип данных не является символьным типом данных или не учитывает регистр.|  
|С ВОЗМОЖНОСТЬЮ ПОИСКА (ODBC 2,0)|9|Smallint, не NULL|Как тип данных используется в предложении **WHERE** :<br /><br /> SQL_PRED_NONE, если столбец не может быть использован в предложении **WHERE** . (Это то же самое, что SQL_UNSEARCHABLE значение в ODBC 2. *x*.)<br /><br /> SQL_PRED_CHAR, если столбец может использоваться в предложении **WHERE** , но только с предикатом **Like** . (Это то же самое, что SQL_LIKE_ONLY значение в ODBC 2. *x*.)<br /><br /> SQL_PRED_BASIC, если столбец может использоваться в предложении **WHERE** со всеми операторами сравнения, кроме **Like** (сравнение, количественное сравнение, **между**, **DISTINCT**, **в**, **Match** и **UNIQUE**). (Это то же самое, что SQL_ALL_EXCEPT_LIKE значение в ODBC 2. *x*.)<br /><br /> SQL_SEARCHABLE, если столбец может использоваться в предложении **WHERE** с любым оператором сравнения.|  
|UNSIGNED_ATTRIBUTE (ODBC 2,0)|10|Smallint|Является ли тип данных неподписанным:<br /><br /> SQL_TRUE, если тип данных не подписан.<br /><br /> SQL_FALSE, если тип данных подписан.<br /><br /> Значение NULL возвращается, если атрибут неприменим к типу данных или тип данных не является числовым.|  
|FIXED_PREC_SCALE (ODBC 2,0)|11|Smallint, не NULL|Имеет ли тип данных предопределенную фиксированную точность и масштаб (которая зависит от источника данных), например тип данных Money:<br /><br /> SQL_TRUE, если у него есть предопределенная фиксированная точность и масштаб.<br /><br /> SQL_FALSE, если у него нет предварительно заданной фиксированной точности и масштаба.|  
|AUTO_UNIQUE_VALUE (ODBC 2,0)|12|Smallint|Указывает, имеет ли тип данных автоматическое приращение:<br /><br /> SQL_TRUE, если тип данных автоматически увеличивается.<br /><br /> SQL_FALSE, если тип данных не является автоматически увеличивающимся.<br /><br /> Значение NULL возвращается, если атрибут неприменим к типу данных или тип данных не является числовым.<br /><br /> Приложение может вставлять значения в столбец, имеющий этот атрибут, но обычно не может обновлять значения в столбце.<br /><br /> При вставке в столбец с автоматическим приращением во время вставки в столбец вставляется уникальное значение. Шаг приращения не определен, но зависит от конкретного источника данных. В приложении не следует рассчитывать, что столбец автоинкремента начинается с любой определенной точки или увеличивается по определенному значению.|  
|LOCAL_TYPE_NAME (ODBC 2,0)|13|Varchar|Локализованная версия имени типа данных, которое зависит от источника данных. Если локализованное имя не поддерживается источником данных, возвращается значение NULL. Это имя предназначено только для вывода, например в диалоговых окнах.|  
|MINIMUM_SCALE (ODBC 2,0)|14|Smallint|Минимальный масштаб типа данных в источнике данных. Если тип данных имеет фиксированный масштаб, это значение содержится и в столбце MINIMUM_SCALE, и в столбце MAXIMUM_SCALE. Например, столбец SQL_TYPE_TIMESTAMP может иметь фиксированный масштаб в долях секунды. Для типов данных, к которым понятие масштаба не применимо, возвращается значение NULL. Дополнительные сведения см. в разделе [размер столбца, десятичные цифры, длина октета и размер дисплея](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) в приложении г: типы данных.|  
|MAXIMUM_SCALE (ODBC 2,0)|15|Smallint|Максимальный масштаб типа данных в источнике данных. Для типов данных, к которым понятие масштаба не применимо, возвращается значение NULL. Если максимальный масштаб не определен отдельно для источника данных, а определяется как максимальная точность, этот столбец содержит то же значение, что и столбец COLUMN_SIZE. Дополнительные сведения см. в разделе [размер столбца, десятичные цифры, длина октета и размер дисплея](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) в приложении г: типы данных.|  
|SQL_DATA_TYPE (ODBC 3,0)|16|Smallint, не РАВНый NULL|Значение типа данных SQL, отображаемое в поле SQL_DESC_TYPE дескриптора. Этот столбец аналогичен столбцу DATA_TYPE, за исключением типов данных Interval и DateTime.<br /><br /> Для типов данных Interval и DateTime поле SQL_DATA_TYPE в результирующем наборе будет возвращать SQL_INTERVAL или SQL_DATETIME, а поле SQL_DATETIME_SUB будет возвращать код для конкретного типа данных Interval или DateTime. (См. [приложение г. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)|  
|SQL_DATETIME_SUB (ODBC 3,0)|17|Smallint|Если значение SQL_DATA_TYPE равно SQL_DATETIME или SQL_INTERVAL, этот столбец содержит подкод DateTime/Interval. Для типов данных, отличных от DateTime и Interval, это поле имеет значение NULL.<br /><br /> Для типов данных Interval или DateTime поле SQL_DATA_TYPE в результирующем наборе будет возвращать SQL_INTERVAL или SQL_DATETIME, а поле SQL_DATETIME_SUB будет возвращать код для конкретного типа данных Interval или DateTime. (См. [приложение г. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)|  
|NUM_PREC_RADIX (ODBC 3,0)|18|Целое число|Если тип данных является приблизительным числовым типом, этот столбец содержит значение 2, указывающее, что COLUMN_SIZE указывает количество битов. Для точных числовых типов этот столбец содержит значение 10, указывающее, что COLUMN_SIZE указывает число десятичных цифр. В противном случае этот столбец содержит значение NULL.|  
|INTERVAL_PRECISION (ODBC 3,0)|19|Smallint|Если тип данных является типом данных интервала, то этот столбец содержит значение в качестве начальной точности интервала. (См. раздел [точность типа данных Interval](../../../odbc/reference/appendixes/interval-data-type-precision.md) в приложении г: типы данных.) В противном случае этот столбец имеет значение NULL.|  
  
 Сведения об атрибутах могут применяться к типам данных или к конкретным столбцам в результирующем наборе. **SQLGetTypeInfo** возвращает сведения об атрибутах, связанных с типами данных. **SQLColAttribute** возвращает сведения об атрибутах, связанных со столбцами в результирующем наборе.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующем наборе|[Функция SQLColAttribute](../../../odbc/reference/syntax/sqlcolattribute-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Выборка одной строки или блока данных в прямом направлении|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Возврат сведений о драйвере или источнике данных|[SQLGetInfo, функция](../../../odbc/reference/syntax/sqlgetinfo-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
