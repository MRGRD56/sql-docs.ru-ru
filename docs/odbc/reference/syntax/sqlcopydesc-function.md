---
description: Функция SQLCopyDesc
title: Функция Склкопидеск | Документация Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLCopyDesc
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLCopyDesc
helpviewer_keywords:
- SQLCopyDesc function [ODBC]
ms.assetid: d5450895-3824-44c4-8aa4-d4f9752a9602
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ab2ef18e777d433daf4ab93b73d249e62507ea3c
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99206305"
---
# <a name="sqlcopydesc-function"></a>Функция SQLCopyDesc
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 3,0: ISO 92  
  
 **Сводка**  
 **Склкопидеск** копирует данные дескриптора из одного дескриптора дескриптора в другой.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLCopyDesc(  
     SQLHDESC     SourceDescHandle,  
     SQLHDESC     TargetDescHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *саурцедесчандле*  
 Входной Дескриптор исходного дескриптора.  
  
 *таржетдесчандле*  
 Входной Дескриптор целевого дескриптора. Аргумент *таржетдесчандле* может быть дескриптором для дескриптора приложения или IPD. *Таржетдесчандле* не может быть установлен в дескриптор IRD, или **СКЛКОПИДЕСК** вернет SQLSTATE HY016 (невозможно изменить дескриптор строки реализации).  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **склкопидеск** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_DESC и *маркером* *таржетдесчандле*. Если в вызове был передан недопустимый *саурцедесчандле* , возвращается SQL_INVALID_HANDLE, но значение SQLSTATE не возвращается. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **склкопидеск** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
 При возвращении ошибки вызов **склкопидеск** немедленно прерывается, а содержимое полей в дескрипторе *таржетдесчандле* не определяется.  
  
 Так как **склкопидеск** может быть реализован вызовом **SQLGetDescField** и **SQLSetDescField**, **склкопидеск** может возвращать SQLSTATE, возвращаемых **SQLGetDescField** или **SQLSetDescField**.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY007|Связанная инструкция не подготовлена|*Саурцедесчандле* был связан с IRD, а соответствующий маркер инструкции не находится в состоянии "подготовлено" или "выполнено".|  
|HY010|Ошибка последовательности функций|(DM) дескриптор дескриптора в *саурцедесчандле* или *таржетдесчандле* был связан с *статеменсандле* , для которого вызывалась асинхронно исполняемая функция (а не эта одна), и она все еще выполнялась при вызове этой функции.<br /><br /> (DM) дескриптор дескриптора в *саурцедесчандле* или *таржетдесчандле* был связан с *статеменсандле* , для которого были вызваны **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *саурцедесчандле* или *таржетдесчандле*. Эта асинхронная функция все еще выполнялась при вызове функции **склкопидеск** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для одного из дескрипторов инструкций, связанных с *саурцедесчандле* или *таржетдесчандле* , и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY016|Невозможно изменить дескриптор строки реализации|*Таржетдесчандле* был связан с IRD.|  
|HY021|Непоследовательные сведения о дескрипторе|Данные дескриптора, проверенные во время проверки согласованности, не были согласованы. Дополнительные сведения см. в разделе "проверки согласованности" в **SQLSetDescField**.|  
|HY092|Недопустимый идентификатор атрибута или параметра|Вызов **склкопидеск** запрашивает вызов **SQLSetDescField**, но *\* ValuePtr* был недопустимым для аргумента *фиелдидентифиер* в *таржетдесчандле*.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *саурцедесчандле* или *таржетдесчандле* , не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Вызов **склкопидеск** копирует поля дескриптора исходного дескриптора в дескриптор целевого дескриптора. Поля можно копировать только в дескриптор приложения или IPD, но не в IRD. Поля можно копировать из приложения или дескриптора реализации.  
  
 Поля можно копировать из IRD только в том случае, если маркер инструкции находится в состоянии "подготовлено" или "выполнен". в противном случае функция возвращает значение SQLSTATE HY007 (связанный оператор не подготовлен).  
  
 Поля можно копировать из IPD независимо от того, была ли подготовлена инструкция. Если инструкция SQL с динамическими параметрами была подготовлена и автоматическое заполнение IPD поддерживается и включено, то функция IPD заполняется драйвером. Если **склкопидеск** вызывается с помощью метода IPD в качестве *саурцедесчандле*, заполненные поля копируются. Если драйвер IPD не заполняется с помощью драйвера, копируются содержимое полей, изначально наявляющихся в IPD.  
  
 Все поля дескриптора, за исключением SQL_DESC_ALLOC_TYPE (который указывает, был ли дескриптор дескриптора автоматически или явно выделен), копируются, независимо от того, определено ли поле для дескриптора назначения. Скопированные поля перезапишут существующие поля.  
  
 Драйвер копирует все поля дескриптора, если аргументы *саурцедесчандле* и *таржетдесчандле* связаны с одним и тем же драйвером, даже если эти драйверы находятся в двух разных подключениях или средах. Если аргументы *саурцедесчандле* и *таржетдесчандле* связаны с разными драйверами, диспетчер драйверов копирует поля, определенные драйвером ODBC, но не копирует поля или поля драйвера, которые не определены в ODBC для типа дескриптора.  
  
 Вызов **склкопидеск** немедленно прерывается при возникновении ошибки.  
  
 При копировании поля SQL_DESC_DATA_PTR в целевом дескрипторе выполняется проверка согласованности. Если проверка согласованности завершается неудачно, возвращается значение SQLSTATE HY021 (несогласованные сведения о дескрипторе), и вызов **склкопидеск** немедленно прерывается. Дополнительные сведения о проверках согласованности см. в разделе "проверки согласованности" в [функции SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
 Дескрипторы дескрипторов можно копировать между соединениями, даже если они находятся в разных средах. Если диспетчер драйверов обнаруживает, что источник и дескриптор назначения не принадлежат одному соединению, а два соединения относятся к отдельным драйверам, то он реализует **склкопидеск** , выполняя копирование по полю с помощью **SQLGetDescField** и **SQLSetDescField**.  
  
 Когда **склкопидеск** вызывается с *саурцедесчандле* в одном драйвере и *таржетдесчандле* в другом драйвере, очередь ошибок *саурцедесчандле* удаляется. Это происходит потому, что **склкопидеск** в этом случае реализуется вызовами методов **SQLGetDescField** и **SQLSetDescField**.  
  
> [!NOTE]  
>  Приложение может связать явно выделенный дескриптор дескриптора с *статеменсандле*, а не вызывать **склкопидеск** для копирования полей из одного дескриптора в другой. Явно выделенный дескриптор может быть связан с другим *статеменсандле* в том же *коннектионхандле* , присвоив атрибуту инструкции SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC дескриптору явно выделенного дескриптора. Когда это будет сделано, **склкопидеск** не нужно вызывать для копирования значений полей дескриптора из одного дескриптора в другой. Дескриптор дескриптора не может быть связан с *статеменсандле* в другом *коннектионхандле*, однако. чтобы использовать одинаковые значения полей дескриптора в *статеменсандлес* для разных *коннектионхандлес*, необходимо вызвать **склкопидеск** .  
  
 Описание полей в заголовке или записи дескриптора см. в разделе [функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md). Дополнительные сведения о дескрипторах см. в разделе [дескрипторы](../../../odbc/reference/develop-app/descriptors.md).  
  
## <a name="copying-rows-between-tables"></a>Копирование строк между таблицами  
 Приложение может копировать данные из одной таблицы в другую без копирования данных на уровне приложения. Для этого приложение привязывает одни и те же буферы данных и сведения о дескрипторе к инструкции, которая извлекает данные, и инструкцию, которая вставляет данные в копию. Это можно сделать путем совместного использования дескриптора приложения (привязки явно выделенного дескриптора как АРД к одной инструкции и APD в другой) или с помощью **склкопидеск** для копирования привязок между АРД и APD двух инструкций. Если инструкции находятся в разных соединениях, необходимо использовать **склкопидеск** . Кроме того, **склкопидеск** должен быть вызван для копирования привязок между IRD и IPD двух инструкций. При копировании между инструкциями в одном соединении тип данных SQL_ACTIVE_STATEMENTS, возвращаемый драйвером для вызова **SQLGetInfo** , должен быть больше 1 для выполнения этой операции. (Это не так при копировании между соединениями.)  
  
### <a name="code-example"></a>Пример кода  
 В следующем примере операции с дескрипторами используются для копирования полей таблицы Партссаурце в таблицу Партскопи. Содержимое таблицы Партссаурце извлекается в буферы наборов строк в *hstmt0*. Эти значения используются в качестве параметров инструкции INSERT в *hstmt1* для заполнения столбцов таблицы партскопи. Для этого поля IRD из *hstmt0* копируются в поля класса IPD *hstmt1*, а поля АРД *HSTMT0* копируются в поля APD в *hstmt1е*. Используйте **SQLSetDescField** , чтобы установить атрибут SQL_DESC_PARAMETER_TYPE IPD SQL_PARAM_INPUT при копировании полей IRD из инструкции с параметрами OUTPUT в поля IPD, которые должны быть входными параметрами.  
  
```cpp  
#define ROWS 100  
#define DESC_LEN 50  
#define SQL_SUCCEEDED(rc) (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)  
  
// Template for a row  
typedef struct {  
   SQLINTEGER   sPartID;  
   SQLINTEGER   cbPartID;  
   SQLUCHAR     szDescription[DESC_LENGTH];  
   SQLINTEGER   cbDescription;  
   REAL         sPrice;  
   SQLINTEGER   cbPrice;  
} PartsSource;  
  
PartsSource    rget[ROWS];          // rowset buffer  
SQLUSMALLINT   sts_ptr[ROWS];       // status pointer  
SQLHSTMT       hstmt0, hstmt1;  
SQLHDESC       hArd0, hIrd0, hApd1, hIpd1;  
  
// ARD and IRD of hstmt0  
SQLGetStmtAttr(hstmt0, SQL_ATTR_APP_ROW_DESC, &hArd0, 0, NULL);  
SQLGetStmtAttr(hstmt0, SQL_ATTR_IMP_ROW_DESC, &hIrd0, 0, NULL);  
  
// APD and IPD of hstmt1  
SQLGetStmtAttr(hstmt1, SQL_ATTR_APP_PARAM_DESC, &hApd1, 0, NULL);  
SQLGetStmtAttr(hstmt1, SQL_ATTR_IMP_PARAM_DESC, &hIpd1, 0, NULL);  
  
// Use row-wise binding on hstmt0 to fetch rows  
SQLSetStmtAttr(hstmt0, SQL_ATTR_ROW_BIND_TYPE, (SQLPOINTER) sizeof(PartsSource), 0);  
  
// Set rowset size for hstmt0  
SQLSetStmtAttr(hstmt0, SQL_ATTR_ROW_ARRAY_SIZE, (SQLPOINTER) ROWS, 0);  
  
// Execute a select statement  
SQLExecDirect(hstmt0, "SELECT PARTID, DESCRIPTION, PRICE FROM PARTS ORDER BY 3, 1, 2"",  
               SQL_NTS);  
  
// Bind  
SQLBindCol(hstmt0, 1, SQL_C_SLONG, rget[0].sPartID, 0,   
   &rget[0].cbPartID);  
SQLBindCol(hstmt0, 2, SQL_C_CHAR, &rget[0].szDescription, DESC_LEN,   
   &rget[0].cbDescription);  
SQLBindCol(hstmt0, 3, SQL_C_FLOAT, rget[0].sPrice,   
   0, &rget[0].cbPrice);  
  
// Perform parameter bindings on hstmt1.   
SQLCopyDesc(hArd0, hApd1);  
SQLCopyDesc(hIrd0, hIpd1);  
  
// Set the array status pointer of IRD  
SQLSetStmtAttr(hstmt0, SQL_ATTR_ROW_STATUS_PTR, sts_ptr, SQL_IS_POINTER);  
  
// Set the ARRAY_STATUS_PTR field of APD to be the same  
// as that in IRD.  
SQLSetStmtAttr(hstmt1, SQL_ATTR_PARAM_OPERATION_PTR, sts_ptr, SQL_IS_POINTER);  
  
// Set the hIpd1 records as input parameters  
rc = SQLSetDescField(hIpd1, 1, SQL_DESC_PARAMETER_TYPE, (SQLPOINTER)SQL_PARAM_INPUT, SQL_IS_INTEGER);  
rc = SQLSetDescField(hIpd1, 2, SQL_DESC_PARAMETER_TYPE, (SQLPOINTER)SQL_PARAM_INPUT, SQL_IS_INTEGER);  
rc = SQLSetDescField(hIpd1, 3, SQL_DESC_PARAMETER_TYPE, (SQLPOINTER)SQL_PARAM_INPUT, SQL_IS_INTEGER);  
  
// Prepare an insert statement on hstmt1. PartsCopy is a copy of  
// PartsSource  
SQLPrepare(hstmt1, "INSERT INTO PARTS_COPY VALUES (?, ?, ?)", SQL_NTS);  
  
// In a loop, fetch a rowset, and copy the fetched rowset to PARTS_COPY  
  
rc = SQLFetchScroll(hstmt0, SQL_FETCH_NEXT, 0);  
while (SQL_SUCCEEDED(rc)) {  
  
   // After the call to SQLFetchScroll, the status array has row   
   // statuses. This array is used as input status in the APD  
   // and hence determines which elements of the rowset buffer  
   // are inserted.  
   SQLExecute(hstmt1);  
  
   rc = SQLFetchScroll(hstmt0, SQL_FETCH_NEXT, 0);  
} // while  
```  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Задание одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
