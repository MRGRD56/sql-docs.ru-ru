---
description: Функция SQLConnect
title: Функция SQLConnect | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLConnect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLConnect
helpviewer_keywords:
- SQLConnect function [ODBC]
ms.assetid: 59075e46-a0ca-47bf-972a-367b08bb518d
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 90d982db52e0656fba25eb54065ea84b751a7b18
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99206136"
---
# <a name="sqlconnect-function"></a>Функция SQLConnect
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLConnect** устанавливает подключения к драйверу и источнику данных. Этот маркер подключения ссылается на хранилище всех сведений о соединении с источником данных, включая состояние, состояние транзакции и сведения об ошибке.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLConnect(  
     SQLHDBC        ConnectionHandle,  
     SQLCHAR *      ServerName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      UserName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      Authentication,  
     SQLSMALLINT    NameLength3);  
```  
  
## <a name="arguments"></a>Аргументы  
 *коннектионхандле*  
 [Input] Дескриптор подключения  
  
 *ServerName*  
 Входной Имя источника данных. Данные могут находиться на том же компьютере, что и программа, или на другом компьютере в сети. Сведения о том, как приложение выбирает источник данных, см. [в разделе Выбор источника данных или драйвера](../../../odbc/reference/develop-app/choosing-a-data-source-or-driver.md).  
  
 *NameLength1*  
 Входной Длина **ServerName* в символах.  
  
 *UserName*  
 Входной Идентификатор пользователя.  
  
 *NameLength2*  
 Входной Длина *имени пользователя* в символах.  
  
 *Аутентификация*  
 Входной Строка проверки подлинности (обычно пароль).  
  
 *NameLength3*  
 Входной Длина **Проверка подлинности* в символах.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLConnect** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_DBC и *маркером* *коннектионхандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLConnect** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Значение параметра изменено|Драйвер не поддерживал указанное значение аргумента *ValuePtr* в **SQLSetConnectAttr** и заменял аналогичное значение. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08001|Клиенту не удалось установить подключение|Драйверу не удалось установить соединение с источником данных.|  
|08002|Имя подключения используется|(DM) указанный *коннектионхандле* уже использовался для установления соединения с источником данных, подключение по-прежнему было открыто или пользователь просматривает подключение.|  
|08004|Сервер отклонил подключение|Источник данных отклонил установку соединения для определенных реализацией причин.|  
|08S01|Сбой канала связи|Не удалось установить связь между драйвером и источником данных, к которому драйвер пытался подключиться, прежде чем функция завершила обработку.|  
|28000|Недопустимая спецификация авторизации|Значение, указанное для аргумента *username* или значение, заданное для *проверки подлинности* аргумента, нарушает ограничения, определенные источником данных.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|(DM) диспетчеру драйверов не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *коннектионхандле*. Была вызвана функция **SQLConnect** , до ее завершения была вызвана [функция склканцелхандле](../../../odbc/reference/syntax/sqlcancelhandle-function.md) в *Коннектионхандле*, а затем в *коннектионхандле* был вызвана функция **SQLConnect** .<br /><br /> Или была вызвана функция **SQLConnect** , и до ее завершения была вызвана **склканцелхандле** в *коннектионхандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызывается асинхронно исполняемая функция (не эта одна) для *коннектионхандле* и все еще выполнялась при вызове этой функции.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное для аргумента *NameLength1*, *NameLength2* или *NameLength3* , было меньше 0, но не равно SQL_NTS.<br /><br /> (DM) значение, указанное для аргумента *NameLength1* , превысило максимальную длину имени источника данных.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до завершения соединения с источником данных. Период ожидания задается через **SQLSetConnectAttr**, SQL_ATTR_LOGIN_TIMEOUT.|  
|HY114|Драйвер не поддерживает асинхронное выполнение функции на уровне соединения|(DM). приложение включило асинхронную операцию для этого обработчика соединения перед подключением. Однако драйвер не поддерживает асинхронные операции с маркером подключения.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, указанный в имени источника данных, не поддерживает функцию.|  
|IM002|Источник данных не найден, драйвер по умолчанию не указан|(DM) имя источника данных, указанное в аргументе *ServerName* , не было найдено в сведениях о системе и не содержит спецификацию драйвера по умолчанию.|  
|IM003|Не удалось подключить указанный драйвер к|(DM) драйвер, указанный в спецификации источника данных в сведениях о системе, не найден или не может быть подключен по какой-либо другой причине.|  
|IM004|Сбой функцию SQLAllocHandle драйвера на SQL_HANDLE_ENV|(DM) во время **SQLConnect** диспетчер драйверов вызвал функцию **функцию SQLAllocHandle** драйвера с *параметром handletype* SQL_HANDLE_ENV и драйвер вернул ошибку.|  
|IM005|Сбой функцию SQLAllocHandle драйвера на SQL_HANDLE_DBC|(DM) во время **SQLConnect** диспетчер драйверов вызвал функцию **функцию SQLAllocHandle** драйвера с *параметром handletype* SQL_HANDLE_DBC и драйвер вернул ошибку.|  
|IM006|Сбой SQLSetConnectAttr драйвера|Во время **SQLConnect** диспетчер драйверов, вызываемый функцией **SQLSetConnectAttr** драйвера, и драйвер вернул ошибку. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|IM009|Не удается подключиться к библиотеке DLL преобразования|Драйверу не удалось подключиться к библиотеке DLL преобразования, указанной для источника данных.|  
|IM010|Слишком длинное имя источника данных|(DM) *\* ServerName* длиннее SQL_MAX_DSN_LENGTH символов.|  
|IM014|Указанное имя источника данных содержит несоответствие архитектуры драйвера и приложения|(DM) 32-разрядное приложение использует имя DSN, которое подключается к 64-разрядному драйверу; или наоборот.|  
|IM015|Сбой SQLConnect драйвера на SQL_HANDLE_DBC_INFO_HANDLE|Если драйвер возвращает SQL_ERROR, диспетчер драйверов вернет SQL_ERROR в приложение, и подключение завершится сбоем.<br /><br /> Дополнительные сведения о SQL_HANDLE_DBC_INFO_TOKEN см. [в разделе Разработка осведомленности Connection-Pool в драйвере ODBC](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md).|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
|S1118|Драйвер не поддерживает асинхронное уведомление|Если драйвер не поддерживает асинхронное уведомление, нельзя задать SQL_ATTR_ASYNC_DBC_EVENT или SQL_ATTR_ASYNC_DBC_RETCODE_PTR.|  
  
## <a name="comments"></a>Комментарии  
 Сведения о том, почему приложение использует **SQLConnect**, см. [в разделе Подключение с помощью SQLConnect](../../../odbc/reference/develop-app/connecting-with-sqlconnect.md).  
  
 Диспетчер драйверов не подключается к драйверу, пока приложение не вызовет функцию (**SQLConnect**, **SQLDriverConnect** или **SQLBrowseConnect**) для подключения к драйверу. До этого момента диспетчер драйверов работает с собственными дескрипторами и управляет сведениями о соединении. Когда приложение вызывает функцию подключения, диспетчер драйверов проверяет, подключен ли в данный момент драйвер для указанного *коннектионхандле*:  
  
-   Если драйвер не подключен к, диспетчер драйверов подключается к драйверу и вызывает **функцию SQLAllocHandle** с *параметром handletype* SQL_HANDLE_ENV, **функцию SQLAllocHandle** с *параметром handletype* SQL_HANDLE_DBC, **SQLSetConnectAttr** (если приложение указало какие-либо атрибуты подключения) и функцию подключения в драйвере. Диспетчер драйверов возвращает значение SQLSTATE IM006 (сбой драйвера **SQLSetConnectOption** ) и SQL_SUCCESS_WITH_INFO для функции подключения, если драйвер вернул ошибку для **SQLSetConnectAttr**. Дополнительные сведения см. [в разделе Подключение к источнику данных или драйверу](../../../odbc/reference/develop-app/connecting-to-a-data-source-or-driver.md).  
  
-   Если указанный драйвер уже подключен к *коннектионхандле*, диспетчер драйверов вызывает только функцию подключения в драйвере. В этом случае драйвер должен убедиться, что все атрибуты подключения для *коннектионхандле* сохраняют свои текущие параметры.  
  
-   Если подключен другой драйвер, диспетчер драйверов вызывает **SQLFreeHandle** с *параметром handletype* SQL_HANDLE_DBC, а затем, если в этой среде не подключен другой драйвер, он вызывает **SQLFreeHandle** с *параметром handletype* SQL_HANDLE_ENV в подключенном драйвере, а затем отключает этот драйвер. Затем он выполняет те же операции, что и при отсутствии подключения к драйверу.  
  
 Затем драйвер выделяет дескрипторы и инициализирует их.  
  
 Когда приложение вызывает **SQLDisconnect**, диспетчер драйверов вызывает **SQLDisconnect** в драйвере. Однако он не отключает драйвер. Это позволяет сохранить драйвер в памяти для приложений, которые многократно подключаются к источнику данных и отключаются от него. Когда приложение вызывает **SQLFreeHandle** с *параметром handletype* SQL_HANDLE_DBC, диспетчер драйверов вызывает **SQLFreeHandle** с *параметром handletype* SQL_HANDLE_DBC, а затем **SQLFreeHandle** с *параметром handletype* SQL_HANDLE_ENV в драйвере, а затем отключает драйвер.  
  
 Приложение ODBC может устанавливать более одного соединения.  
  
## <a name="driver-manager-guidelines"></a>Рекомендации по диспетчеру драйверов  
 Содержимое файла **ServerName* влияет на совместную работу диспетчера драйверов и драйвера для установления соединения с источником данных.  
  
-   Если \* *ServerName* содержит допустимое имя источника данных, диспетчер драйверов находит соответствующую спецификацию источника данных в сведениях о системе и подключается к соответствующему драйверу. Диспетчер драйверов передает каждый аргумент **SQLConnect** драйверу.  
  
-   Если имя источника данных не найдено или *ServerName* является пустым указателем, диспетчер драйверов находит спецификацию источника данных по умолчанию и подключается к соответствующему драйверу. Диспетчер драйверов передает драйверу *имя пользователя* и аргументы *проверки подлинности* без изменений и значение по умолчанию для аргумента *ServerName* .  
  
-   Если аргумент *ServerName* имеет значение "default", диспетчер драйверов находит спецификацию источника данных по умолчанию и подключается к соответствующему драйверу. Диспетчер драйверов передает каждый аргумент **SQLConnect** драйверу.  
  
-   Если имя источника данных не найдено или *ServerName* является пустым указателем, а спецификация источника данных по умолчанию не существует, диспетчер драйверов возвращает SQL_ERROR с параметром SQLSTATE IM002 (имя источника данных не найдено, а драйвер по умолчанию не указан).  
  
 После подключения к диспетчеру драйверов драйвер может определить соответствующую спецификацию источника данных в сведениях о системе и использовать сведения, относящиеся к драйверу, из спецификации для завершения набора необходимых сведений о соединении.  
  
 Если в сведениях о системе для источника данных указана Библиотека преобразования по умолчанию, драйвер подключится к нему. Можно подключить другую библиотеку преобразования, вызвав **SQLSetConnectAttr** с атрибутом SQL_ATTR_TRANSLATE_LIB. Параметр перевода можно указать, вызвав **SQLSetConnectAttr** с атрибутом SQL_ATTR_TRANSLATE_OPTION.  
  
 Если драйвер поддерживает **SQLConnect**, раздел "ключевое слово драйвера" системных сведений о драйвере должен содержать ключевое слово **коннектфунктионс** , в первом символе которого задано значение "Y".  
  
### <a name="connection-pooling"></a>Объединение подключений в пул  
 Пул соединений позволяет приложению повторно использовать уже созданное соединение. Если включено использование пулов соединений и **SQLConnect** вызывается, диспетчер драйверов пытается установить соединение с помощью соединения, входящего в пул подключений в среде, которая была назначена для пула подключений. Эта среда является общей средой, используемой всеми приложениями, которые используют подключения в пуле.  
  
 Пул соединений включается до выделения среды путем вызова **SQLSetEnvAttr** , чтобы задать SQL_ATTR_CONNECTION_POOLING SQL_CP_ONE_PER_DRIVER (который указывает максимум одного пула для каждого драйвера) или SQL_CP_ONE_PER_HENV (который задает максимум один пул для каждой среды). **SQLSetEnvAttr** в этом случае вызывается с параметром *енвиронменсандле* , для которого задано значение null, что делает атрибут атрибутом уровня процесса. Если для SQL_ATTR_CONNECTION_POOLING установлено значение SQL_CP_OFF, пулы соединений отключены.  
  
 После включения пула соединений для выделения среды вызывается **функцию SQLAllocHandle** с *параметром handletype* SQL_HANDLE_ENV. Среда, выделенная этим вызовом, является общей средой, так как включена поддержка пулов соединений. Однако используемая среда не определяется до тех пор, пока не будет вызван **функцию SQLAllocHandle** с *параметром handletype* из SQL_HANDLE_DBC.  
  
 **Функцию SQLAllocHandle** с *параметром handletype* SQL_HANDLE_DBC вызывается для выделения подключения. Диспетчер драйверов пытается найти существующую общую среду, соответствующую атрибутам среды, заданным приложением. Если такой среды не существует, она создается как неявная *Общая среда*. Если найдена соответствующая общая среда, то в приложение возвращается маркер среды, а его число ссылок увеличивается.  
  
 Однако используемое соединение не определяется до тех пор, пока не будет вызван **SQLConnect** . На этом этапе диспетчер драйверов пытается найти в пуле соединений существующее соединение, которое соответствует критериям, запрошенным приложением. Эти критерии включают параметры соединения, запрошенные в вызове **SQLConnect** (значения *ServerName*, *username* и ключевые слова *проверки подлинности* ), и все атрибуты соединения, заданные с момента вызова **функцию SQLAllocHandle** с *параметром handletype* SQL_HANDLE_DBC. Диспетчер драйверов проверяет эти критерии по соответствующим ключевым словам соединения и атрибутам в соединениях в пуле. Если совпадение найдено, используется соединение в пуле. Если совпадений не найдено, создается новое соединение.  
  
 Если для атрибута среды SQL_ATTR_CP_MATCH задано значение SQL_CP_STRICT_MATCH, соответствие должно быть точным для используемого соединения в пуле. Если для атрибута среды SQL_ATTR_CP_MATCH задано значение SQL_CP_RELAXED_MATCH, параметры соединения в вызове **SQLConnect** должны совпадать, но не все атрибуты соединения должны совпадать.  
  
 Следующие правила применяются, если атрибут соединения, заданный приложением до **SQLConnect** , не соответствует атрибуту соединения в пуле.  
  
-   Если необходимо задать атрибут соединения до установки соединения:  
  
     Если SQL_ATTR_CP_MATCH SQL_CP_STRICT_MATCH, SQL_ATTR_PACKET_SIZE в соединении с пулом должны совпадать с атрибутом, заданным приложением. Если SQL_CP_RELAXED_MATCH, значения SQL_ATTR_PACKET_SIZE могут отличаться.  
  
     Значение SQL_ATTR_LOGIN_VALUE не влияет на совпадение.  
  
-   Значение, если атрибут соединения можно задать до или после установки соединения:  
  
     Если атрибут соединения не был задан приложением, но задан для соединения в пуле, и существует значение по умолчанию, атрибуту Connection в соединении с пулом присваивается значение по умолчанию и объявляется совпадение. Если значение по умолчанию отсутствует, соединение с пулом не считается совпадением.  
  
     Если атрибут Connection задан приложением, но не задан для соединения в пуле, атрибут соединения в пуле изменяется на, заданный приложением, и объявляется совпадение.  
  
     Если атрибут Connection задан приложением и установлен в соединении в пуле, но значения различаются, то используется значение атрибута соединения приложения и объявляется совпадение.  
  
-   Если значения атрибутов подключения для конкретного драйвера не идентичны, а SQL_ATTR_CP_MATCH имеет значение SQL_CP_STRICT_MATCH, то соединение в пуле не используется.  
  
 Когда приложение вызывает **SQLDisconnect** для отключения, подключение возвращается в пул соединений и доступно для повторного использования.  
  
### <a name="optimizing-connection-pooling-performance"></a>Оптимизация производительности пула подключений  
 При использовании распределенных транзакций можно оптимизировать производительность пула подключений с помощью **SQL_DTC_TRANSITION_COST**, которая представляет собой битовую маску SQLUINTEGER. Переходы, на которые ссылаются, — это переходы атрибута Connection SQL_ATTR_ENLIST_IN_DTC от значения 0 к нулю, и наоборот. Это соединение, которое не прикрепляется к распределенной транзакции для прикрепления к распределенной транзакции и наоборот. В зависимости от того, как драйвер реализует прикрепление (Установка атрибута соединения SQL_ATTR_ENLIST_IN_DTC), эти переходы могут быть дорогостоящими, поэтому их следует избегать для достижения лучшей производительности.  
  
 Значение, возвращаемое драйвером, содержит любое сочетание следующих битов:  
  
-   **SQL_DTC_ENLIST_EXPENSIVE**, если задано, подразумевает, что нулевой ненулевой переход значительно дороже, чем переход от ненулевого к другому ненулевому значению (прикрепление ранее прикрепленного соединения в своей следующей транзакции).  
  
-   **SQL_DTC_UNENLIST_EXPENSIVE**, если задано, подразумевает, что ненулевое значение перехода значительно дороже, чем использование соединения, атрибут SQL_ATTR_ENLIST_IN_DTC которого уже имеет нулевое значение.  
  
 Существует компромисс производительности и скорости использования соединения. Если драйвер указывает на то, что один или несколько переходов являются дорогостоящими, диспетчер драйверов отвечает на него, сохраняя в пуле больше соединений. Некоторые подключения в пуле являются предпочтительными для нетранзакционного использования, а некоторые являются предпочтительными для использования в транзакциях. Однако если драйвер указывает на то, что эти переходы не требуют больших затрат, можно использовать меньшее количество соединений, возможно, попеременно между нетранзакционным и транзакционным использованием.  
  
 Драйверы, которые не поддерживают SQL_ATTR_ENLIST_IN_DTC, не нуждаются в поддержке SQL_DTC_TRANSITION_COST. Для драйверов, которые поддерживают SQL_ATTR_ENLIST_IN_DTC но не SQL_DTC_TRANSITION_COST, предполагается, что переходы не являются дорогостоящими, как если бы для этого значения был возвращен 0 (для этого не задан бит).  
  
 Хотя SQL_DTC_TRANSITION_COST был представлен в ODBC 3,5, ODBC 2. драйвер *x* также может поддерживать его, так как диспетчер драйверов будет запрашивать эти сведения независимо от версии драйвера.  
  
### <a name="code-example"></a>Пример кода  
 В следующем примере приложение выделяет дескрипторы среды и соединения. Затем он подключается к источнику данных SalesOrders с ИДЕНТИФИКАТОРом пользователя Джонс и паролем Sesame и обрабатывает данные. После завершения обработки данных он отключается от источника данных и освобождает дескрипторы.  
  
```cpp  
// SQLConnect_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <sqlext.h>  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt;  
   SQLRETURN retcode;  
  
   SQLCHAR * OutConnStr = (SQLCHAR * )malloc(255);  
   SQLSMALLINT * OutConnStrLen = (SQLSMALLINT *)malloc(255);  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLCHAR*) "NorthWind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение маркера|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Обнаружение и перечисление значений, необходимых для подключения к источнику данных|[Функция SQLBrowseConnect](../../../odbc/reference/syntax/sqlbrowseconnect-function.md)|  
|Отключение от источника данных|[Функция SQLDisconnect](../../../odbc/reference/syntax/sqldisconnect-function.md)|  
|Соединение с источником данных с помощью строки подключения или диалогового окна|[Функция SQLDriverConnect](../../../odbc/reference/syntax/sqldriverconnect-function.md)|  
|Возврат значения атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Установка атрибута соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
