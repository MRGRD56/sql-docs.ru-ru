---
description: Функция SQLBindParameter
title: Функция SQLBindParameter | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLBindParameter
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLBindParameter
helpviewer_keywords:
- SQLBindParameter function [ODBC]
ms.assetid: 38349d4b-be03-46f9-9d6a-e50dd144e225
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: d173d3cc38a0f07532f6b9d8a225d9bbf44a6a28
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99181082"
---
# <a name="sqlbindparameter-function"></a>Функция SQLBindParameter

**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 2,0: ODBC  
  
 **Сводка**  
 **SQLBindParameter** привязывает буфер к маркеру параметра в инструкции SQL. **SQLBindParameter** поддерживает привязку к типу данных Юникода C, даже если базовый драйвер не поддерживает данные в Юникоде.  
  
> [!NOTE]  
>  Эта функция заменяет функцию **SQLSETPARAM** ODBC 1,0. Дополнительные сведения см. в разделе "Комментарии".  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp
  
SQLRETURN SQLBindParameter(  
      SQLHSTMT        StatementHandle,  
      SQLUSMALLINT    ParameterNumber,  
      SQLSMALLINT     InputOutputType,  
      SQLSMALLINT     ValueType,  
      SQLSMALLINT     ParameterType,  
      SQLULEN         ColumnSize,  
      SQLSMALLINT     DecimalDigits,  
      SQLPOINTER      ParameterValuePtr,  
      SQLLEN          BufferLength,  
      SQLLEN *        StrLen_or_IndPtr);  
```
  
## <a name="arguments"></a>Аргументы

 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *параметернумбер*  
 Входной Номер параметра, упорядоченный последовательно в порядке возрастания параметров, начиная с 1.  
  
 *InputOutputType*  
 Входной Тип параметра. Дополнительные сведения см. в разделе "аргумент *инпутаутпуттипе* " в разделе "Комментарии".  
  
 *ValueType*  
 Входной Тип данных C для параметра. Дополнительные сведения см. в разделе "аргумент *ValueType* " в разделе "Комментарии".  
  
 *ParameterType*  
 Входной Тип данных SQL параметра. Дополнительные сведения см. в разделе "аргумент *ParameterType* " в разделе "Комментарии".  
  
 *ColumnSize*  
 Входной Размер столбца или выражения соответствующего маркера параметра. Дополнительные сведения см. в разделе "аргумент *ColumnSize* " в разделе "Комментарии".  
  
 Если приложение будет работать в 64-разрядной операционной системе Windows, см. раздел [сведения о ODBC 64-bit](../../../odbc/reference/odbc-64-bit-information.md).  
  
 *DecimalDigits*  
 Входной Десятичные разряды столбца или выражения соответствующего маркера параметра. Дополнительные сведения о размере столбцов см. в разделе [размер столбца, десятичные цифры, длина октета и размер отображаемого](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)данных.  
  
 *параметервалуептр*  
 [Отложенный вход] Указатель на буфер для данных параметра. Дополнительные сведения см. в разделе "аргумент *параметервалуептр* " в разделе "Комментарии".  
  
 *BufferLength*  
 [Входные и выходные данные] Длина буфера *параметервалуептр* в байтах. Дополнительные сведения см. в разделе "аргумент *BufferLength* " в разделе "Комментарии".  
  
 Если приложение будет работать в 64-разрядной операционной системе, см. [сведения о ODBC 64-bit](../../../odbc/reference/odbc-64-bit-information.md).  
  
 *StrLen_or_IndPtr*  
 [Отложенный вход] Указатель на буфер для длины параметра. Дополнительные сведения см. в разделе "*StrLen_or_IndPtr* аргумент" раздела "Комментарии".  
  
## <a name="returns"></a>Возвращаемое значение

 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика

 Когда **SQLBindParameter** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLBindParameter** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  

|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута ограниченного типа данных|Тип данных, определяемый аргументом *ValueType* , не может быть преобразован в тип данных, определяемый аргументом *ParameterType* . Обратите внимание, что эта ошибка может возвращаться **SQLExecDirect**, **SQLExecute** или **SQLPutData** во время выполнения, а не **SQLBindParameter**.|  
|07009|Недопустимый индекс дескриптора|(DM) значение, указанное для аргумента *параметернумбер* , было меньше 1.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере **MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003|Недопустимый тип буфера приложения|Значение, заданное аргументом *ValueType* , не является допустимым типом данных C или SQL_C_DEFAULT.|  
|HY004|Недопустимый тип данных SQL|Значение, указанное для аргумента *ParameterType* , не является допустимым идентификатором типа данных SQL ODBC или идентификатором типа данных SQL, зависящим от драйвера, поддерживаемым драйвером.|  
|HY009|Недопустимое значение аргумента|(DM) аргумент *параметервалуептр* был пустым указателем, аргумент *StrLen_or_IndPtr* был пустым указателем, а аргумент *инпутаутпуттипе* не SQL_PARAM_OUTPUT.<br /><br /> (DM) SQL_PARAM_OUTPUT, где аргумент *параметервалуептр* был пустым указателем, тип C — char или binary, а BufferLength (*кбвалуемакс*) больше 0.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове **SQLBindParameter** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) была вызвана асинхронно исполняемая функция для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY021|Непоследовательные сведения о дескрипторе|Данные дескриптора, проверенные во время проверки согласованности, не были согласованы. (См. раздел "проверки согласованности" в **SQLSetDescField**.)<br /><br /> Значение, указанное для аргумента *деЦималдигитс* , находится вне диапазона значений, поддерживаемых источником данных для столбца типа данных SQL, указанного аргументом *ParameterType* .|  
|HY090|Недопустимая длина строки или буфера|(DM) значение в *BufferLength* было меньше 0. (См. Описание поля SQL_DESC_DATA_PTR в **SQLSetDescField**.)|  
|HY104|Недопустимое значение точности или масштаба|Значение, указанное для аргумента *ColumnSize* или *деЦималдигитс* , находится вне диапазона значений, поддерживаемых источником данных для столбца типа данных SQL, указанного аргументом *ParameterType* .|  
|HY105|Недопустимый тип параметра|(DM) значение, указанное для аргумента *инпутаутпуттипе* , недопустимо. (См. раздел "Комментарии".)|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает преобразование, указанное сочетанием значения, указанного для аргумента *ValueType* , и значения, зависящего от драйвера, заданного для аргумента *ParameterType*.<br /><br /> Значение, заданное для аргумента *ParameterType* , является допустимым идентификатором типа данных ODBC SQL для версии ODBC, поддерживаемой драйвером, но не поддерживаемой драйвером или источником данных.<br /><br /> Драйвер поддерживает только ODBC 2. *x* и *ValueType* аргумента являются одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и все типы данных интервала C, перечисленные в разделе [типы данных c](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: типы данных.<br /><br /> Драйвер поддерживает только версии ODBC до 3,50, а аргумент *ValueType* SQL_C_GUID.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии

 Приложение вызывает **SQLBindParameter** для привязки каждого маркера параметра в инструкции SQL. Привязки действуют до тех пор, пока приложение не вызовет **SQLBindParameter** снова, вызывает **SQLFreeStmt** с параметром SQL_RESET_PARAMS или вызывает **SQLSetDescField** , чтобы задать SQL_DESC_COUNT в поле заголовка APD значение 0.  
  
 Дополнительные сведения о параметрах см. в разделе [Параметры инструкции](../../../odbc/reference/develop-app/statement-parameters.md). Дополнительные сведения о типах данных параметров и маркерах параметров см. в разделе [типы данных](../../../odbc/reference/appendixes/parameter-data-types.md) и [маркеры параметров](../../../odbc/reference/appendixes/parameter-markers.md) в приложении C: грамматика SQL.  
  
## <a name="parameternumber-argument"></a>Параметернумбер, аргумент  
 Если *параметернумбер* в вызове **SQLBindParameter** больше, чем значение SQL_DESC_COUNT, вызывается **SQLSetDescField** , чтобы увеличить значение SQL_DESC_COUNT в *параметернумбер*.  
  
## <a name="inputoutputtype-argument"></a>Инпутаутпуттипе, аргумент  
 Аргумент *инпутаутпуттипе* указывает тип параметра. Этот аргумент задает SQL_DESC_PARAMETER_TYPE поле для IPD. Все параметры в инструкциях SQL, которые не вызывают процедуры, такие как инструкции **INSERT** , являются *входными* *параметрами*. Параметрами в вызовах процедур могут быть входные, входные и выходные параметры. (Приложение вызывает **SQLProcedureColumns** для определения типа параметра в вызове процедуры; параметры, тип которых не может быть определен, считаются входными параметрами.)  
  
 Аргумент *InputOutputType* может иметь одно из следующих значений:  
  
-   SQL_PARAM_INPUT. Параметр помечает параметр в инструкции SQL, которая не вызывает процедуру, например инструкцию **INSERT** , или помечает входной параметр в процедуре. Например, параметры в инструкции **INSERT в значениях сотрудников (?,?,?)** являются входными параметрами, тогда как параметры в **{call аддемп (?,?,?)}** могут быть, но не обязательно являются входными параметрами.  
  
     При выполнении инструкции драйвер отправляет данные для параметра в источник данных. буфер \* *параметервалуептр* должен содержать допустимое входное значение, либо буфер **StrLen_or_IndPtr* должен содержать SQL_NULL_DATA, SQL_DATA_AT_EXEC или результат макроса SQL_LEN_DATA_AT_EXEC.  
  
     Если приложение не может определить тип параметра в вызове процедуры, оно устанавливает для *инпутаутпуттипе* значение SQL_PARAM_INPUT; Если источник данных возвращает значение для параметра, драйвер отклоняет его.  
  
-   SQL_PARAM_INPUT_OUTPUT. Параметр помечает входной/выходной параметр в процедуре. Например, параметр в **{Call жетемпдепт (?)}** является входным и выходным параметром, который принимает имя сотрудника и возвращает имя отдела сотрудника.  
  
     При выполнении инструкции драйвер отправляет данные для параметра в источник данных. буфер \* *параметервалуептр* должен содержать допустимое входное значение, либо буфер \* *StrLen_or_IndPtr* должен содержать SQL_NULL_DATA, SQL_DATA_AT_EXEC или результат макроса SQL_LEN_DATA_AT_EXEC. После выполнения инструкции драйвер возвращает данные для параметра в приложение. Если источник данных не возвращает значение для параметра ввода-вывода, драйвер устанавливает буфер **StrLen_or_IndPtr* для SQL_NULL_DATA.  
  
    > [!NOTE]  
    >  Когда приложение ODBC 1,0 вызывает **SQLSetParam** в драйвере ODBC 2,0, диспетчер драйверов преобразует его в вызов **SQLBindParameter** , в котором аргумент *инпутаутпуттипе* имеет значение SQL_PARAM_INPUT_OUTPUT.  
  
-   SQL_PARAM_OUTPUT. Параметр помечает возвращаемое значение процедуры или выходного параметра в процедуре; в любом случае они называются *выходными параметрами*. Например, параметр в **{? = Call жетнекстемпид}** является выходным параметром, который ВОЗВРАЩАЕТ следующий идентификатор сотрудника.  
  
     После выполнения инструкции драйвер возвращает данные для параметра в приложение, если только аргументы *параметервалуептр* и *StrLen_or_IndPtr* не являются пустыми указателями, в этом случае драйвер отклоняет выходное значение. Если источник данных не возвращает значение для выходного параметра, драйвер устанавливает буфер **StrLen_or_IndPtr* для SQL_NULL_DATA.  
  
-   SQL_PARAM_INPUT_OUTPUT_STREAM. Указывает, что входной или выходной параметр должен быть потоковым. **SQLGetData** может считывать значения параметров в частях. *BufferLength* игнорируется, так как длина буфера определяется при вызове **SQLGetData**. Значение буфера *StrLen_or_IndPtr* должно содержать SQL_NULL_DATA, SQL_DEFAULT_PARAM, SQL_DATA_AT_EXEC или результат макроса SQL_LEN_DATA_AT_EXEC. Параметр должен быть привязан как параметр данных при выполнении (DAE) на входе, если он будет передаваться в поток выходных данных. *Параметервалуептр* может быть любым значением указателя, отличным от NULL, которое будет возвращено **метод SQLParamData** в качестве определяемого пользователем маркера, значение которого было передано с помощью *параметервалуептр* для входных и выходных данных. Дополнительные сведения см. в разделе [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_PARAM_OUTPUT_STREAM. То же, что и SQL_PARAM_INPUT_OUTPUT_STREAM, для выходного параметра. *Во входных данных *StrLen_or_IndPtr* игнорируется.  
  
 В следующей таблице перечислены различные сочетания *инпутаутпуттипе* и **StrLen_or_IndPtr*.  
  
|*InputOutputType*|**StrLen_or_IndPtr*|Результат|Замечание на Параметервалуептр|  
|-----------------------|----------------------------|-------------|---------------------------------|  
|SQL_PARAM_INPUT|SQL_LEN_DATA_AT_EXEC (*Len*) или SQL_DATA_AT_EXEC|Входные данные частей|*Параметервалуептр* может быть любым значением указателя, которое будет возвращено **метод SQLParamData** в качестве определяемого пользователем маркера, значение которого было передано с помощью *параметервалуептр*.|  
|SQL_PARAM_INPUT|Не SQL_LEN_DATA_AT_EXEC (*Len*) или SQL_DATA_AT_EXEC|Буфер привязки ввода|*Параметервалуептр* — это адрес входного буфера.|  
|SQL_PARAM_OUTPUT|Во входных данных игнорируется.|Буфер привязки вывода|*Параметервалуептр* — это адрес выходного буфера.|  
|SQL_PARAM_OUTPUT_STREAM|Во входных данных игнорируется.|Потоковый вывод|*Параметервалуептр* может быть любым значением указателя, которое будет возвращено **метод SQLParamData** в качестве определяемого пользователем маркера, значение которого было передано с помощью *параметервалуептр*.|  
|SQL_PARAM_INPUT_OUTPUT|SQL_LEN_DATA_AT_EXEC (*Len*) или SQL_DATA_AT_EXEC|Входные данные в части и буфер, привязанный к выходу|*Параметервалуептр* — это адрес выходного буфера, который также будет возвращен **метод SQLParamData** в качестве определяемого пользователем маркера, значение которого было передано в *параметервалуептр*.|  
|SQL_PARAM_INPUT_OUTPUT|Не SQL_LEN_DATA_AT_EXEC (*Len*) или SQL_DATA_AT_EXEC|Буфер привязки входных данных и буфер привязки вывода|*Параметервалуептр* — это адрес общего буфера ввода-вывода.|
|SQL_PARAM_INPUT_OUTPUT_STREAM|SQL_LEN_DATA_AT_EXEC (*Len*) или SQL_DATA_AT_EXEC|Входные данные частей и потокового вывода|*Параметервалуептр* может быть любым значением указателя, отличным от NULL, которое будет возвращено **метод SQLParamData** в качестве определяемого пользователем маркера, значение которого было передано с помощью *параметервалуептр* для входных и выходных данных.|  
  
> [!NOTE]  
>  Драйвер должен решить, какие типы SQL разрешены, когда приложение привязывает параметр Output или Input-Output к потоковой передаче. Диспетчер драйверов не выдаст ошибку для недопустимого типа SQL.  
  
## <a name="valuetype-argument"></a>Аргумент ValueType

 Аргумент *ValueType* задает тип данных C для параметра. Этот аргумент задает поля SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE объекта APD. Это должно быть одно из значений в разделе " [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) " приложения г: типы данных.  
  
 Если аргумент *ValueType* является одним из типов данных интервала, поле SQL_DESC_TYPE записи *параметернумбер* APD имеет значение SQL_INTERVAL, поле SQL_DESC_CONCISE_TYPE APD имеет тип данных краткая интервал, а в поле SQL_DESC_DATETIME_INTERVAL_CODE записи *параметернумбер* задается подкод для определенного типа данных Interval. (См. [приложение г. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).) Начальная точность по умолчанию (2) и интервал в секундах (6), заданная в полях SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION APD, соответственно, используются для данных. Если точность по умолчанию не подходит, приложение должно явно задать поле дескриптора путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Если аргумент *ValueType* является одним из типов данных DateTime, то поле SQL_DESC_TYPE записи *параметернумбер* APD имеет значение SQL_DATETIME, в поле SQL_DESC_CONCISE_TYPE записи *параметернумбер* для APD задается тип данных Краткая дата и время, а в поле SQL_DESC_DATETIME_INTERVAL_CODE записи *параметернумбер* задается подкод для конкретного типа данных DateTime. (См. [приложение г. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)  
  
 Если аргумент *ValueType* имеет тип данных SQL_C_NUMERIC, точность по умолчанию (определяемая драйвером) и масштаб по умолчанию (0), заданный в полях SQL_DESC_PRECISION и SQL_DESC_SCALE APD, используются для данных. Если точность или масштаб по умолчанию не подходят, приложение должно явно задать поле дескриптора путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 SQL_C_DEFAULT указывает, что значение параметра должно быть передано из типа данных C по умолчанию для типа данных SQL, указанного параметром *ParameterType*.  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 Дополнительные сведения см. в разделе Типы данных [c по умолчанию](../../../odbc/reference/appendixes/default-c-data-types.md), [Преобразование данных из c в типы данных SQL](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md)и [Преобразование данных из типов данных SQL в c](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложении г: типы данных.  
  
## <a name="parametertype-argument"></a>ParameterType, аргумент

 Это должно быть одно из значений, перечисленных в разделе [типы данных SQL](../../../odbc/reference/appendixes/sql-data-types.md) приложения D: типы данных, или это значение должно быть зависящим от драйвера. Этот аргумент задает SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE поля IPD.  
  
 Если аргумент *ParameterType* является одним из идентификаторов DateTime, поле SQL_DESC_TYPE IPD имеет значение SQL_DATETIME, SQL_DESC_CONCISE_TYPE поле IPD имеет тип данных SQL "Краткая дата и время", а в поле "SQL_DESC_DATETIME_INTERVAL_CODE" устанавливается соответствующее значение подкода DateTime.  
  
 Если *ParameterType* является одним из идентификаторов интервалов, в поле SQL_DESC_TYPE IPD задается значение SQL_INTERVAL, в поле SQL_DESC_CONCISE_TYPE IPD задается сокращенный тип данных интервала SQL, а в поле SQL_DESC_DATETIME_INTERVAL_CODE IPD задается соответствующий код интервала. В поле SQL_DESC_DATETIME_INTERVAL_PRECISION IPD задается начальная точность интервала, а для поля SQL_DESC_PRECISION — значение интервала в секундах (если применимо). Если значение по умолчанию SQL_DESC_DATETIME_INTERVAL_PRECISION или SQL_DESC_PRECISION не подходит, приложение должно явно задать его, вызвав **SQLSetDescField**. Дополнительные сведения о любом из этих полей см. в разделе [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md).  
  
 Если аргумент *ValueType* является SQL_NUMERIC типом данных, точность по умолчанию (определяемая драйвером) и масштаб по умолчанию (0), заданный в полях SQL_DESC_PRECISION и SQL_DESC_SCALE IPD, используются для данных. Если точность или масштаб по умолчанию не подходят, приложение должно явно задать поле дескриптора путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Сведения о преобразовании данных см. в разделе [Преобразование данных из c в типы данных SQL](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md) и [Преобразование данных из типов данных SQL в c](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложении г: типы данных.  
  
## <a name="columnsize-argument"></a>ColumnSize, аргумент

 Аргумент *ColumnSize* задает размер столбца или выражения, которые соответствуют маркеру параметра, длине этих данных или обоим параметрам. Этот аргумент задает различные поля IPD в зависимости от типа данных SQL (аргумент *ParameterType* ). К этому сопоставлению применяются следующие правила.  
  
-   Если *ParameterType* имеет SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY или один из типов данных даты и времени SQL, в поле SQL_DESC_LENGTH IPD задается значение *ColumnSize*. (Дополнительные сведения см. в разделе [размер столбца, десятичные цифры, длина октета и размер отображаемого](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) раздела в приложении г: типы данных.)  
  
-   Если *ParameterType* имеет значение SQL_DECIMAL, SQL_NUMERIC, SQL_FLOAT, SQL_REAL или SQL_DOUBLE, поле SQL_DESC_PRECISION для IPD задается в значении *ColumnSize*.  
  
-   Для других типов данных аргумент *ColumnSize* игнорируется.  
  
 Дополнительные сведения см. в разделе "передача значений параметров" и SQL_DATA_AT_EXEC в "аргументе *StrLen_or_IndPtr* ".  
  
## <a name="decimaldigits-argument"></a>ДеЦималдигитс, аргумент

 Если *ParameterType* имеет значение SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP, SQL_INTERVAL_SECOND, SQL_INTERVAL_DAY_TO_SECOND, SQL_INTERVAL_HOUR_TO_SECOND или SQL_INTERVAL_MINUTE_TO_SECOND, поле SQL_DESC_PRECISION для IPD устанавливается в значение *деЦималдигитс*. Если *ParameterType* имеет значение SQL_NUMERIC или SQL_DECIMAL, для поля SQL_DESC_SCALE IPD устанавливается значение *деЦималдигитс*. Для всех остальных типов данных аргумент *деЦималдигитс* игнорируется.  
  
## <a name="parametervalueptr-argument"></a>Параметервалуептр, аргумент

 Аргумент *параметервалуептр* указывает на буфер, который при вызове **SQLExecute** или **SQLExecDirect** содержит фактические данные для параметра. Данные должны быть в форме, заданной аргументом *ValueType* . Этот аргумент задает SQL_DESC_DATA_PTR поле APD. Приложение может установить для аргумента *параметервалуептр* указатель null, если *\* StrLen_or_IndPtr* SQL_NULL_DATA или SQL_DATA_AT_EXEC. (Это относится только к входным и выходным параметрам.)  
  
 Если \* *StrLen_or_IndPtr* является результатом макроса SQL_LEN_DATA_AT_EXEC (*Длина*) или SQL_DATA_AT_EXEC, то *параметервалуептр* является значением указателя, определяемым приложением и связанным с параметром. Он возвращается приложению через **метод SQLParamData**. Например, *параметервалуептр* может быть ненулевым токеном, таким как номер параметра, указатель на данные или указатель на структуру, которую приложение использовало для привязки входных параметров. Однако обратите внимание, что если параметр является входным или выходным параметром, *параметервалуептр* должен быть указателем на буфер, в котором будет храниться выходное значение. Если значение атрибута оператора SQL_ATTR_PARAMSET_SIZE больше 1, приложение может использовать значение, на которое указывает атрибут инструкции SQL_ATTR_PARAMS_PROCESSED_PTR, вместе с аргументом *параметервалуептр* . Например, *параметервалуептр* может указывать на массив значений, и приложение может использовать значение, на которое указывает, SQL_ATTR_PARAMS_PROCESSED_PTR для получения правильного значения из массива. Дополнительные сведения см. Далее в подразделе «передача значений параметров».  
  
 Если аргумент *инпутаутпуттипе* имеет SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, *параметервалуептр* указывает на буфер, в котором драйвер возвращает выходное значение. Если процедура возвращает один или несколько результирующих наборов, \* не гарантируется, что буфер *параметервалуептр* будет установлен до тех пор, пока не будут обработаны все результирующие наборы или количество строк. Если буфер не задан до завершения обработки, выходные параметры и возвращаемые значения будут недоступны до тех пор, пока **SQLMoreResults** не возвратит SQL_NO_DATA. Вызов **SQLCloseCursor** или **SQLFreeStmt** с параметром SQL_CLOSE приведет к отмене этих значений.  
  
 Если значение в атрибуте оператора SQL_ATTR_PARAMSET_SIZE больше 1, *параметервалуептр* указывает на массив. Одна инструкция SQL обрабатывает полный массив входных значений для входных или выходных параметров и возвращает массив выходных значений для входного/выходного или выходного параметра.  
  
## <a name="bufferlength-argument"></a>BufferLength, аргумент

 Для символьных и двоичных данных C аргумент *BufferLength* задает длину \* буфера *параметервалуептр* (если это единственный элемент) или длину элемента в \* массиве *параметервалуептр* (если значение в атрибуте оператора SQL_ATTR_PARAMSET_SIZE больше 1). Этот аргумент задает SQL_DESC_OCTET_LENGTH поле записи для APD. Если в приложении указано несколько значений, *BufferLength* используется для определения местоположения значений в массиве **параметервалуептр* , как на входе, так и на выходе. Для входных, выходных и выходных параметров используется для определения необходимости усечения символьных и двоичных данных C на выходе:  
  
-   Для символьных данных C, если число возвращаемых байт больше или равно *BufferLength*, данные в \* *параметервалуептр* усекаются до *BufferLength* меньше длины символа завершения, равного null, и заканчиваются драйвером.  
  
-   Для двоичных данных C, если количество доступных для возврата байт превышает *BufferLength*, данные в \* *параметервалуептр* усекаются до *BufferLength* байт.  
  
 Для всех других типов данных языка C аргумент *BufferLength* игнорируется. Длина \* буфера *параметервалуептр* (если он является единственным элементом) или длина элемента в \* массиве *Параметервалуептр* (если приложение вызывает **SQLSetStmtAttr** с аргументом *атрибута* SQL_ATTR_PARAMSET_SIZE, чтобы указать несколько значений для каждого параметра), предполагается, что это длина типа данных C.  
  
 Для потокового вывода или потоковых входных и выходных параметров аргумент *BufferLength* игнорируется, так как длина буфера указана в **SQLGetData**.  
  
> [!NOTE]  
>  Когда приложение ODBC 1,0 вызывает **SQLSetParam** в ODBC 3. драйвер *x* , диспетчер драйверов преобразует его в вызов **SQLBindParameter** , в котором аргумент *BufferLength* всегда SQL_SETPARAM_VALUE_MAX. Так как диспетчер драйверов возвращает ошибку, если ODBC 3. Приложение *x* устанавливает для *BufferLength* значение SQL_SETPARAM_VALUE_MAX, ODBC 3. драйвер *x* может использовать этот параметр, чтобы определить, когда он вызывается приложением ODBC 1,0.  
  
> [!NOTE]  
>  В **SQLSetParam**, способ, которым приложение определяет длину буфера *параметервалуептр* , чтобы драйвер мог вернуть символьные или двоичные данные, и способ, которым приложение отправляет в драйвер массив значений символьных или двоичных параметров, определяется драйвером.  
  
## <a name="strlen_or_indptr-argument"></a>StrLen_or_IndPtr аргумент

 Аргумент *StrLen_or_IndPtr* указывает на буфер, который при вызове **SQLExecute** или **SQLExecDirect** содержит один из следующих элементов. (Этот аргумент задает SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR поля записей указателей параметров приложения.)  
  
-   Длина значения параметра, хранящегося в **параметервалуептр*. Этот параметр игнорируется, за исключением символьных или двоичных данных C.  
  
-   SQL_NTS. Значение параметра является строкой, завершающейся нулем.  
  
-   SQL_NULL_DATA. Значение параметра равно NULL.  
  
-   SQL_DEFAULT_PARAM. Процедура заключается в использовании значения параметра по умолчанию вместо значения, полученного из приложения. Это значение допустимо только в процедуре, вызванной в каноническом синтаксисе ODBC, а затем только в том случае, если аргумент *инпутаутпуттипе* имеет значение SQL_PARAM_INPUT, SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_INPUT_OUTPUT_STREAM. Если \* *StrLen_or_IndPtr* имеет SQL_DEFAULT_PARAM, аргументы *ValueType*, *ParameterType*, *ColumnSize*, *деЦималдигитс*, *BufferLength* и *параметервалуептр* игнорируются для входных параметров и используются только для определения значения выходного параметра для входных и выходных параметров.  
  
-   Результат выполнения макроса SQL_LEN_DATA_AT_EXEC (*length*). Данные для параметра будут отправлены с помощью **SQLPutData**. Если аргумент *ParameterType* имеет значение SQL_LONGVARBINARY, SQL_LONGVARCHAR или длинный тип данных, зависящий от источника данных, а драйвер возвращает значение "Y" для SQL_NEED_LONG_DATA_LENного типа сведений в **SQLGetInfo**, то *Длина* — это число байтов данных, отправляемых для параметра. в противном случае *Длина* должна быть неотрицательным значением и игнорироваться. Дополнительные сведения см. Далее в подразделе «передача значений параметров».  
  
     Например, чтобы указать, что 10 000 байт данных будут отправляться с помощью **SQLPutData** в одном или нескольких вызовах, для параметра SQL_LONGVARCHAR приложение задаст **StrLen_or_IndPtr* для SQL_LEN_DATA_AT_EXEC (10000).  
  
-   SQL_DATA_AT_EXEC. Данные для параметра будут отправлены с помощью **SQLPutData**. Это значение используется приложениями ODBC 1,0 при вызове ODBC 3. драйверы *x* . Дополнительные сведения см. Далее в подразделе «передача значений параметров».  
  
 Если *StrLen_or_IndPtr* является пустым указателем, драйвер предполагает, что все входные значения параметров не равны NULL, а символьные и двоичные данные завершаются нулем. Если *инпутаутпуттипе* имеет значение SQL_PARAM_OUTPUT или SQL_PARAM_OUTPUT_STREAM *и* *StrLen_or_IndPtr* являются пустыми указателями, драйвер отклоняет выходное значение.  
  
> [!NOTE]  
>  Разработчикам приложений настоятельно не рекомендуется указывать указатель null для *StrLen_or_IndPtr* , если тип данных параметра — SQL_C_BINARY. Чтобы убедиться, что драйвер не выполняет непредвиденное усечение данных SQL_C_BINARY, *StrLen_or_IndPtr* должен содержать указатель на допустимое значение длины.  
  
 Если аргумент *инпутаутпуттипе* имеет значение SQL_PARAM_INPUT_OUTPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, *StrLen_or_IndPtr* указывает на буфер, в котором драйвер возвращает SQL_NULL_DATA, число байтов, доступных для возврата в \* *параметервалуептр* (за исключением байта завершающего нуль символа символьных данных) или SQL_NO_TOTAL (если количество байт, доступных для возврата, не может быть определено). Если процедура возвращает один или несколько результирующих наборов, то буфер **StrLen_or_IndPtr* не гарантируется, пока не будут получены все результаты.  
  
 Если значение атрибута оператора SQL_ATTR_PARAMSET_SIZE больше 1, *StrLen_or_IndPtr* указывает на массив значений SQLLEN. Это могут быть любые значения, перечисленные ранее в этом разделе, которые обрабатываются с помощью одной инструкции SQL.  
  
## <a name="passing-parameter-values"></a>Передача значений параметров

 Приложение может передать значение для параметра либо в \* буфер *параметервалуептр* , либо с помощью одного или нескольких вызовов **SQLPutData**. Параметры, данные которых передаются с помощью **SQLPutData** , известны как параметры *с данными при выполнении* . Обычно они используются для отправки данных для SQL_LONGVARBINARY и SQL_LONGVARCHAR параметров и могут быть смешаны с другими параметрами.  
  
 Для передачи значений параметров приложение выполняет следующую последовательность действий.  
  
1.  Вызывает **SQLBindParameter** для каждого параметра, чтобы привязать буферы для значения параметра (аргумента *параметервалуептр* ) и длины или индикатора (*StrLen_or_IndPtr* аргумент). Для параметров, выполняемых при выполнении данных, *параметервалуептр* — это определяемое приложением значение указателя, например номер параметра или указатель на данные. Значение будет возвращено позже и может быть использовано для обнаружения параметра.  
  
2.  Помещает значения для входных и выходных параметров в \* буферах *параметервалуептр* и *StrLen_or_IndPtr* *:  
  
    -   Для обычных параметров приложение помещает значение параметра в \* буфер *параметервалуептр* и длину этого значения в буфер **StrLen_or_IndPtr* . Дополнительные сведения см. в разделе [Задание значений параметров](../../../odbc/reference/develop-app/setting-parameter-values.md).  
  
    -   Для параметров, выполняемых при выполнении, приложение помещает результат SQL_LEN_DATA_AT_EXEC (*length*) макроса (при вызове драйвера ODBC 2,0) в буфере **StrLen_or_IndPtr* .  
  
3.  Вызывает **SQLExecute** или **SQLExecDirect** для выполнения инструкции SQL.  
  
    -   Если параметры данных не выполняются, процесс завершается.  
  
    -   Если какие-либо параметры данных выполняются, функция возвращает SQL_NEED_DATA.  
  
4.  Вызывает **метод SQLParamData** для получения определяемого приложением значения, указанного в аргументе *параметервалуептр* **SQLBindParameter** , для первого обрабатываемого параметра обработки данных. **Метод SQLParamData** возвращает SQL_NEED_DATA.  
  
    > [!NOTE]  
    >  Несмотря на то, что параметры данных во время выполнения похожи на столбцы данных в ходе выполнения, значение, возвращаемое функцией **метод SQLParamData** , отличается для каждого из них. Параметры данных при выполнении — это параметры в инструкции SQL, для которых данные будут отправляться с помощью **SQLPutData** при выполнении инструкции с **SQLExecDirect** или **SQLExecute**. Они связаны с **SQLBindParameter**. Значение, возвращаемое функцией **метод SQLParamData** , является значением указателя, передаваемым в **SQLBindParameter** в аргументе *параметервалуептр* . Столбцы "данные в ходе выполнения" — это столбцы в наборе строк, для которых данные будут отправляться с помощью **SQLPutData** при обновлении или добавлении строки с помощью **SQLBulkOperations** или при обновлении с помощью функции **SQLSetPos**. Они связаны с **SQLBindCol**. Значение, возвращаемое функцией **метод SQLParamData** , является адресом строки в буфере **таржетвалуептр* (задается вызовом **SQLBindCol**), который обрабатывается.  
  
5.  Вызывает **SQLPutData** один или несколько раз для отправки данных для параметра. Требуется более одного вызова, если значение данных больше, чем \* буфер *параметервалуептр* , указанный в **SQLPutData**; несколько вызовов **SQLPutData** для одного и того же параметра разрешены только при отправке символьных данных c в столбец с символьным, двоичным или определенным типом данных или при отправке двоичных данных c в столбец с символьным, двоичным или связанным с источником данных типом данных.  
  
6.  Вызывает **метод SQLParamData** еще раз, чтобы сообщить о том, что все данные были отправлены для параметра.  
  
    -   Если имеются дополнительные параметры, возвращаемые при выполнении, **метод SQLParamData** возвращает SQL_NEED_DATA и значение, определяемое приложением для следующего обрабатываемого параметра data-by-Execution. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет параметров для данных, процесс завершается. Если инструкция выполнена успешно, **метод SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; в случае сбоя выполнения возвращается SQL_ERROR. На этом этапе **метод SQLParamData** может возвращать любое значение SQLSTATE, которое может возвращаться функцией, используемой для выполнения инструкции (**SQLExecDirect** или **SQLExecute**).  
  
         Выходные значения для всех входных и выходных или выходных параметров доступны в \* буферах *параметервалуептр* и **StrLen_or_IndPtr* после того, как приложение извлекает все результирующие наборы, созданные инструкцией.  
  
 Вызов **SQLExecute** или **SQLExecDirect** помещает инструкцию в состояние SQL_NEED_DATA. На этом этапе приложение может вызывать только **SQLCancel**, **SQLGetDiagField**, **SQLGetDiagRec**, **SQLGetFunctions**, **метод SQLParamData** или **SQLPutData** с инструкцией или с *маркером соединения* , связанным с инструкцией. Если вызывается любая другая функция с инструкцией или соединение, связанное с инструкцией, функция возвращает значение SQLSTATE HY010 (ошибка последовательности функций). Инструкция оставляет SQL_NEED_DATA состояние, когда **метод SQLParamData** или **SQLPutData** возвращает ошибку, **метод SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO либо инструкция отменена.  
  
 Если приложение вызывает **SQLCancel** , а драйверу по-прежнему требуются данные для параметров выполнения, драйвер отменяет выполнение инструкции. Затем приложение может снова вызвать **SQLExecute** или **SQLExecDirect** .  
  
## <a name="retrieving-streamed-output-parameters"></a>Получение потоковых выходных параметров

 Когда приложение устанавливает *инпутаутпуттипе* в SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, значение выходного параметра должно быть получено одним или несколькими вызовами **SQLGetData**. Если драйвер имеет потоковое значение выходного параметра для возврата в приложение, оно будет возвращать SQL_PARAM_DATA_AVAILABLE в ответ на вызов следующих функций: **SQLMoreResults**, **SQLExecute** и **SQLExecDirect**. Приложение вызывает **метод SQLParamData** , чтобы определить, какое значение параметра доступно.  
  
 Дополнительные сведения о SQL_PARAM_DATA_AVAILABLE и потоковых выходных параметрах см. в разделе [получение выходных параметров с помощью SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="using-arrays-of-parameters"></a>Использование массивов параметров

 Когда приложение подготавливает инструкцию с маркерами параметров и передает массив параметров, можно выполнить два разных способа. Один из способов заключается в том, чтобы драйвер зависел от возможностей обработки массивов серверной части, в этом случае вся инструкция с массивом параметров рассматривается как одна атомарная единица. Oracle — это пример источника данных, поддерживающего возможности обработки массивов. Другим способом реализации этой функции является то, что драйвер создает пакет инструкций SQL, одну инструкцию SQL для каждого набора параметров в массиве параметров и выполняет пакет. Массивы параметров не могут использоваться с оператором Update, в **котором находится текущая** инструкция.  
  
 При обработке массива параметров могут быть доступны отдельные результирующие наборы или количество строк (по одному для каждого набора параметров), а количество результирующих наборов/строк может быть сведено в одну. Параметр SQL_PARAM_ARRAY_ROW_COUNTS в **SQLGetInfo** указывает, доступны ли счетчики строк для каждого набора параметров (SQL_PARC_BATCH) или доступно только одно число строк (SQL_PARC_NO_BATCH).  
  
 Параметр SQL_PARAM_ARRAY_SELECTS в **SQLGetInfo** указывает, доступен ли результирующий набор для каждого набора параметров (SQL_PAS_BATCH) или доступен только один результирующий набор (SQL_PAS_NO_BATCH). Если драйвер не допускает выполнения инструкции создания результирующего набора с массивом параметров, SQL_PARAM_ARRAY_SELECTS возвращает SQL_PAS_NO_SELECT.  
  
 Дополнительные сведения см. в разделе [функция SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md).  
  
 Для поддержки массивов параметров в атрибуте инструкции SQL_ATTR_PARAMSET_SIZE задано указание количества значений для каждого параметра. Если поле больше 1, поля SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR объекта APD должны указывать на массивы. Количество элементов массива равно значению SQL_ATTR_PARAMSET_SIZE.  
  
 Поле SQL_DESC_ROWS_PROCESSED_PTR APD указывает на буфер, содержащий количество обработанных параметров, включая наборы ошибок. При обработке каждого набора параметров драйвер сохраняет новое значение в буфере. Если это указатель null, число не будет возвращено. При использовании массивов параметров значение, на которое указывает SQL_DESC_ROWS_PROCESSED_PTR поле APD, заполняется, даже если функция настройки возвращает SQL_ERROR. Если возвращается SQL_NEED_DATA, значение, на которое указывает SQL_DESC_ROWS_PROCESSED_PTR поле APD, задается набором обрабатываемых параметров.  
  
 Что происходит при привязке массива параметров и **обновлении, где выполняется текущая** инструкция, определяется драйвером.  
  
## <a name="column-wise-parameter-binding"></a>Привязка параметра Column-Wise

 В привязке на уровне столбца приложение привязывает отдельные массивы параметров и длин/индикаторов к каждому параметру.  
  
 Чтобы использовать привязку на уровне столбца, приложение сначала устанавливает атрибут SQL_ATTR_PARAM_BIND_TYPE инструкции в значение SQL_PARAM_BIND_BY_COLUMN. (Это значение по умолчанию.) Для каждого столбца, который должен быть привязан, приложение выполняет следующие действия:  
  
1.  Выделяет массив буферов параметров.  
  
2.  Выделяет массив буферов длины или индикатора.  
  
    > [!NOTE]  
    >  Если приложение выполняет запись непосредственно в дескрипторы при использовании привязки на уровне столбца, для данных длины и индикатора можно использовать отдельные массивы.  
  
3.  Вызывает **SQLBindParameter** со следующими аргументами:  
  
    -   *ValueType* — это тип C одного элемента в массиве буферов параметров.  
  
    -   *ParameterType* — это тип SQL параметра.  
  
    -   *Параметервалуептр* — адрес массива буферов параметров.  
  
    -   *BufferLength* — это размер одного элемента в массиве буферов параметров. Аргумент *BufferLength* игнорируется, если данные являются данными фиксированной длины.  
  
    -   *StrLen_or_IndPtr* — это адрес массива длины или индикатора.  
  
 Дополнительные сведения об использовании этих сведений см. в подразделе «аргумент Параметервалуептр» в «комментариях» ниже Дополнительные сведения о привязке параметров на уровне столбца см. в разделе [Привязка массивов параметров](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).  
  
## <a name="row-wise-parameter-binding"></a>Привязка параметра Row-Wise

 В привязке на уровне строки приложение определяет структуру, которая содержит параметры и буферы длины/индикатора для каждого параметра, который должен быть привязан.  
  
 Чтобы использовать привязку на уровне строки, приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения одного набора параметров (включая параметры, буферы длины и индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение выполняет запись непосредственно в дескрипторы при использовании привязки на уровне строки, для данных длины и индикатора можно использовать отдельные поля.  
  
2.  Задает для атрибута SQL_ATTR_PARAM_BIND_TYPE инструкции размер структуры, содержащей один набор параметров, или размер экземпляра буфера, к которому будут привязаны параметры. Длина должна включать пробел для всех привязанных параметров и любое заполнение структуры или буфера, чтобы гарантировать, что при увеличении адреса привязанного параметра на указанную длину результат будет указывать на начало того же параметра в следующей строке. При использовании оператора *sizeof* в ANSI C это поведение гарантировано.  
  
3.  Вызывает **SQLBindParameter** со следующими аргументами для каждого параметра, который должен быть привязан:  
  
    -   *ValueType* — это тип элемента буфера параметра, который должен быть привязан к столбцу.  
  
    -   *ParameterType* — это тип SQL параметра.  
  
    -   *Параметервалуептр* — это адрес элемента буфера параметров в первом элементе массива.  
  
    -   *BufferLength* — размер элемента буфера параметров.  
  
    -   *StrLen_or_IndPtr* — это адрес элемента с длиной или индикатором, который должен быть привязан.  
  
 Дополнительные сведения об использовании этих сведений см. в подразделе «аргумент *параметервалуептр* » далее в этом подразделе. Дополнительные сведения о привязке параметров на уровне строки см. в разделе [массивы привязки параметров](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).  
  
## <a name="error-information"></a>Сведения об ошибке

 Если драйвер не реализует массивы параметров как пакеты (параметр SQL_PARAM_ARRAY_ROW_COUNTS равен SQL_PARC_NO_BATCH), то ситуации ошибки обрабатываются так, как если бы выполнялась одна инструкция. Если драйвер реализует массивы параметров как пакеты, приложение может использовать поле заголовка SQL_DESC_ARRAY_STATUS_PTR IPD для определения того, какой параметр инструкции SQL или какой параметр в массиве параметров привел к возврату ошибки **SQLExecDirect** или **SQLExecute** . Это поле содержит сведения о состоянии для каждой строки значений параметров. Если в поле указано, что произошла ошибка, поля в структуре диагностических данных будут указывать номер строки и параметра для параметра, который завершился ошибкой. Число элементов в массиве определяется полем SQL_DESC_ARRAY_SIZE заголовка в APD, которое может быть задано атрибутом инструкции SQL_ATTR_PARAMSET_SIZE.  
  
> [!NOTE]  
>  Поле заголовка SQL_DESC_ARRAY_STATUS_PTR в APD используется для пропуска параметров. Дополнительные сведения об игнорировании параметров см. в следующем разделе «игнорирование набора параметров».  
  
 Когда **SQLExecute** или **SQLExecDirect** возвращает SQL_ERROR, элементы массива, на которые указывает поле SQL_DESC_ARRAY_STATUS_PTR в IPD, будут содержать SQL_PARAM_ERROR, SQL_PARAM_SUCCESS, SQL_PARAM_SUCCESS_WITH_INFO, SQL_PARAM_UNUSED или SQL_PARAM_DIAG_UNAVAILABLE.  
  
 Для каждого элемента в этом массиве структура диагностических данных содержит одну или несколько записей состояния. В поле SQL_DIAG_ROW_NUMBER структуры указывается номер строки значений параметров, вызвавших ошибку. Если можно определить конкретный параметр в строке параметров, вызвавших ошибку, номер параметра будет указан в поле SQL_DIAG_COLUMN_NUMBER.  
  
 SQL_PARAM_UNUSED введено, если параметр не использовался из-за ошибки в более раннем параметре, который вынужден прервать **SQLExecute** или **SQLExecDirect** . Например, если имеется 50 параметров и произошла ошибка при выполнении фортиес набора параметров, вызвавших прерывание **SQLExecute** или **SQLExecDirect** , то SQL_PARAM_UNUSED в массиве состояний для параметров 41 – 50.  
  
 SQL_PARAM_DIAG_UNAVAILABLE задается, когда драйвер обрабатывает массивы параметров в виде монолитного блока, поэтому он не создает этот индивидуальный уровень параметров сведений об ошибках.  
  
 Некоторые ошибки при обработке одного набора параметров вызывают прекращение обработки последующих наборов параметров в массиве. Другие ошибки не влияют на обработку последующих параметров. Ошибки, которые прекратят обработать, определяются драйвером. Если обработка не остановлена, все параметры в массиве обрабатываются, SQL_SUCCESS_WITH_INFO возвращается в результате ошибки, а буфер, определенный SQL_ATTR_PARAMS_PROCESSED_PTR, задает общее число обработанных параметров (как определено атрибутом инструкции SQL_ATTR_PARAMSET_SIZE), который включает в себя наборы ошибок.  
  
> [!CAUTION]  
>  Поведение ODBC при возникновении ошибки при обработке массива параметров отличается в ODBC 3. *x* , чем в ODBC 2. *x*. В ODBC 2. *x*, функция вернула SQL_ERROR и обработка прекращается. Буфер, на который указывает аргумент *пиров* объекта **SQLParamOptions** , содержал номер строки ошибки. В ODBC 3. *x*, функция возвращает SQL_SUCCESS_WITH_INFO, а обработка может быть прекращена или продолжена. Если он будет продолжен, в буфере, заданном SQL_ATTR_PARAMS_PROCESSED_PTR, будет установлено значение всех обработанных параметров, включая те, которые привели к ошибке. Это изменение в поведении может привести к проблемам с существующими приложениями.  
  
 Когда **SQLExecute** или **SQLExecDirect** возвращает значение до завершения обработки всех наборов параметров в массиве параметров, например при возвращении SQL_ERROR или SQL_NEED_DATA, массив состояния содержит состояния для уже обработанных параметров. Расположение, на которое указывает поле SQL_DESC_ROWS_PROCESSED_PTR в IPD, содержит номер строки в массиве параметров, вызвавший SQL_ERROR или SQL_NEED_DATA код ошибки. При отправке массива параметров в инструкцию SELECT доступность значений массива состояния определяется драйвером. они могут быть доступны после выполнения инструкции или при выборке результирующих наборов.  
  
## <a name="ignoring-a-set-of-parameters"></a>Пропуск набора параметров

 Поле SQL_DESC_ARRAY_STATUS_PTR APD (как задано атрибутом SQL_ATTR_PARAM_STATUS_PTR инструкции) можно использовать, чтобы указать, что набор привязанных параметров в инструкции SQL следует игнорировать. Чтобы указать драйверу игнорировать один или несколько наборов параметров во время выполнения, приложение должно выполнить следующие действия:  
  
1.  Вызовите **SQLSetDescField** , чтобы задать поле заголовка SQL_DESC_ARRAY_STATUS_PTR APD, чтобы оно указывало на массив значений склусмаллинт, содержащих сведения о состоянии. Это поле также может быть задано путем вызова **SQLSetStmtAttr** с *атрибутом* SQL_ATTR_PARAM_OPERATION_PTR, который позволяет приложению устанавливать поле без получения дескриптора дескриптора.  
  
2.  Задайте для каждого элемента массива, определенного SQL_DESC_ARRAY_STATUS_PTR полем APD, одно из двух значений:  
  
    -   SQL_PARAM_IGNORE, чтобы указать, что строка исключена из выполнения инструкции.  
  
    -   SQL_PARAM_PROCEED, чтобы указать, что строка включается в выполнение инструкции.  
  
3.  Вызовите **SQLExecDirect** или **SQLExecute** , чтобы выполнить подготовленную инструкцию.  
  
 К массиву, определяемому полем SQL_DESC_ARRAY_STATUS_PTR APD, применяются следующие правила.  
  
-   По умолчанию указатель имеет значение null.  
  
-   Если указатель имеет значение null, используются все наборы параметров, как если бы для всех элементов было задано значение SQL_ROW_PROCEED.  
  
-   Присвоение элементу значения SQL_PARAM_PROCEED не гарантирует, что операция будет использовать этот конкретный набор параметров.  
  
-   SQL_PARAM_PROCEED определяется как 0 в файле заголовка.  
  
 Приложение может задать SQL_DESC_ARRAY_STATUS_PTR поле в APD, чтобы оно указывало на тот же массив, на который указывает поле SQL_DESC_ARRAY_STATUS_PTR в IRD. Это полезно при привязке параметров к данным строк. Параметры можно игнорировать в соответствии с состоянием данных строки. Кроме SQL_PARAM_IGNORE, следующие коды приводят к игнорированию параметра в инструкции SQL: SQL_ROW_DELETED, SQL_ROW_UPDATED и SQL_ROW_ERROR. Кроме SQL_PARAM_PROCEED, следующие коды приводят к тому, что инструкция SQL будет продолжаться: SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO и SQL_ROW_ADDED.  
  
## <a name="rebinding-parameters"></a>Повторная привязка параметров

 Приложение может выполнить одну из двух операций для изменения привязки:  
  
-   Вызовите **SQLBindParameter** , чтобы указать новую привязку для уже привязанного столбца. Драйвер перезаписывает старую привязку новым.  
  
-   Укажите смещение, которое будет добавлено к буферному адресу, указанному вызовом привязки к **SQLBindParameter**. Дополнительные сведения см. в следующем разделе "повторная привязка с использованием смещений".  
  
## <a name="rebinding-with-offsets"></a>Повторная привязка с использованием смещений

 Повторная привязка параметров особенно полезна, если в приложении имеется настройка буферной области, которая может содержать много параметров, но вызов **SQLExecDirect** или **SQLExecute** использует только несколько параметров. Оставшееся место в буферной области можно использовать для следующего набора параметров путем изменения существующей привязки по смещению.  
  
 Поле заголовка SQL_DESC_BIND_OFFSET_PTR в APD указывает на смещение привязки. Если поле не равно null, драйвер отменяет ссылку на указатель и, если ни одно из значений в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR не является пустым указателем, добавляет значение разыменования в эти поля в записи дескриптора во время выполнения. При выполнении инструкций SQL используются новые значения указателя. Смещение остается действительным после повторной привязки. Поскольку SQL_DESC_BIND_OFFSET_PTR является указателем на смещение, а не само смещение, приложение может изменить смещение напрямую, не требуя вызова [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md) для изменения поля дескриптора. По умолчанию указатель имеет значение null. Поле SQL_DESC_BIND_OFFSET_PTR АРД может быть задано вызовом [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или вызовом [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)с *фаттрибуте* SQL_ATTR_PARAM_BIND_OFFSET_PTR.  
  
 Смещение привязки всегда добавляется непосредственно к значениям в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется на другое значение, новое значение по-прежнему добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется к сумме значения поля и предшествующим смещениям.  
  
## <a name="descriptors"></a>Дескрипторы

 Привязка параметра определяется полями Апдс и ИПДС. Аргументы в **SQLBindParameter** используются для задания этих полей дескриптора. Поля также могут быть заданы функциями **SQLSetDescField** , хотя **SQLBindParameter** более эффективны, поскольку приложению не нужно получать дескриптор дескриптора для вызова **SQLBindParameter**.  
  
> [!CAUTION]  
>  Вызов **SQLBindParameter** для одного оператора может повлиять на другие инструкции. Это происходит, когда АРД, связанный с инструкцией, явным образом выделяется и также связывается с другими инструкциями. Поскольку **SQLBindParameter** изменяет поля APD, изменения применяются ко всем инструкциям, с которыми связан этот дескриптор. Если это не является необходимым поведением, приложение должно отменить связь этого дескриптора с другими инструкциями перед вызовом **SQLBindParameter**.  
  
 По сути, **SQLBindParameter** выполняет следующие действия последовательно:  
  
1.  Вызывает [SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) для получения маркера APD.  
  
2.  Вызывает [SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md) , чтобы получить поле SQL_DESC_COUNT APD, и если значение аргумента *ColumnNumber* превышает значение SQL_DESC_COUNT, вызывает **SQLSetDescField** , чтобы увеличить значение SQL_DESC_COUNT до *columnNumber*.  
  
3.  Вызывает [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) несколько раз, чтобы присвоить значения следующим полям APD:  
  
    -   Устанавливает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE значение *ValueType*, за исключением того, что если *ValueType* является одним из сокращенных идентификаторов подтипа DateTime или Interval, он устанавливает для SQL_DESC_TYPE SQL_DATETIME или SQL_INTERVAL соответственно, устанавливает SQL_DESC_CONCISE_TYPE в сокращенный идентификатор и устанавливает SQL_DESC_DATETIME_INTERVAL_CODE в соответствующий код даты и времени.  
  
    -   Устанавливает поле SQL_DESC_OCTET_LENGTH в значение *BufferLength*.  
  
    -   Устанавливает поле SQL_DESC_DATA_PTR в значение *ParameterValue*.  
  
    -   Задает для поля SQL_DESC_OCTET_LENGTH_PTR значение *StrLen_Or_Ind*.  
  
    -   Задает для поля SQL_DESC_INDICATOR_PTR также значение *StrLen_Or_Ind*.  
  
     Параметр *StrLen_Or_Ind* задает как сведения об индикаторе, так и длину значения параметра.  
  
4.  Вызывает [SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) для получения маркера IPD.  
  
5.  Вызывает [SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md) для получения поля SQL_DESC_COUNT IPD. Если значение аргумента *ColumnNumber* превышает значение SQL_DESC_COUNT, вызывает **SQLSetDescField** , чтобы увеличить значение SQL_DESC_COUNT до *columnNumber*.  
  
6.  Вызывает [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) несколько раз, чтобы присвоить значения следующим полям IPD:  
  
    -   Устанавливает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE значение *ParameterType*, за исключением того, что если *ParameterType* является одним из сокращенных идентификаторов подтипа DateTime или interval, он устанавливает SQL_DESC_TYPE в SQL_DATETIME или SQL_INTERVAL соответственно, устанавливает SQL_DESC_CONCISE_TYPE в сокращенный идентификатор и устанавливает SQL_DESC_DATETIME_INTERVAL_CODE в соответствующий код даты и времени.  
  
    -   Задает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION и SQL_DESC_DATETIME_INTERVAL_PRECISION в соответствии с подходящим для *ParameterType*.  
  
    -   Задает SQL_DESC_SCALE значение *деЦималдигитс*.  
  
 Если вызов **SQLBindParameter** завершается ошибкой, содержимое полей дескриптора, которое было бы задано в APD, не определено, а SQL_DESC_COUNT поле APD не изменяется. Кроме того, поля SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_TYPE соответствующей записи IPD не определены, и поле SQL_DESC_COUNT IPD не изменяется.  
  
## <a name="conversion-of-calls-to-and-from-sqlsetparam"></a>Преобразование вызовов в SQLSetParam и из него

 Когда приложение ODBC 1,0 вызывает **SQLSetParam** в ODBC 3. драйвер *x* , ODBC 3. Диспетчер драйверов *x* сопоставляет вызов, как показано в следующей таблице.  
  
|Вызов приложения ODBC 1,0|Вызов ODBC 3. драйвер *x*|  
|----------------------------------|-------------------------------|  
|SQLSetParam (Статеменсандле, Параметернумбер, ValueType, ParameterType, ЛенгспреЦисион, Параметерскале, Параметервалуептр, StrLen_or_IndPtr);|SQLBindParameter (Статеменсандле, Параметернумбер, SQL_PARAM_INPUT_OUTPUT, ValueType, ParameterType,      *ColumnSize*,      *деЦималдигитс*, параметервалуептр, SQL_SETPARAM_VALUE_MAX, StrLen_or_IndPtr);|  
  
## <a name="examples"></a>Примеры  

### <a name="a-use-sqlbindparameter-function"></a>A. Использование функции SQLBindParameter

 В следующем примере приложение подготавливает инструкцию SQL для вставки данных в таблицу ORDERs. Для каждого параметра в инструкции приложение вызывает **SQLBindParameter** для указания типа данных ODBC C и типа данных SQL параметра, а также для привязки буфера к каждому параметру. Для каждой строки данных приложение назначает значения данных каждому параметру и вызывает **SQLExecute** для выполнения инструкции.  
  
 В следующем примере предполагается, что у вас есть источник данных ODBC на компьютере с именем Northwind, связанный с базой данных Northwind.  
  
 Дополнительные примеры кода см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [Функция SQLProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md), функция [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)и [Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
```cpp
// SQLBindParameter_Function.cpp  
// compile with: ODBC32.lib  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
#define EMPLOYEE_ID_LEN 10  
  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLSMALLINT sCustID;  
  
SQLCHAR szEmployeeID[EMPLOYEE_ID_LEN];  
SQL_DATE_STRUCT dsOrderDate;  
SQLINTEGER cbCustID = 0, cbOrderDate = 0, cbEmployeeID = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, EMPLOYEE_ID_LEN, 0, szEmployeeID, 0, &cbEmployeeID);  
   retcode = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_SSHORT, SQL_INTEGER, 0, 0, &sCustID, 0, &cbCustID);  
   retcode = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TIMESTAMP, sizeof(dsOrderDate), 0, &dsOrderDate, 0, &cbOrderDate);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"INSERT INTO Orders(CustomerID, EmployeeID, OrderDate) VALUES (?, ?, ?)", SQL_NTS);  
  
   strcpy_s((char*)szEmployeeID, _countof(szEmployeeID), "BERGS");  
   sCustID = 5;  
   dsOrderDate.year = 2006;  
   dsOrderDate.month = 3;  
   dsOrderDate.day = 17;  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
### <a name="b-execute-a-stored-procedure-using-a-named-parameter"></a>Б. Выполнение хранимой процедуры с помощью именованного параметра

 В следующем примере приложение выполняет SQL Server хранимую процедуру с помощью именованного параметра.  
  
```cpp
// SQLBindParameter_Function_2.cpp  
// compile with: ODBC32.lib  
// sample assumes the following stored procedure:  
// use northwind  
// DROP PROCEDURE SQLBindParameter  
// GO  
//   
// CREATE PROCEDURE SQLBindParameter @quote int  
// AS  
// delete from orders where OrderID >= @quote  
// GO  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
SQLHDESC hIpd = NULL;  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLCHAR szQuote[50] = "100084";  
SQLINTEGER cbValue = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"{call SQLBindParameter(?)}", SQL_NTS);  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 50, 0, szQuote, 0, &cbValue);  
   retcode = SQLGetStmtAttr(hstmt, SQL_ATTR_IMP_PARAM_DESC, &hIpd, 0, 0);  
   retcode = SQLSetDescField(hIpd, 1, SQL_DESC_NAME, "@quote", SQL_NTS);  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возврат сведений о параметре в операторе|[Функция SQLDescribeParam](../../../odbc/reference/syntax/sqldescribeparam-function.md)|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Освобождение буферов параметров в инструкции|[SQLFreeStmt, функция](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращение количества параметров инструкции|[SQLNumParams, функция](../../../odbc/reference/syntax/sqlnumparams-function.md)|  
|Возврат следующего параметра для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Указание нескольких значений параметров|[Функция SQLParamOptions](../../../odbc/reference/syntax/sqlparamoptions-function.md)|  
|Отправка данных параметров во время выполнения|[SQLPutData, функция](../../../odbc/reference/syntax/sqlputdata-function.md)|  
  
## <a name="see-also"></a>См. также:

 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
