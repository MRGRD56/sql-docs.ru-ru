---
description: Функция SQLFetchScroll
title: Функция SQLFetchScroll | Документация Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLFetchScroll
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLFetchScroll
helpviewer_keywords:
- SQLFetchScroll function [ODBC]
ms.assetid: c0243667-428c-4dda-ae91-3c307616a1ac
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 5cfa442ab1ada0b17e06137257b4d17bf37f854c
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99198540"
---
# <a name="sqlfetchscroll-function"></a>Функция SQLFetchScroll
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 3,0: ISO 92  
  
 **Сводка**  
 **SQLFetchScroll** извлекает указанный набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов. Наборы строк могут быть заданы на абсолютном или относительном месте или по закладке.  
  
 При работе с драйвером ODBC 2. x диспетчер драйверов сопоставляет эту функцию с **SQLExtendedFetch**. Дополнительные сведения см. в разделе [Сопоставление функций замены для обратной совместимости приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLFetchScroll(  
      SQLHSTMT      StatementHandle,  
      SQLSMALLINT   FetchOrientation,  
      SQLLEN        FetchOffset);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *фетчориентатион*  
 Входной  
  
 Тип выборки:  
  
 SQL_FETCH_NEXT  
  
 SQL_FETCH_PRIOR  
  
 SQL_FETCH_FIRST  
  
 SQL_FETCH_LAST  
  
 SQL_FETCH_ABSOLUTE  
  
 SQL_FETCH_RELATIVE  
  
 SQL_FETCH_BOOKMARK  
  
 Дополнительные сведения см. в подразделе «размещение курсора» раздела «комментарии».  
  
 *фетчоффсет*  
 Входной  
  
 Номер извлекаемой строки. Интерпретация этого аргумента зависит от значения аргумента *фетчориентатион* . Дополнительные сведения см. в подразделе «размещение курсора» раздела «комментарии».  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLFetchScroll** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с параметром handletype SQL_HANDLE_STMT и маркером статеменсандле. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLFetchScroll** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное. Если в одном столбце возникает ошибка, **SQLGetDiagField** можно вызвать с диагидентифиер из SQL_DIAG_COLUMN_NUMBER, чтобы определить столбец, в котором произошла ошибка. и **SQLGetDiagField** можно вызывать с диагидентифиер SQL_DIAG_ROW_NUMBER для определения строки, содержащей этот столбец.  
  
 Для всех этих SQLSTATE, которые могут возвращать SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением 01XXX SQLSTATE), SQL_SUCCESS_WITH_INFO возвращается в случае возникновения ошибки в одной или нескольких строках операции многострочные, а SQL_ERROR возвращается в случае возникновения ошибки в операции с одной строкой.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Строковые или двоичные данные, возвращаемые для столбца, привели к усечению непустого символа или двоичных данных, отличных от NULL. Если это строковое значение, оно было усечено по правому краю.|  
|01S01|Ошибка в строке|Произошла ошибка при выборке одной или нескольких строк.<br /><br /> (Если это значение SQLSTATE возвращается, когда приложение ODBC 3 *. x* работает с драйвером ODBC 2 *. x* , его можно игнорировать.)|  
|01S06|Попытка выборки до того, как результирующий набор вернул первый набор строк|Запрошенный набор строк перекрывает начало результирующего набора, когда Фетчориентатион был SQL_FETCH_PRIOR, текущая позиции выходит за пределы первой строки, а номер текущей строки меньше или равен размеру набора строк.<br /><br /> Запрошенный набор строк перекрывается с начала результирующего набора, когда Фетчориентатион был SQL_FETCH_PRIOR, текущая точка находится за пределами результирующего набора, а размер набора строк превысил размер результирующего набора.<br /><br /> Запрошенный набор строк с перекрытием начала результирующего набора, когда Фетчориентатион был SQL_FETCH_RELATIVE, Фетчоффсет был отрицательным, а абсолютное значение Фетчоффсет было меньше или равно размеру набора строк.<br /><br /> Запрошенный набор строк, перекрывающийся с началом результирующего набора, когда Фетчориентатион был SQL_FETCH_ABSOLUTE, Фетчоффсет был отрицательным, а абсолютное значение Фетчоффсет было больше, чем размер результирующего набора, но меньше или равен размеру набора строк.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Усечение дробной части|Данные, возвращаемые для столбца, были усечены. Для числовых типов данных дробная часть числа была усечена. Для типов данных времени, временных меток и интервалов, содержащих компонент времени, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных столбца в результирующем наборе не может быть преобразовано в тип данных, указанный в *TargetType* в **SQLBindCol**.<br /><br /> Столбец 0 был привязан к типу данных SQL_C_BOOKMARK, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS задано значение SQL_UB_VARIABLE.<br /><br /> Столбец 0 был привязан к типу данных SQL_C_VARBOOKMARK, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS не было задано значение SQL_UB_VARIABLE.|  
|07009|Недопустимый индекс дескриптора|Драйвер был драйвером ODBC 2 *. x* , который не поддерживает **SQLExtendedFetch**, а номер столбца, указанный в привязке для столбца, равен 0.<br /><br /> Столбец 0 был привязан, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_OFF.|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|22001|Строковые данные, усеченные справа|Закладка переменной длины, возвращаемая для столбца, усечена.|  
|22002|Требуемая, но не определенная переменная индикатора|Данные NULL были получены в столбец, *StrLen_or_IndPtr* которого задается параметром **SQLBindCol** (или SQL_DESC_INDICATOR_PTR Set by **SQLSetDescField** или **SQLSetDescRec**), является пустым указателем.|  
|22003|Числовое значение вне допустимого диапазона|Возврат числового значения (в виде числового или строкового) для одного или нескольких привязанных столбцов привело бы к усечению всего (в отличие от дробной части) числа.<br /><br /> Дополнительные сведения см. в разделе [Преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в [приложении г: типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22007|Недопустимый формат даты и времени|Символьный столбец в результирующем наборе был привязан к структуре даты, времени или метки времени C, а значение в столбце является, соответственно, недействительной датой, временем или меткой времени.|  
|22012|Деление на ноль|Возвращено значение из арифметического выражения, результатом которого является деление на ноль.|  
|22015|Переполнение поля интервала|Назначение типа SQL с точным числовым или интервалом до типа Interval C привело к утере значащих цифр в начальном поле.<br /><br /> При выборке данных в тип C Interval не было представления значения типа SQL в типе Interval C.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе был привязан к символьному буферу C, а столбец содержал символ, для которого в наборе символов буфера отсутствует представление.<br /><br /> Тип C был точным или приблизительным числовым, типом данных DateTime или интервалом. тип SQL столбца имеет символьный тип данных; и значение в столбце не было допустимым литералом привязанного типа C.|  
|24 000|Недопустимое состояние курсора|*Статеменсандле* был в выполненном состоянии, но с *статеменсандле* не связан ни один результирующий набор.|  
|40001|Сбой сериализации|Транзакция, в которой выполнялась выборка, была прервана во избежание взаимоблокировки.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана, и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *статеменсандле*. Затем функция была вызвана в *статеменсандле*.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLFetchScroll** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) указанный *статеменсандле* не находится в выполненном состоянии. Функция была вызвана без предварительного вызова **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) **SQLFetch** был вызван для *статеменсандле* после того, как был вызван **SQLExtendedFetch** , и перед вызовом **SQLFreeStmt** с параметром SQL_CLOSE.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Атрибуту инструкции SQL_ATTR_USE_BOOKMARK было присвоено значение SQL_UB_VARIABLE, а столбец 0 был привязан к буферу, длина которого не равна максимальной длине закладки для этого результирующего набора. (Эта длина доступна в поле SQL_DESC_OCTET_LENGTH IRD и может быть получено путем вызова **SQLDescribeCol**, **SQLColAttribute** или **SQLGetDescField**.)|  
|HY106|Тип выборки вне допустимого диапазона|DM) значение, указанное для аргумента Фетчориентатион, недопустимо.<br /><br /> (DM) аргумент Фетчориентатион был SQL_FETCH_BOOKMARK, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS задано значение SQL_UB_OFF.<br /><br /> Значение атрибута SQL_ATTR_CURSOR_TYPE оператора было SQL_CURSOR_FORWARD_ONLYо, а значение аргумента Фетчориентатион не SQL_FETCH_NEXT.<br /><br /> Значение атрибута SQL_ATTR_CURSOR_SCROLLABLE оператора было SQL_NONSCROLLABLEо, а значение аргумента Фетчориентатион не SQL_FETCH_NEXT.|  
|HY107|Значение строки вне допустимого диапазона|Значение, указанное в атрибуте оператора SQL_ATTR_CURSOR_TYPE, было SQL_CURSOR_KEYSET_DRIVENо, но значение, указанное в атрибуте инструкции SQL_ATTR_KEYSET_SIZE, было больше 0 и меньше значения, указанного в атрибуте инструкции SQL_ATTR_ROW_ARRAY_SIZE.|  
|HY111|Недопустимое значение закладки|Аргумент Фетчориентатион был SQL_FETCH_BOOKMARK, а закладка, на которую указывает значение в атрибуте инструкции SQL_ATTR_FETCH_BOOKMARK_PTR, недопустима или является пустым указателем.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает преобразование, заданное сочетанием *TargetType* в **SQLBindCol** и типом данных SQL соответствующего столбца.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул запрошенный результирующий набор. Период ожидания задается через SQLSetStmtAttr, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 **SQLFetchScroll** Возвращает указанный набор строк из результирующего набора. Наборы строк можно задавать с помощью абсолютного или относительного положения или закладки. **SQLFetchScroll** можно вызывать только во время существования результирующего набора, то есть после вызова, создающего результирующий набор и до закрытия курсора над этим результирующим набором. Если какие бы то ни было столбцы связаны, они возвращают данные в этих столбцах. Если приложение указало указатель на массив состояний строк или буфер, в котором возвращается число извлекаемых строк, **SQLFetchScroll** также возвращает эти сведения. Вызовы **SQLFetchScroll** можно смешивать с вызовами **SQLFetch** , но не могут смешиваться с вызовами **SQLExtendedFetch**.  
  
 Дополнительные сведения см. [в разделе Использование блочных курсоров](../../../odbc/reference/develop-app/using-block-cursors.md) и [Использование прокручиваемых курсоров](../../../odbc/reference/develop-app/using-scrollable-cursors.md).  
  
## <a name="positioning-the-cursor"></a>Размещение курсора  
 При создании результирующего набора курсор располагается перед началом результирующего набора. **SQLFetchScroll** размещает курсор на блоке на основе значений аргументов *фетчориентатион* и *фетчоффсет* , как показано в следующей таблице. Точные правила определения начала нового набора строк показаны в следующем разделе.  
  
|фетчориентатион|Значение|  
|----------------------|-------------|  
|SQL_FETCH_NEXT|Возврат следующего набора строк. Это эквивалентно вызову **SQLFetch**.<br /><br /> **SQLFetchScroll** игнорирует значение *фетчоффсет*.|  
|SQL_FETCH_PRIOR|Возврат к предыдущему набору строк.<br /><br /> **SQLFetchScroll** игнорирует значение *фетчоффсет*.|  
|SQL_FETCH_RELATIVE|Возврат набора строк, *фетчоффсет* с начала текущего набора строк.|  
|SQL_FETCH_ABSOLUTE|Возврат набора строк, начиная со строки *фетчоффсет*.|  
|SQL_FETCH_FIRST|Возврат первого набора строк в результирующем наборе.<br /><br /> **SQLFetchScroll** игнорирует значение *фетчоффсет*.|  
|SQL_FETCH_LAST|Возврат последнего полного набора строк в результирующем наборе.<br /><br /> **SQLFetchScroll** игнорирует значение *фетчоффсет*.|  
|SQL_FETCH_BOOKMARK|Возврат набора строк Фетчоффсет строки из закладки, заданной атрибутом инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
  
 Для поддержки всех ориентаций выборки драйверы не требуются. приложение вызывает **SQLGetInfo** с типом сведений SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 (в зависимости от типа курсора), чтобы определить, какие ориентации выборки поддерживаются драйвером. В этих типах сведений приложение должно просматривать битовую маску SQL_CA1_NEXT, SQL_CA1_RELATIVE, SQL_CA1_ABSOLUTE и WQL_CA1_BOOKMARK. Более того, если курсор является однонаправленным и Фетчориентатион не SQL_FETCH_NEXT, **SQLFetchScroll** ВОЗВРАЩАЕТ SQLSTATE HY106 (тип выборки за пределами диапазона).  
  
 Атрибут инструкции SQL_ATTR_ROW_ARRAY_SIZE указывает количество строк в наборе строк. Если набор строк, который извлекается с помощью **SQLFetchScroll** , пересекается с концом результирующего набора, **SQLFetchScroll** возвращает частичный набор строк. То есть, если S + R-1 больше, чем L, где S — Начальная строка извлекаемого набора строк, R — это размер набора строк, а L — Последняя строка в результирующем наборе, то допустимы только первые L-S + 1 строки набора строк. Оставшиеся строки пусты и имеют состояние SQL_ROW_NOROW.  
  
 После возврата **SQLFetchScroll** текущая строка является первой строкой набора строк.  
  
## <a name="cursor-positioning-rules"></a>Правила позиционирования курсора  
 В следующих разделах описаны точные правила для каждого значения Фетчориентатион. Эти правила используют следующую нотацию.  
  
|Notation|Значение|  
|--------------|-------------|  
|*Перед началом работы*|Курсор блока располагается перед началом результирующего набора. Если первая строка нового набора строк находится перед началом результирующего набора, **SQLFetchScroll** возвращает SQL_NO_DATA.|  
|*После окончания*|Курсор блока располагается после конца результирующего набора. Если первая строка нового набора строк находится после конца результирующего набора, **SQLFetchScroll** возвращает SQL_NO_DATA.|  
|*куррровсетстарт*|Номер первой строки в текущем наборе строк.|  
|*ластресултров*|Номер последней строки в результирующем наборе.|  
|*ровсетсизе*|Размер набора строк.|  
|*фетчоффсет*|Значение аргумента *фетчоффсет* .|  
|*букмаркров*|Строка, соответствующая закладке, заданной атрибутом SQL_ATTR_FETCH_BOOKMARK_PTR Statement.|  
  
## <a name="sql_fetch_next"></a>SQL_FETCH_NEXT  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*Перед началом работы*|1|  
|*Куррровсетстарт + ровсетсизе*[1] *\< = ластресултров*|*Куррровсетстарт + ровсетсизе*[1]|  
|*Куррровсетстарт + ровсетсизе*[1]*> ластресултров*|*После окончания*|  
|*После окончания*|*После окончания*|  
  
 [1] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это размер набора строк, который использовался в предыдущем вызове.  
  
## <a name="sql_fetch_prior"></a>SQL_FETCH_PRIOR  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*Перед началом работы*|*Перед началом работы*|  
|*Куррровсетстарт = 1*|*Перед началом работы*|  
|*1 < куррровсетстарт <= ровсетсизе* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*Куррровсетстарт > ровсетсизе* <sup>[2]</sup>|*Куррровсетстарт-ровсетсизе* <sup>[2]</sup>|  
|*После End and ластресултров < ровсетсизе* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*После завершения и ластресултров >= ровсетсизе* <sup>[2]</sup>|*Ластресултров-ровсетсизе + 1* <sup>[2]</sup>|  
  
 [1]   **SQLFetchScroll** ВОЗВРАЩАЕТ значение SQLSTATE 01S06 (попытка выборки до того, как результирующий набор вернул первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [2] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
## <a name="sql_fetch_relative"></a>SQL_FETCH_RELATIVE  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*(Перед началом и Фетчоффсет > 0) ИЛИ (после завершения и Фетчоффсет < 0)*|*--*<sup>[1]</sup>|  
|*Бефорестарт и Фетчоффсет <= 0*|*Перед началом работы*|  
|*Куррровсетстарт = 1 и Фетчоффсет < 0*|*Перед началом работы*|  
|*Куррровсетстарт > 1 и куррровсетстарт + фетчоффсет < 1 и &#124; фетчоффсет &#124; > ровсетсизе* <sup>[3]</sup>|*Перед началом работы*|  
|*Куррровсетстарт > 1 и куррровсетстарт + фетчоффсет < 1 и &#124; фетчоффсет &#124; <= ровсетсизе* <sup>[3]</sup> .|*1* <sup>[2]</sup>|  
|*1 <= Куррровсетстарт + Фетчоффсет \< = ластресултров*|*Куррровсетстарт + Фетчоффсет*|  
|*Куррровсетстарт + Фетчоффсет > Ластресултров*|*После окончания*|  
|*После End и Фетчоффсет >= 0*|*После окончания*|  
  
 [1] ***SQLFetchScroll** _ возвращает тот же набор строк, что и при вызове с фетчориентатион, для которого задано значение SQL_FETCH_ABSOLUTE. Дополнительные сведения см. в разделе "SQL_FETCH_ABSOLUTE".  
  
 [2] _ *SQLFetchScroll** ВОЗВРАЩАЕТ значение SQLSTATE 01S06 (попытка получить, прежде чем результирующий набор вернул первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [3] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
## <a name="sql_fetch_absolute"></a>SQL_FETCH_ABSOLUTE  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*Фетчоффсет < 0 и &#124; Фетчоффсет &#124; <= Ластресултров*|*Ластресултров + Фетчоффсет + 1*|  
|*Фетчоффсет < 0 и &#124; фетчоффсет &#124; > ЛАСТРЕСУЛТРОВ и &#124; фетчоффсет &#124; > ровсетсизе* <sup>[2]</sup>|*Перед началом работы*|  
|*Фетчоффсет < 0 и &#124; фетчоффсет &#124; > ЛАСТРЕСУЛТРОВ и &#124; фетчоффсет &#124; <= ровсетсизе* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*Фетчоффсет = 0*|*Перед началом работы*|  
|*1 <= Фетчоффсет \< = ластресултров*|*фетчоффсет*|  
|*Фетчоффсет > Ластресултров*|*После окончания*|  
  
 [1]   **SQLFetchScroll** ВОЗВРАЩАЕТ значение SQLSTATE 01S06 (попытка выборки до того, как результирующий набор вернул первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [2] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
 Абсолютная выборка, выполненная для динамического курсора, не может предоставить необходимый результат, так как позиции строк в динамическом курсоре не определены. Такая операция эквивалентна первой выборке, за которой следует относительная выборка. Это не атомарная операция, как и абсолютная выборка для статического курсора.  
  
## <a name="sql_fetch_first"></a>SQL_FETCH_FIRST  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*Любые*|*1*|  
  
## <a name="sql_fetch_last"></a>SQL_FETCH_LAST  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*Ровсетсизе* <sup>[1]</sup> <= ластресултров|*Ластресултров-ровсетсизе + 1* <sup>[1]</sup>|  
|*Ровсетсизе* <sup>[1]</sup> > ластресултров|*1*|  
  
 [1] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
## <a name="sql_fetch_bookmark"></a>SQL_FETCH_BOOKMARK  
 Применяются следующие правила.  
  
|Условие|Первая строка нового набора строк|  
|---------------|-----------------------------|  
|*Букмаркров + Фетчоффсет < 1*|*Перед началом работы*|  
|*1 <= Букмаркров + Фетчоффсет \< = ластресултров*|*Букмаркров + Фетчоффсет*|  
|*Букмаркров + Фетчоффсет > Ластресултров*|*После окончания*|  
  
 Дополнительные сведения о закладках см. в разделе [закладки (ODBC)](../../../odbc/reference/develop-app/bookmarks-odbc.md).  
  
## <a name="effect-of-deleted-added-and-error-rows-on-cursor-movement"></a>Воздействие удаленных, добавленных и ошибочных строк при перемещении курсора  
 Статические и управляемые набором ключей курсоры иногда определяют строки, добавленные в результирующий набор, и удаляют строки, удаленные из результирующего набора. Вызывая **SQLGetInfo** с параметрами SQL_STATIC_CURSOR_ATTRIBUTES2 и SQL_KEYSET_CURSOR_ATTRIBUTES2 и просматривая битовую маску SQL_CA2_SENSITIVITY_ADDITIONS, SQL_CA2_SENSITIVITY_DELETIONS и SQL_CA2_SENSITIVITY_UPDATES, приложение определяет, выполняют ли они курсоры, реализованные определенным драйвером. Для драйверов, которые могут обнаруживать удаленные строки и удалять их, в следующих параграфах описываются последствия такого поведения. Для драйверов, которые могут обнаруживать удаленные строки, но не могут их удалять, удаления не влияют на перемещение курсора, и следующие абзацы не применяются.  
  
 Если курсор обнаруживает строки, добавленные в результирующий набор, или удаляет строки, удаленные из результирующего набора, он будет выглядеть так, как если бы они выбирали эти изменения только при выборе данных. Это включает случай, когда **SQLFetchScroll** вызывается с параметром фетчориентатион, для которого задано значение SQL_FETCH_RELATIVE, а фетчоффсет имеет значение 0 для повторной выборки того же набора строк, но не включает случай, когда функция SQLSetPos вызывается с параметром параметром fOption SQL_REFRESH. В последнем случае данные в буферах наборов строк обновляются, но не изменяются повторно, а удаленные строки не удаляются из результирующего набора. Таким словами, при удалении или вставке строки в текущий набор строк курсор не изменяет буферы набора строк. Вместо этого он обнаруживает изменение при выборке любого набора строк, который ранее включал в себя удаленную строку, или теперь включает вставленную строку.  
  
 Например:  
  
```cpp  
// Fetch the next rowset.  
SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);  
// Delete third row of the rowset. Does not modify the rowset buffers.  
SQLSetPos(hstmt, 3, SQL_DELETE, SQL_LOCK_NO_CHANGE);  
// The third row has a status of SQL_ROW_DELETED after this call.  
SQLSetPos(hstmt, 3, SQL_REFRESH, SQL_LOCK_NO_CHANGE);  
// Refetch the same rowset. The third row is removed, replaced by what  
// was previously the fourth row.  
SQLFetchScroll(hstmt, SQL_FETCH_RELATIVE, 0);  
```  
  
 Когда **SQLFetchScroll** возвращает новый набор строк с позицией относительно текущего набора строк, то есть фетчориентатион имеет SQL_FETCH_NEXT, SQL_FETCH_PRIOR или SQL_FETCH_RELATIVE-он не включает изменения в текущий набор строк при вычислении начальной координаты нового набора строк. Однако он включает изменения вне текущего набора строк, если он способен обнаруживать их. Более того, когда **SQLFetchScroll** возвращает новый набор строк, который имеет независимую от текущего набора строк, то есть фетчориентатион SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE или SQL_FETCH_BOOKMARK-он включает все изменения, которые он способен обнаружить, даже если они находятся в текущем наборе строк.  
  
 При определении того, находятся ли добавленные строки внутри или вне текущего набора строк, считается, что частичный набор строк находится в конце последней допустимой строки. то есть последняя строка, для которой состояние строки не SQL_ROW_NOROW. Например, предположим, что курсор способен обнаруживать только что добавленные строки, текущий набор строк является частичным набором строк, приложение добавляет новые строки, а курсор добавляет эти строки в конец результирующего набора. Если приложение вызывает **SQLFetchScroll** с фетчориентатион, для которого задано значение SQL_FETCH_NEXT, **SQLFetchScroll** возвращает набор строк, начиная с первой вновь добавленной строки.  
  
 Например, предположим, что текущий набор строк состоит из строк от 21 до 30, размер набора строк равен 10, курсор удаляет строки, удаленные из результирующего набора, и курсор обнаруживает строки, добавленные в результирующий набор. В следующей таблице показаны строки, возвращаемые **SQLFetchScroll** в различных ситуациях.  
  
|Change|Тип выборки|фетчоффсет|Новый набор строк [1]|  
|------------|----------------|-----------------|---------------------|  
|Удалить строку 21|NEXT|0|от 31 до 40|  
|Удалить строку 31|NEXT|0|от 32 до 41|  
|Вставить строку между строками 21 и 22|NEXT|0|от 31 до 40|  
|Вставить строку между строками 30 и 31|NEXT|0|Вставленная строка, 31 – 39|  
|Удалить строку 21|PRIOR|0|от 11 до 20|  
|Удалить строку 20|PRIOR|0|от 10 до 19|  
|Вставить строку между строками 21 и 22|PRIOR|0|от 11 до 20|  
|Вставить строку между строками 20 и 21|PRIOR|0|от 12 до 20 вставленных строк|  
|Удалить строку 21|RELATIVE|0|от 22 до 31<sup>[2]</sup>|  
|Удалить строку 21|RELATIVE|1|от 22 до 31|  
|Вставить строку между строками 21 и 22|RELATIVE|0|21, вставленная строка, 22 – 29|  
|Вставить строку между строками 21 и 22|RELATIVE|1|от 22 до 31|  
|Удалить строку 21|ABSOLUTE|21|от 22 до 31<sup>[2]</sup>|  
|Удалить строку 22|ABSOLUTE|21|21, 23 – 31|  
|Вставить строку между строками 21 и 22|ABSOLUTE|22|Вставленная строка, 22 – 29|  
  
 [1] в этом столбце используются номера строк до вставки или удаления строк.  
  
 [2] в этом случае курсор пытается вернуть строки, начинающиеся со строки 21. Поскольку строка 21 была удалена, первая строка, которую она возвращает, — строка 22.  
  
 Строки ошибок (т. е. строки с состоянием SQL_ROW_ERROR) не влияют на перемещение курсора. Например, если текущий набор строк начинается со строки 11, а состояние строки 11 — SQL_ROW_ERROR, вызов **SQLFetchScroll** с фетчориентатион, для которого задано значение SQL_FETCH_RELATIVE и фетчоффсет значение 5, возвращает набор строк, начинающийся со строки 16, точно так же, как если бы для строки 11 было установлено состояние SQL_SUCCESS.  
  
## <a name="returning-data-in-bound-columns"></a>Возврат данных в связанных столбцах  
 **SQLFetchScroll** возвращает данные в связанных столбцах так же, как **SQLFetch**. Дополнительные сведения см. в разделе "возвращение данных в связанных столбцах" в [функции SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
 Если столбцы не привязаны, **SQLFetchScroll** не возвращает данные, но перемещает блочный курсор в указанную позицию. Могут ли данные извлекаться из непривязанных столбцов блочного курсора с **SQLGetData** зависит от драйвера. Эта возможность поддерживается, если вызов **SQLGetInfo** возвращает бит SQL_GD_BLOCK для SQL_GETDATA_EXTENSIONSного типа данных.  
  
## <a name="buffer-addresses"></a>Буферные адреса  
 **SQLFetchScroll** использует ту же формулу для определения адреса данных и буферов длины или индикатора как **SQLFetch**. Дополнительные сведения см. в разделе "буферные адреса" в [функции SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
## <a name="row-status-array"></a>Массив статусов строк  
 **SQLFetchScroll** задает значения в массиве состояний строк так же, как SQLFetch. Дополнительные сведения см. в разделе "массив состояний строк" в [функции SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="rows-fetched-buffer"></a>Буфер выборки строк  
 **SQLFetchScroll** возвращает количество строк, выбранных в буфере, которые выбирались так же, как **SQLFetch**. Дополнительные сведения см. в разделе «строки, получающие буфер» в [функции SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="error-handling"></a>Обработка ошибок  
 Когда приложение вызывает **SQLFetchScroll** в драйвере ODBC 3. x, диспетчер драйверов вызывает **SQLFetchScroll** в драйвере. Когда приложение вызывает **SQLFetchScroll** в драйвере ODBC 2. x, диспетчер драйверов вызывает SQLExtendedFetch в драйвере. Так как **SQLFetchScroll** и SQLExtendedFetch обрабатывали ошибки немного иным образом, приложение видит слегка отличающееся поведение ошибки при вызове **SQLFetchScroll** в драйверах ODBC 2. x и ODBC 3. x.  
  
 **SQLFetchScroll** возвращает ошибки и предупреждения так же, как **SQLFetch**; Дополнительные сведения см. в разделе «Обработка ошибок» в **SQLFetch**. **SQLExtendedFetch** возвращает ошибки так же, как **SQLFetch**, за исключением следующих:  
  
 При возникновении предупреждения, которое относится к определенной строке в наборе строк, SQLExtendedFetch присваивает соответствующей записи в массиве состояния строки значение SQL_ROW_SUCCESS, а не SQL_ROW_SUCCESS_WITH_INFO.  
  
 Если ошибки возникают в каждой строке в наборе строк, SQLExtendedFetch возвращает SQL_SUCCESS_WITH_INFO, а не SQL_ERROR.  
  
 В каждой группе записей состояния, которая применяется к отдельной строке, первая запись состояния, возвращаемая функцией SQLExtendedFetch, должна содержать SQLSTATE 01S01 (ошибка в строке). **SQLFetchScroll** не ВОЗВРАЩАЕТ это SQLSTATE. Если SQLExtendedFetch не может вернуть дополнительные SQLSTATE, он по-прежнему должен возвращать значение SQLSTATE.  
  
## <a name="sqlfetchscroll-and-optimistic-concurrency"></a>SQLFetchScroll и оптимистичный параллелизм  
 Если курсор использует оптимистичный параллелизм, то есть атрибут SQL_ATTR_CONCURRENCY оператора имеет значение SQL_CONCUR_VALUES или SQL_CONCUR_ROWVER- **SQLFetchScroll** обновляет значения оптимистичного параллелизма, используемые источником данных для обнаружения изменений в строке. Это происходит каждый раз, когда **SQLFetchScroll** извлекает новый набор строк, включая время повторной выборки текущего набора строк. (Он вызывается с параметром Фетчориентатион, для которого задано значение SQL_FETCH_RELATIVE, а Фетчоффсет — 0.)  
  
## <a name="sqlfetchscroll-and-odbc-2x-drivers"></a>Драйверы SQLFetchScroll и ODBC 2. x  
 Когда приложение вызывает **SQLFetchScroll** в драйвере ODBC 2. x, диспетчер драйверов сопоставляет этот вызов с **SQLExtendedFetch**. Он передает следующие значения для аргументов **SQLExtendedFetch**.  
  
|SQLExtendedFetch, аргумент|Значение|  
|-------------------------------|-----------|  
|статеменсандле|Статеменсандле в **SQLFetchScroll**.|  
|фетчориентатион|Фетчориентатион в **SQLFetchScroll**.|  
|фетчоффсет|Если Фетчориентатион не SQL_FETCH_BOOKMARK, используется значение аргумента Фетчоффсет в **SQLFetchScroll** .<br /><br /> Если Фетчориентатион имеет SQL_FETCH_BOOKMARK, то используется значение, хранящееся в адресе, указанном атрибутом инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
|RowCountPtr|Адрес, указанный в атрибуте оператора SQL_ATTR_ROWS_FETCHED_PTR.|  
|ровстатусаррай|Адрес, указанный в атрибуте оператора SQL_ATTR_ROW_STATUS_PTR.|  
  
 Дополнительные сведения см. в разделе [блочные курсоры, прокручиваемые курсоры и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: рекомендации по драйверам для обеспечения обратной совместимости.  
  
## <a name="descriptors-and-sqlfetchscroll"></a>Дескрипторы и SQLFetchScroll  
 **SQLFetchScroll** взаимодействует с дескрипторами так же, как **SQLFetch**. Дополнительные сведения см. в разделе "дескрипторы и SQLFetchScroll" в [функции SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="code-example"></a>Пример кода  
 См. [статью привязка на уровне столбца](../../../odbc/reference/develop-app/column-wise-binding.md), [Привязка по строкам](../../../odbc/reference/develop-app/row-wise-binding.md), [позиционированные обновления и инструкции DELETE](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md), а [также обновление строк в наборе строк с помощью функции SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение операций с массовыми операциями вставки, обновления и удаления|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующем наборе|[SQLDescribeCol, функция](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка одной строки или блока данных в прямом направлении|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Закрытие курсора в операторе|[SQLFreeStmt, функция](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращение количества столбцов результирующего набора|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Размещение курсора, обновление данных в наборе строк, обновление или удаление данных в результирующем наборе|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|Задание атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
