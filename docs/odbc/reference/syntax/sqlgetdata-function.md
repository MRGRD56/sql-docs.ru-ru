---
description: Функция SQLGetData
title: Функция SQLGetData | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLGetData
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetData
helpviewer_keywords:
- SQLGetData function [ODBC]
ms.assetid: e3c1356a-5db7-4186-85fd-8b74633317e8
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 42b81d50a83fef0be7c13604902cfe67b2d2dd89
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99201972"
---
# <a name="sqlgetdata-function"></a>Функция SQLGetData
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLGetData** извлекает данные для одного столбца в результирующем наборе или для одного параметра после того, как **метод SQLParamData** возвращает SQL_PARAM_DATA_AVAILABLE. Его можно вызывать несколько раз для получения данных переменной длины в частях.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetData(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   Col_or_Param_Num,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_IndPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *Col_or_Param_Num*  
 Входной Для получения данных столбца это номер столбца, для которого возвращаются данные. Столбцы результирующего набора нумеруются в порядке возрастания порядка столбцов, начиная с 1. Столбец закладки имеет номер столбца 0; Это можно указать, только если закладки включены.  
  
 Для получения данных параметра это порядковый номер параметра, который начинается с 1.  
  
 *TargetType*  
 Входной Идентификатор типа данных C для буфера **таржетвалуептр* . Список допустимых типов данных C и идентификаторов типов см. в разделе [типы данных c](../../../odbc/reference/appendixes/c-data-types.md) в приложении г: типы данных.  
  
 Если *TargetType* SQL_ARD_TYPE, драйвер использует идентификатор типа, указанный в поле SQL_DESC_CONCISE_TYPE объекта АРД. Если *TargetType* имеет SQL_APD_TYPE, **SQLGetData** будет использовать тот же тип данных C, который был указан в **SQLBindParameter**. В противном случае тип данных C, указанный в **SQLGetData** , переопределяет тип данных c, указанный в **SQLBindParameter**. Если это SQL_C_DEFAULT, драйвер выбирает тип данных C по умолчанию, основанный на типе данных SQL источника.  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *таржетвалуептр*  
 Проверки Указатель на буфер, в который возвращаются данные.  
  
 *Таржетвалуептр* не может иметь значение null.  
  
 *BufferLength*  
 Входной Длина буфера **таржетвалуептр* в байтах.  
  
 Драйвер использует *BufferLength* , чтобы избежать записи после конца \* буфера *таржетвалуептр* при возврате данных переменной длины, таких как символьные или двоичные данные. Обратите внимание, что драйвер подсчитывает символ завершения null при возврате символьных данных в \* *таржетвалуептр*. *Таким образом, *таржетвалуептр* должен содержать пробел для завершающего символа null, или драйвер будет усекать данные.  
  
 Когда драйвер возвращает данные фиксированной длины, такие как целое число или структура даты, драйвер игнорирует *BufferLength* и считает, что буфер достаточно велик для хранения данных. Поэтому важно, чтобы приложение выделило большой буфер для данных фиксированной длины, иначе драйвер запишет после конца буфера.  
  
 **SQLGetData** ВОЗВРАЩАЕТ значение SQLSTATE HY090 (Недопустимая строка или длина буфера), если *BufferLength* меньше 0, но не если *BufferLength* равно 0.  
  
 *StrLen_or_IndPtr*  
 Проверки Указатель на буфер, в который возвращается длина или значение индикатора. Если это пустой указатель, значение длины или индикатора не возвращается. Это возвращает ошибку, если извлекаемые данные имеют значение NULL.  
  
 **SQLGetData** может возвращать следующие значения в буфере длины или индикатора:  
  
-   Длина возвращаемых данных  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Дополнительные сведения см. в разделе [Использование значений length/индикаторов](../../../odbc/reference/develop-app/using-length-and-indicator-values.md) и комментариев в этой статье.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLGetData** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLGetData** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Не все данные для указанного столбца *Col_or_Param_Num* могут быть получены в одном вызове функции. SQL_NO_TOTAL или длина данных, остающихся в указанном столбце до текущего вызова **SQLGetData** , возвращается в \* *StrLen_or_IndPtr*. (Функция возвращает SQL_SUCCESS_WITH_INFO.)<br /><br /> Дополнительные сведения об использовании нескольких вызовов **SQLGetData** для одного столбца см. в разделе "Комментарии".|  
|01S07|Усечение дробной части|Данные, возвращаемые для одного или нескольких столбцов, были усечены. Для числовых типов данных дробная часть числа была усечена. Для типов данных времени, временных меток и интервалов, содержащих компонент времени, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных столбца в результирующем наборе не может быть преобразовано в тип данных C, указанный в аргументе *TargetType*.|  
|07009|Недопустимый индекс дескриптора|Значение, заданное для аргумента *Col_or_Param_Num* , равно 0, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS задано SQL_UB_OFF.<br /><br /> Значение, указанное для аргумента, *Col_or_Param_Num* было больше числа столбцов в результирующем наборе.<br /><br /> Значение *Col_or_Param_Num* не равно порядковому номеру доступного параметра.<br /><br /> (DM) указанный столбец был привязан. Это описание не применяется к драйверам, которые возвращают битовую маску SQL_GD_BOUND для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) номер указанного столбца меньше или равен числу наибольшего связанного столбца. Это описание не применяется к драйверам, которые возвращают битовую маску SQL_GD_ANY_COLUMN для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) приложение уже вызвало **SQLGetData** для текущей строки; номер столбца, указанного в текущем вызове, меньше, чем номер столбца, указанного в предыдущем вызове; и драйвер не возвращает битовую маску SQL_GD_ANY_ORDER для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) аргумент *TargetType* был SQL_ARD_TYPE, а запись дескриптора *Col_or_Param_Num* в АРД не прошла проверку согласованности.<br /><br /> (DM) аргумент *TargetType* был SQL_ARD_TYPE, а значение в поле SQL_DESC_COUNT АРД было меньше, чем аргумент *Col_or_Param_Num* .|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|22002|Требуемая, но не определенная переменная индикатора|*StrLen_or_IndPtr* был пустым указателем, и извлечены данные null.|  
|22003|Числовое значение вне допустимого диапазона|Возврат числового значения (в виде числового или строкового) для столбца привело бы к усечению всего числа (в отличие от дробной части).<br /><br /> Дополнительные сведения см. в разделе [Приложение D. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22007|Недопустимый формат даты и времени|Столбец символов в результирующем наборе был привязан к структуре даты, времени или метки времени C, а значение в столбце имеет недопустимую дату, время или отметку времени соответственно. Дополнительные сведения см. в разделе [Приложение D. типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22012|Деление на ноль|Возвращено значение из арифметического выражения, результатом которого является деление на ноль.|  
|22015|Переполнение поля интервала|Назначение типа SQL с точным числовым или интервалом до типа Interval C привело к утере значащих цифр в начальном поле.<br /><br /> При возврате данных в тип C "Interval" не было представления значения типа SQL в типе "Interval C".|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе был возвращен в символьный буфер C, а столбец содержал символ, для которого не было представления в кодировке буфера.<br /><br /> Тип C был точным или приблизительным числовым, типом данных DateTime или интервалом. тип SQL столбца имеет символьный тип данных; и значение в столбце не было допустимым литералом привязанного типа C.|  
|24 000|Недопустимое состояние курсора|(DM) функция была вызвана без предварительного вызова **SQLFetch** или **SQLFetchScroll** для позиционирования курсора в строке данных, которая необходима.<br /><br /> (DM) *статеменсандле* находится в выполненном состоянии, но с *статеменсандле* не связан ни один результирующий набор.<br /><br /> Курсор был открыт в *статеменсандле* , **SQLFetch** или **SQLFetchScroll** был вызван, но курсор был помещен перед началом результирующего набора или после конца результирующего набора.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003|Тип программы вне допустимого диапазона|(DM) аргумент *TargetType* не является допустимым типом данных, SQL_C_DEFAULT, SQL_ARD_TYPE (в случае получения данных столбца) или SQL_APD_TYPE (в случае получения данных параметра).<br /><br /> (DM) аргумент *Col_or_Param_Num* равен 0, а параметр *TargetType* не SQL_C_BOOKMARK для закладки фиксированной длины или SQL_C_VARBOOKMARK для закладки переменной длины.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *Статеменсандле*, а затем в *статеменсандле* был вызвана функция.<br /><br /> Функция была вызвана, и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения, а затем в *статеменсандле* был вызвана функция.|  
|HY009|Недопустимое использование пустого указателя|(DM) аргумент *таржетвалуептр* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) указанный *статеменсандле* не находится в выполненном состоянии. Функция была вызвана без предварительного вызова **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLGetData** .<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) *статеменсандле* находится в выполненном состоянии, но с *статеменсандле* не связан ни один результирующий набор.<br /><br /> Вызов **склексецеуте**, **SQLExecDirect** или **SQLMoreResults** вернул SQL_PARAM_DATA_AVAILABLE, но был вызван **SQLGetData** , а не **метод SQLParamData**.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное для аргумента *BufferLength* , было меньше 0.<br /><br /> Значение аргумента *BufferLength* меньше 4, аргументу *Col_or_Param_Num* присвоено значение 0, а драйвер — драйвер ODBC 2 *. x* .|  
|HY109|Недопустимое расположение курсора|Курсор был помещен (by **SQLSetPos**, **SQLFetch**, **SQLFetchScroll** или **SQLBulkOperations**) в строку, которая была удалена или не может быть получена.<br /><br /> Курсор был однонаправленным курсором, а размер набора строк был больше единицы.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает использование **SQLGetData** с несколькими строками в **SQLFetchScroll**. Это описание не применяется к драйверам, которые возвращают битовую маску SQL_GD_BLOCK для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> Драйвер или источник данных не поддерживает преобразование, заданное сочетанием аргумента *TargetType* и типом данных SQL соответствующего столбца. Эта ошибка применяется только в том случае, если тип данных SQL столбца был сопоставлен с типом данных SQL конкретного драйвера.<br /><br /> Драйвер поддерживает только ODBC 2 *. x*, а аргумент *TargetType* является одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любые типы данных интервала C, перечисленные в разделе [типы данных c](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: типы данных.<br /><br /> Драйвер поддерживает только версии ODBC до 3,50, а аргумент *TargetType* был SQL_C_GUID.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, соответствующий *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 **SQLGetData** возвращает данные в указанном столбце. **SQLGetData** можно вызвать только после того, как одна или несколько строк были получены из результирующего набора **SQLFetch**, **SQLFetchScroll** или **SQLExtendedFetch**. Если данные переменной длины слишком велики для возвращения в одном вызове **SQLGetData** (из-за ограничения в приложении), **SQLGetData** может извлечь его в части. Можно привязать некоторые столбцы в строке и вызвать **SQLGetData** для других, хотя это зависит от некоторых ограничений. Дополнительные сведения см. в разделе [Получение длинных данных](../../../odbc/reference/develop-app/getting-long-data.md).  
  
 Сведения об использовании **SQLGetData** с потоковыми выходными параметрами см. в разделе [получение выходных параметров с помощью SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="using-sqlgetdata"></a>Использование SQLGetData  
 Если драйвер не поддерживает расширения для **SQLGetData**, функция может возвращать данные только для несвязанных столбцов с числом больше, чем у последнего связанного столбца. Кроме того, в строке данных значение аргумента *Col_or_Param_Num* в каждом вызове **SQLGetData** должно быть больше или равно значению *Col_or_Param_Num* в предыдущем вызове. то есть данные необходимо извлечь в порядке возрастания номеров столбцов. Наконец, если расширения не поддерживаются, **SQLGetData** не может быть вызван, если размер набора строк больше 1.  
  
 Драйверы могут ослабить любые из этих ограничений. Чтобы определить ограничения, которые раскладываются драйвером, приложение вызывает **SQLGetInfo** с любым из следующих вариантов SQL_GETDATA_EXTENSIONS:  
  
-   Для возврата значений выходных параметров можно вызвать SQL_GD_OUTPUT_PARAMS = **SQLGetData** . Дополнительные сведения см. в разделе [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_GD_ANY_COLUMN. Если возвращается этот параметр, **SQLGetData** может быть вызван для любого несвязанного столбца, включая те, которые предшествуют последнему привязанному столбцу.  
  
-   SQL_GD_ANY_ORDER. Если возвращается этот параметр, **SQLGetData** может быть вызван для несвязанных столбцов в любом порядке.  
  
-   SQL_GD_BLOCK. Если этот параметр возвращается функцией **SQLGetInfo** для SQL_GETDATA_EXTENSIONS инфотипе, драйвер поддерживает вызовы **SQLGetData** , если размер набора строк больше 1, а приложение может вызвать функцию **SQLSetPos** с параметром SQL_POSITION, чтобы поместить курсор в нужную строку перед вызовом **SQLGetData.**  
  
-   SQL_GD_BOUND. Если возвращается этот параметр, **SQLGetData** может вызываться для связанных столбцов, а также для несвязанных столбцов.  
  
 Существует два исключения из этих ограничений и возможность их рассмягчить. Во-первых, **SQLGetData** не следует вызывать для однонаправленного курсора, если размер набора строк больше 1. Во-вторых, если драйвер поддерживает закладки, он всегда должен поддерживать возможность вызова **SQLGetData** для столбца 0, даже если он не позволяет приложениям вызывать **SQLGetData** для других столбцов до последнего связанного столбца. (Когда приложение работает с ODBC 2 *. драйвер x* , **SQLGetData** будет успешно возвращать закладку при вызове с *Col_or_Param_Num* равным 0 после вызова **SQLFetch**, так как **SQLFetch** сопоставлен диспетчером драйверов ODBC 3 *. x* **SQLExtendedFetch** с *фетчориентатион* SQL_FETCH_NEXT, а **SQLGetData** с *Col_or_Param_Num* 0 сопоставлен диспетчером драйверов ODBC 3 *. x* **SQLGetStmtOption** с *параметром fOption* SQL_GET_BOOKMARK.)  
  
 **SQLGetData** не может использоваться для получения закладки для строки, только что вставленной путем вызова **SQLBulkOperations** с параметром SQL_ADD, так как курсор не находится в строке. Приложение может получить закладку для такой строки путем привязки столбца 0 перед вызовом **SQLBulkOperations** с SQL_ADD, в этом случае **SQLBulkOperations** возвращает закладку в связанном буфере. Затем **SQLFetchScroll** можно вызвать с SQL_FETCH_BOOKMARK, чтобы переместить курсор в эту строку.  
  
 Если аргумент *TargetType* является типом данных Interval, то значение интервала по умолчанию (2) и значение интервала в секундах (6), заданное в полях SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION АРД, соответственно, используются для данных. Если аргумент *TargetType* имеет тип данных SQL_C_NUMERIC, точность по умолчанию (определяется драйвером) и масштаб по умолчанию (0), как задано в полях SQL_DESC_PRECISION и SQL_DESC_SCALE АРД, используются для данных. Если какая-либо точность или масштаб по умолчанию не подходит, приложение должно явно задать соответствующее поле дескриптора, вызвав метод **SQLSetDescField** или **SQLSetDescRec**. Он может задать для поля SQL_DESC_CONCISE_TYPE значение SQL_C_NUMERIC и вызвать **SQLGetData** с помощью аргумента *TargetType* SQL_ARD_TYPE, что приведет к тому, что значения точности и масштаба в полях дескриптора будут использоваться.  
  
> [!NOTE]
>  В ODBC 2 *. x* приложения устанавливают для *TargetType* значение SQL_C_DATE, SQL_C_TIME или SQL_C_TIMESTAMP, чтобы указать, что \* *таржетвалуептр* — это структура даты, времени или метки времени. В ODBC 3 *. x* приложения устанавливают для *TargetType* значение SQL_C_TYPE_DATE, SQL_C_TYPE_TIME или SQL_C_TYPE_TIMESTAMP. При необходимости диспетчер драйверов выполняет соответствующие сопоставления в зависимости от версии приложения и драйвера.  
  
## <a name="retrieving-variable-length-data-in-parts"></a>Извлечение Variable-Length данных в частях  
 **SQLGetData** можно использовать для получения данных из столбца, содержащего данные переменной длины в частях, то есть если идентификатором типа данных SQL столбца является SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_WCHAR, SQL_WVARCHAR, SQL_WLONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY или идентификатор конкретного драйвера для типа переменной длины.  
  
 Для получения данных из столбца в частях приложение вызывает **SQLGetData** несколько раз подряд для одного и того же столбца. При каждом вызове **SQLGetData** возвращает следующую часть данных. Приложение может повторно собрать части, что позаботится об удалении символа завершения со значением NULL из промежуточных частей символьных данных. При наличии большего числа возвращаемых данных или недостаточного размера буфера, выделенного для завершающего символа, **SQLGetData** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004 (усечение данных). Когда возвращается последняя часть данных, **SQLGetData** возвращает SQL_SUCCESS. В последнем допустимом вызове для получения данных из столбца не могут возвращаться ни SQL_NO_TOTAL, ни ноль, так как приложение не сможет понять, какая часть данных в буфере приложения является допустимой. Если после этого вызывается **SQLGetData** , возвращается SQL_NO_DATA. Дополнительные сведения см. в следующем разделе "получение данных с помощью SQLGetData".  
  
 Закладки переменной длины могут возвращаться в частях по **SQLGetData**. Как и в случае с другими данными, вызов **SQLGetData** для возвращения закладок с переменной длиной в частях будет возвращать SQLSTATE 01004 (строковые данные, усеченные справа) и SQL_SUCCESS_WITH_INFO при наличии большего числа возвращаемых данных. Это отличается от случая, когда закладка переменной длины усекается вызовом **SQLFetch** или **SQLFetchScroll**, который возвращает SQL_ERROR и SQLSTATE 22001 (строковые данные, усеченные справа).  
  
 **SQLGetData** нельзя использовать для возвращения данных фиксированной длины в частях. Если **SQLGetData** вызывается более одного раза в строке для столбца, содержащего данные фиксированной длины, он возвращает SQL_NO_DATA для всех вызовов после первого.  
  
## <a name="retrieving-streamed-output-parameters"></a>Получение потоковых выходных параметров  
 Если драйвер поддерживает потоковые выходные параметры, приложение может многократно вызывать **SQLGetData** с небольшим буфером для получения большого значения параметра. Дополнительные сведения о потоковых параметрах вывода см. в разделе [получение выходных параметров с помощью SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="retrieving-data-with-sqlgetdata"></a>Получение данных с помощью SQLGetData  
 Чтобы получить данные для указанного столбца, **SQLGetData** выполняет следующую последовательность действий.  
  
1.  Возвращает SQL_NO_DATA, если он уже вернул все данные для столбца.  
  
2.  Задает \* *StrLen_or_IndPtr* для SQL_NULL_DATA, если данные имеют значение null. Если данные имеют значение NULL, а *StrLen_or_IndPtr* был пустым указателем, **SQLGetData** возвращает SQLSTATE 22002 (требуется, но не указана переменная индикатора).  
  
     Если данные для столбца не равны NULL, **SQLGetData** переходит к шагу 3.  
  
3.  Если для атрибута SQL_ATTR_MAX_LENGTH инструкции задано ненулевое значение, если столбец содержит символьные или двоичные данные, а если для столбца не был вызван **SQLGetData** , данные усекаются до SQL_ATTR_MAX_LENGTH байтов.  
  
    > [!NOTE]  
    >  Атрибут инструкции SQL_ATTR_MAX_LENGTH предназначен для уменьшения сетевого трафика. Обычно он реализуется с помощью источника данных, который усекает данные перед их возвратом по сети. Драйверы и источники данных не обязательно должны поддерживать их. Таким образом, чтобы гарантировать усечение данных до определенного размера, приложение должно выделить буфер этого размера и указать размер в аргументе *BufferLength* .  
  
4.  Преобразует данные в тип, указанный в *TargetType*. Данные получают точность и масштаб по умолчанию для этого типа данных. Если *TargetType* имеет SQL_ARD_TYPE, используется тип данных в поле SQL_DESC_CONCISE_TYPE АРД. Если *TargetType* имеет SQL_ARD_TYPE, то данные получают точность и масштаб в полях SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION и SQL_DESC_SCALE АРД в зависимости от типа данных в поле SQL_DESC_CONCISE_TYPE. Если какая-либо точность или масштаб по умолчанию не подходит, приложение должно явно задать соответствующее поле дескриптора, вызвав метод **SQLSetDescField** или **SQLSetDescRec**.  
  
5.  Если данные были преобразованы в тип данных переменной длины, например символьный или двоичный, **SQLGetData** проверяет, превышает ли длина данных длину *BufferLength*. Если длина символьных данных (включая завершающий символ null) превышает *BufferLength*, **SQLGetData** усекает данные до *BufferLength* меньше длины символа завершения, равного null. Затем значение NULL завершает данные. Если длина двоичных данных превышает длину буфера данных, **SQLGetData** усекает его до *BufferLength* байт.  
  
     Если указанный буфер данных слишком мал для хранения символа завершения, **SQLGetData** возвращает значение SQL_SUCCESS_WITH_INFO и SQLSTATE 01004.  
  
     **SQLGetData** никогда не усекает данные, преобразованные в типы данных фиксированной длины; всегда предполагается, что длина **таржетвалуептр* равна размеру типа данных.  
  
6.  Помещает преобразованные (и, возможно, усеченные) данные в \* *таржетвалуептр*. Обратите внимание, что **SQLGetData** не может вернуть данные из строки.  
  
7.  Помещает в \* *StrLen_or_IndPtr* длину данных. Если *StrLen_or_IndPtr* был пустым указателем, **SQLGetData** не возвращает длину.  
  
    -   Для символьных или двоичных данных это длина данных после преобразования и до усечения из-за *BufferLength*. Если драйвер не может определить длину данных после преобразования, как это иногда бывает в случае с длинными данными, он возвращает SQL_SUCCESS_WITH_INFO и задает длину SQL_NO_TOTAL. (Последний вызов **SQLGetData** должен всегда возвращать длину данных, а не ноль или SQL_NO_TOTAL). Если данные были усечены из-за атрибута SQL_ATTR_MAX_LENGTH оператора, значение этого атрибута, в отличие от фактической длины, помещается в \* *StrLen_or_IndPtr*. Это обусловлено тем, что этот атрибут предназначен для усечения данных на сервере перед преобразованием, поэтому драйвер не может определить фактическую длину. Когда **SQLGetData** вызывается несколько раз подряд для одного и того же столбца, это длина данных, доступных в начале текущего вызова. Это значит, что длина уменьшается при каждом последующем вызове.  
  
    -   Для всех других типов данных это длина данных после преобразования. то есть это размер типа, в который были преобразованы данные.  
  
8.  Если данные усекаются без потери значимости во время преобразования (например, вещественное число 1,234 усекается при преобразовании в целое число 1) или из-за слишком маленького *BufferLength* (например, строка «abcdef» помещается в 4-байтовый буфер), **SQLGetData** возвращает SQLSTATE 01004 (данные усекаются) и SQL_SUCCESS_WITH_INFO. Если данные усекаются без потери значимости из-за атрибута SQL_ATTR_MAX_LENGTH инструкции, **SQLGetData** возвращает SQL_SUCCESS и не возвращает SQLSTATE 01004 (усечение данных).  
  
 Содержимое связанного буфера данных (если **SQLGetData** вызывается в связанном столбце), а буфер длины и индикатора не определен, если **SQLGetData** не возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Последовательные вызовы **SQLGetData** будут получать данные из последнего запрошенного столбца; предыдущие смещения становятся недействительными. Например, при выполнении следующей последовательности:  
  
```cpp  
SQLGetData(icol=n), SQLGetData(icol=m), SQLGetData(icol=n)  
```  
  
 второй вызов SQLGetData (icol = n) извлекает данные с начала столбца n. Любое смещение данных из-за предыдущих вызовов **SQLGetData** для столбца больше не является допустимым.  
  
## <a name="descriptors-and-sqlgetdata"></a>Дескрипторы и SQLGetData  
 **SQLGetData** не взаимодействует напрямую с какими бы то ни было полями дескрипторов.  
  
 Если *TargetType* имеет SQL_ARD_TYPE, используется тип данных в поле SQL_DESC_CONCISE_TYPE АРД. Если *TargetType* либо SQL_ARD_TYPE, либо SQL_C_DEFAULT, то данные получают точность и масштаб в полях SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION и SQL_DESC_SCALE в зависимости от типа данных в поле SQL_DESC_CONCISE_TYPE.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет инструкцию **SELECT** для возврата результирующего набора идентификаторов клиентов, имен и номеров телефонов, отсортированных по имени, идентификатору и номеру телефона. Для каждой строки данных он вызывает **SQLFetch** , чтобы поместить курсор в следующую строку. Он вызывает **SQLGetData** для получения извлеченных данных; буферы для данных и возвращенное число байтов указываются в вызове **SQLGetData**. Наконец, он выводит имя, идентификатор и номер телефона каждого сотрудника.  
  
```cpp  
#define NAME_LEN 50  
#define PHONE_LEN 50  
  
SQLCHAR      szName[NAME_LEN], szPhone[PHONE_LEN];  
SQLINTEGER   sCustID, cbName, cbAge, cbBirthday;  
SQLRETURN    retcode;  
SQLHSTMT     hstmt;  
  
retcode = SQLExecDirect(hstmt,  
   "SELECT CUSTID, NAME, PHONE FROM CUSTOMERS ORDER BY 2, 1, 3",  
   SQL_NTS);  
  
if (retcode == SQL_SUCCESS) {  
   while (TRUE) {  
      retcode = SQLFetch(hstmt);  
      if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO) {  
         show_error();  
      }  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO){  
  
         /* Get data for columns 1, 2, and 3 */  
  
         SQLGetData(hstmt, 1, SQL_C_ULONG, &sCustID, 0, &cbCustID);  
         SQLGetData(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &cbName);  
         SQLGetData(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN,  
            &cbPhone);  
  
         /* Print the row of data */  
  
         fprintf(out, "%-5d %-*s %*s", sCustID, NAME_LEN-1, szName,   
            PHONE_LEN-1, szPhone);  
      } else {  
         break;  
      }  
   }  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Назначение хранилища для столбца в результирующем наборе|[SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение массовых операций, не связанных с блочным положением курсора|[SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Исполнение инструкции SQL|[SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Выборка одной строки данных или блока данных в прямом направлении|[SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Отправка данных параметров во время выполнения|[SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Размещение курсора, обновление данных в наборе строк, обновление или удаление данных в наборе строк|[функция SQLSetPos;](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
