---
description: Функция SQLExecute
title: Функция SQLExecute | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLExecute
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExecute
helpviewer_keywords:
- SQLExecute function [ODBC]
ms.assetid: 9286a01d-cde2-4b90-af94-9fd7f8da48bf
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 52fadf8de2ca9d5ec0f669dd46cd9dfdfe7ac7aa
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99179876"
---
# <a name="sqlexecute-function"></a>Функция SQLExecute
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLExecute** выполняет подготовленную инструкцию, используя текущие значения переменных маркера параметра, если в инструкции существуют маркеры параметров.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExecute(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, SQL_NO_DATA, SQL_INVALID_HANDLE или SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLExecute** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLExecute** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01001|Конфликт операций с курсором|Подготовленная инструкция, связанная с *статеменсандле* , содержит инструкцию позиционированного обновления или удаления, и ни одна строка, ни несколько строк не были обновлены или удалены. (Дополнительные сведения об обновлениях более чем в одной строке см. в описании *атрибута* SQL_ATTR_SIMULATE_CURSOR в **SQLSetStmtAttr**.)<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01003|Значение NULL исключено в функции Set|Подготовленная инструкция, связанная с *статеменсандле* , содержала функцию Set (например, **AVG**, **Max**, **min** и т. д.), но не функцию набора **Count** , а значения аргументов null были удалены до применения функции. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Строковые или двоичные данные, возвращаемые для выходного параметра, привели к усечению непустого символа или двоичных данных, отличных от NULL. Если это строковое значение, оно было усечено по правому краю. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01006|Привилегия не отменена|Подготовленная инструкция, связанная с *статеменсандле* , была инструкцией **REVOKE** , а пользователь не имеет указанных прав. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01007|Привилегия не предоставлена|Подготовленная инструкция, связанная с *статеменсандле* , была инструкцией **Grant** , и пользователю не удалось предоставить указанные права доступа.|  
|01S02|Значение параметра изменено|Указанный атрибут инструкции был недопустимым из-за рабочих условий реализации, поэтому было временно заменено аналогичное значение. (**SQLGetStmtAttr** можно вызвать, чтобы определить, что такое временно заменяющий параметр.) Заменяющее значение допустимо для *статеменсандле* до тех пор, пока курсор не будет закрыт, после чего атрибут инструкции вернется к предыдущему значению. Атрибуты инструкции, которые могут быть изменены: SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_KEYSET_SIZE, SQL_ATTR_MAX_LENGTH, SQL_ATTR_MAX_ROWS, SQL_ATTR_QUERY_TIMEOUT и SQL_ATTR_SIMULATE_CURSOR. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Усечение дробной части|Данные, возвращаемые для входного или выходного или выходного параметра, были усечены таким, что дробная часть числового типа данных была усечена, или дробная часть временного компонента времени, отметки времени или типа данных интервала была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07002|Неверное поле количества|Число параметров, указанных в **SQLBindParameter** , меньше числа параметров в инструкции SQL, содержащейся в \* *статементтекст*.<br /><br /> **SQLBindParameter** был вызван с *параметервалуептр* , для которого задан пустой указатель, *StrLen_or_IndPtr* не задано значение SQL_NULL_DATA или SQL_DATA_AT_EXEC, а *инпутаутпуттипе* не задано значение SQL_PARAM_OUTPUT, чтобы число параметров, указанное в **SQLBindParameter** , было больше числа параметров в инструкции SQL, содержащейся в **статементтекст*.|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных, определяемое аргументом *ValueType* в **SQLBindParameter** для привязанного параметра, не может быть преобразовано в тип данных, определяемый аргументом *ParameterType* в **SQLBindParameter**.<br /><br /> Значение данных, возвращаемое для параметра, привязанного как SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, не может быть преобразовано в тип данных, определяемый аргументом *ValueType* в **SQLBindParameter**.<br /><br /> (Если не удалось преобразовать значения данных для одной или нескольких строк, но одна или несколько строк были успешно возвращены, эта функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07007|Нарушение значения ограниченного параметра|Тип параметра SQL_PARAM_INPUT_OUTPUT_STREAM используется только для параметра, который отправляет и получает данные в частях. Для этого типа параметра не допускается использование присоединенного буфера ввода.<br /><br /> Эта ошибка возникает, если тип параметра — SQL_PARAM_INPUT_OUTPUT, а \* *StrLen_or_IndPtr* , указанный в **SQLBindParameter** , не равен SQL_NULL_DATA, SQL_DEFAULT_PARAM, SQL_LEN_DATA_AT_EXEC (len) или SQL_DATA_AT_EXEC.|  
|07S01|Недопустимое использование параметра по умолчанию|Значение параметра, заданное с помощью **SQLBindParameter**, было SQL_DEFAULT_PARAM, а соответствующий параметр не является параметром для вызова канонической процедуры ODBC.|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|Подготовленная инструкция, связанная с *статеменсандле* , содержала инструкцию **Create View** , а неквалифицированный список столбцов (количество столбцов, указанных для представления в аргументах *идентификатора столбца* инструкции SQL) содержит больше имен, чем число столбцов в производной таблице, ОПРЕДЕЛЕННОЕ аргументом *спецификации запроса* инструкции SQL.|  
|22001|Строковые данные, усечение справа|Присвоение символьного или двоичного значения столбцу привело к усечению непустых (символов) или не пустых (двоичных) символов или байтов.|  
|22002|Требуемая, но не определенная переменная индикатора|Данные NULL были привязаны к выходному параметру, *StrLen_or_IndPtr* , установленный **SQLBindParameter** , был пустым указателем.|  
|22003|Числовое значение вне допустимого диапазона|Подготовленная инструкция, связанная с *статеменсандле* , содержала привязанный числовой параметр, а значение параметра привело к усечению всего (в отличие от дробного) части числа, которая будет обрезана при присваивании соответствующему столбцу таблицы.<br /><br /> Возврат числового значения (в виде числового или строкового) для одного или нескольких входных, выходных или выходных параметров приведет к усечению всего числа (в отличие от дробной части).|  
|22007|Недопустимый формат даты и времени|Подготовленная инструкция, связанная с *статеменсандле* , содержала инструкцию SQL, содержащую структуру даты, времени или метки времени в качестве привязанного параметра, а параметр, соответственно, имеет недопустимую дату, время или отметку времени.<br /><br /> Входной/выходной или выходной параметр привязан к структуре даты, времени или метки времени C, а значение в возвращенном параметре было соответственно недействительной дате, времени или метке времени. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22008|Переполнение поля даты и времени|Подготовленная инструкция, связанная с *статеменсандле* , содержит инструкцию SQL, содержащую выражение DateTime, которое при вычислении привело к недопустимой структуре даты, времени или метки времени.<br /><br /> Выражение DateTime, вычисленное для входного/выходного или выходного параметра, привело к недопустимой структуре даты, времени или метки времени C.|  
|22012|Деление на ноль|Подготовленная инструкция, связанная с *статеменсандле* , содержит арифметическое выражение, вызвавшее деление на ноль.<br /><br /> Арифметическое выражение, вычисленное для входного/выходного или выходного параметра, привело к делению на нуль.|  
|22015|Переполнение поля интервала|*\* Статементтекст* содержал точный числовой параметр или интервал, который при преобразовании в тип данных SQL Interval привел к утрате значащих цифр.<br /><br /> *\* Статементтекст* содержал параметр интервала с более чем одним полем, которое при преобразовании в числовой тип данных столбца не имело представления числового типа данных.<br /><br /> *\* Статементтекст* содержал данные параметров, которые были назначены типу SQL Interval, и в типе SQL Interval не было представления значения типа C.<br /><br /> Назначение входного, выходного или выходного параметра, который был точным числовым или интервалом типа SQL, к типу Interval C привел к утрате значащих цифр.<br /><br /> Если входной/выходной или выходной параметр был назначен структуре интервала C, в структуре данных интервала отсутствовало представления данных.|  
|22018|Недопустимое символьное значение для спецификации приведения|*\* Статементтекст* содержал тип C, который был точным или приблизительным числовым, типом данных DateTime или значением интервала; тип SQL столбца был символьным типом данных, а значение в столбце не является допустимым литералом привязанного типа C.<br /><br /> При возвращении входного/выходного или выходного параметра тип SQL был точным или приблизительным числовым значением типа DateTime или типом данных интервала; Тип C — SQL_C_CHAR; и значение в столбце не было допустимым литералом привязанного типа SQL.|  
|22019|Недопустимый escape-символ|Подготовленная инструкция, связанная с *статеменсандле* , содержала предикат **Like** с **escape** -символом в предложении **WHERE** , а длина escape-символа после **escape** -последовательности не равна 1.|  
|22025|Недопустимая escape-последовательность|Подготовленная инструкция, связанная с *статеменсандле* , содержит символ " **escape** - _escape-последовательность_ _значений шаблона_ **" в** предложении **WHERE** , а символ, следующий за escape-символом в значении шаблона, не является одним из "%" или "_".|  
|23000|Нарушение ограничения целостности|Подготовленная инструкция, связанная с *статеменсандле* , содержит параметр. Значение параметра имело значение NULL для столбца, определенного как NOT NULL в связанном столбце таблицы, было указано повторяющееся значение для столбца, ограничение которого должно содержать только уникальные значения, или нарушено какое-либо другое ограничение целостности.|  
|24 000|Недопустимое состояние курсора|Курсор был помещен в *статеменсандле* by **SQLFetch** или **SQLFetchScroll**. Эта ошибка возвращается диспетчером драйверов, если **SQLFetch** или **SQLFetchScroll** не вернул SQL_NO_DATA, и возвращается драйвером, если **SQLFetch** или **SQLFetchScroll** вернул SQL_NO_DATA.<br /><br /> Курсор был открыт в *статеменсандле*.<br /><br /> Подготовленная инструкция, связанная с *статеменсандле* , содержала позиционированное обновление или удаление статемен, t, и курсор был помещен перед началом результирующего набора или после конца результирующего набора.|  
|40001|Сбой сериализации|Произошел откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|42000|Синтаксическая ошибка или нарушение прав доступа|У пользователя нет разрешения на выполнение подготовленной инструкции, связанной с *статеменсандле*.|  
|44000|Нарушение параметра WITH CHECK OPTION|Подготовленная инструкция, связанная с *статеменсандле* , содержала инструкцию **INSERT** , выполненную в просматриваемой таблице, или таблицу, производную от просматриваемой таблицы, которая была создана с помощью **параметра WITH CHECK**, так что одна или несколько строк, затронутых инструкцией **INSERT** , больше не будут присутствовать в просматриваемой таблице.<br /><br /> Подготовленная инструкция, связанная с *статеменсандле* , содержала инструкцию **Update** , выполненную в просматриваемой таблице, или таблицу, производную от просматриваемой таблицы, которая была создана с помощью **параметра WITH CHECK**, так что одна или несколько строк, затронутых инструкцией **Update** , больше не будут присутствовать в просматриваемой таблице.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана, и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *статеменсандле*. Затем функция была вызвана в *статеменсандле*.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLExecute** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) *статеменсандле* не был подготовлен.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Значение параметра, заданное с помощью **SQLBindParameter**, является пустым указателем, а значение длины параметра не равно 0, SQL_NULL_DATA, SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение параметра, заданное с помощью **SQLBindParameter**, не является пустым указателем; тип данных C — SQL_C_BINARY или SQL_C_CHAR; и значение длины параметра было меньше 0, но не было SQL_NTS, SQL_NULL_DATA, SQL_DEFAULT_PARAM или SQL_DATA_AT_EXEC или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение длины параметра, связанное с **SQLBindParameter** , было установлено в SQL_DATA_AT_EXEC; тип SQL был либо SQL_LONGVARCHAR, SQL_LONGVARBINARY, либо типом данных типа Long, относящимся к источнику данных. а тип сведений SQL_NEED_LONG_DATA_LEN в **SQLGetInfo** — «Y».|  
|HY105|Недопустимый тип параметра|Значение, указанное для аргумента *инпутаутпуттипе* в **SQLBindParameter** , было SQL_PARAM_OUTPUT, а параметр является входным параметром.|  
|HY109|Недопустимое расположение курсора|Подготовленная инструкция была позиционированной инструкцией UPDATE или DELETE, и курсор был размещен (по **SQLSetPos** или **SQLFetchScroll**) в строке, которая была удалена или не может быть получена.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Сочетание текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживалось драйвером или источником данных.<br /><br /> Атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_VARIABLE, а атрибуту инструкции SQL_ATTR_CURSOR_TYPE задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
 **SQLExecute** может возвращать любое значение SQLSTATE, которое может быть возвращено **SQLPrepare**, в зависимости от того, когда источник данных оценивает инструкцию SQL, связанную с инструкцией.  
  
## <a name="comments"></a>Комментарии  
 **SQLExecute** выполняет инструкцию, подготовленную **SQLPrepare**. После того как приложение обрабатывает или отклоняет результаты из вызова **SQLExecute**, приложение может снова вызвать **SQLExecute** с новыми значениями параметров. Дополнительные сведения о подготовленном выполнении см. в разделе [подготовленное выполнение](../../../odbc/reference/develop-app/prepared-execution-odbc.md).  
  
 Чтобы выполнить инструкцию **SELECT** несколько раз, приложение должно вызвать **SQLCloseCursor** перед повторным выполнением инструкции **SELECT** .  
  
 Если источник данных находится в режиме фиксации вручную (требует явной инициации транзакции) и транзакция еще не запущена, драйвер инициирует транзакцию перед отправкой инструкции SQL. Дополнительные сведения см. в статье о [транзакциях](../../../odbc/reference/develop-app/transactions-odbc.md).  
  
 Если приложение использует **SQLPrepare** для подготовки и **SQLExecute** для отправки инструкций **commit** или **ROLLBACK** , оно не будет взаимодействовать между продуктами СУБД. Чтобы зафиксировать или откатить транзакцию, вызовите **SQLEndTran**.  
  
 Если **SQLExecute** встречает параметр данных при выполнении, он возвращает SQL_NEED_DATA. Приложение отправляет данные с помощью **метод SQLParamData** и **SQLPutData**. См. раздел [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [метод SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)и [Отправка длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
 Если **SQLExecute** выполняет инструкцию обновления, вставки или удаления, которая не влияет ни на какие строки в источнике данных, вызов **SQLExecute** возвращает SQL_NO_DATA.  
  
 Если значение атрибута оператора SQL_ATTR_PARAMSET_SIZE больше 1, а инструкция SQL содержит по крайней мере один маркер параметра, **SQLExecute** выполняет инструкцию SQL один раз для каждого набора значений параметров в массивах, на которые указывает аргумент *\* Параметервалуептр* в вызовах **SQLBindParameter**. Дополнительные сведения см. в разделе [массивы значений параметров](../../../odbc/reference/develop-app/arrays-of-parameter-values.md).  
  
 Если закладки включены и выполняется запрос, который не поддерживает закладки, драйвер должен попытаться привести среду к той, которая поддерживает закладки, изменив значение атрибута и возвращая SQLSTATE 01S02 (значение параметра изменено). Если атрибут не может быть изменен, драйвер должен возвращать значение SQLSTATE HY024 (недопустимое значения атрибута).  
  
> [!NOTE]  
>  При использовании пулов соединений приложение не должно выполнять инструкции SQL, которые изменяют базу данных или контекст базы данных, например инструкцию **use** _Database_ в SQL Server, которая изменяет каталог, используемый источником данных.  
  
## <a name="code-example"></a>Пример кода  
 См. раздел [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Закрытие курсора|[Функция SQLCloseCursor](../../../odbc/reference/syntax/sqlclosecursor-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выборка нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Освобождение маркера инструкции|[SQLFreeStmt, функция](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращение имени курсора|[Функция SQLGetCursorName](../../../odbc/reference/syntax/sqlgetcursorname-function.md)|  
|Выборка части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возврат следующего параметра для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Отправка данных параметров во время выполнения|[SQLPutData, функция](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Задание имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
|Задание атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
