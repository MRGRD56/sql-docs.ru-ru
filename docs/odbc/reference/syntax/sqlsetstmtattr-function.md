---
description: Функция SQLSetStmtAttr
title: Функция SQLSetStmtAttr | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ae590b9ba8a01182f32928f874f0417b554f00a1
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99191765"
---
# <a name="sqlsetstmtattr-function"></a>Функция SQLSetStmtAttr
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 3,0: ISO 92  
  
 **Сводка**  
 **SQLSetStmtAttr** задает атрибуты, связанные с инструкцией.  
  
> [!NOTE]
>  Дополнительные сведения о том, как диспетчер драйверов сопоставляет эту функцию, когда приложение ODBC *3. x* работает с драйвером ODBC *2. x* , см. в разделе [Сопоставление функций замены для обратной совместимости приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *Attribute*  
 Входной Параметр, заданный в списке "Комментарии".  
  
 *ValuePtr*  
 Входной Значение, связываемое с *атрибутом*. В зависимости от значения *атрибута* *ValuePtr* будет иметь одно из следующих значений:  
  
-   Дескриптор ODBC.  
  
-   Значение SQLUINTEGER.  
  
-   Значение SQLULEN.  
  
-   Указатель на один из следующих элементов:  
  
    -   Строка символов, завершающаяся нулем.  
  
    -   Двоичный буфер.  
  
    -   Значение или массив типа SQLLEN, SQLULEN или СКЛУСМАЛЛИНТ.  
  
    -   Определенное драйвером значение.  
  
 Если аргумент *атрибута* является зависящим от драйвера значением, *ValuePtr* может быть целым числом со знаком.  
  
 *StringLength*  
 Входной Если *атрибут Attribute* является атрибутом, ОПРЕДЕЛЯЕМым ODBC, а *ValuePtr* указывает на символьную строку или двоичный буфер, этот аргумент должен иметь длину \* *ValuePtr*. Если *атрибут Attribute* является атрибутом, ОПРЕДЕЛЯЕМым ODBC, а *ValuePtr* — целым числом, *StringLength* игнорируется.  
  
 Если *атрибут* является атрибутом, определяемым драйвером, приложение указывает природу атрибута для диспетчера драйверов, задавая аргумент *StringLength* . *StringLength* могут иметь следующие значения:  
  
-   Если *ValuePtr* является указателем на символьную строку, *StringLength* — это длина строки или SQL_NTS.  
  
-   Если *ValuePtr* является указателем на двоичный буфер, приложение помещает результат макроса SQL_LEN_BINARY_ATTR (*length*) в *StringLength*. Это помещает отрицательное значение в *StringLength*.  
  
-   Если *ValuePtr* является указателем на значение, отличное от символьной строки или двоичной строки, *StringLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение фиксированной длины, то *StringLength* либо SQL_IS_INTEGER, либо SQL_IS_UINTEGER, соответственно.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetStmtAttr** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLSetStmtAttr** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Значение параметра изменено|Драйвер не поддерживал значение, указанное в *ValuePtr*, или значение, указанное в *ValuePtr* , было недопустимым из-за рабочих условий реализации, поэтому драйвер заменяет аналогичное значение. (**SQLGetStmtAttr** можно вызвать, чтобы определить временно заменяющий значение.) Заменяющее значение допустимо для *статеменсандле* до тех пор, пока курсор не будет закрыт, после чего атрибут инструкции вернется к предыдущему значению. Атрибуты инструкции, которые могут быть изменены:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|*Атрибут* был SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR или SQL_ATTR_USE_BOOKMARKS, и курсор был открыт.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере *\* MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY009|Недопустимое использование пустого указателя|Аргумент *атрибута* определил атрибут инструкции, который требовал строкового атрибута, а аргумент *ValuePtr* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLSetStmtAttr** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) была вызвана асинхронно исполняемая функция для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY011|Задать атрибут сейчас невозможно|*Атрибут* был SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR или SQL_ ATTR_USE_BOOKMARKS, и инструкция была подготовлена.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY017|Недопустимое использование автоматически выделенного дескриптора дескриптора|(DM) аргумент *атрибута* был SQL_ATTR_IMP_ROW_DESC или SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) аргумент *атрибута* был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC, а значение в *ValuePtr* было неявно выделенным дескриптором дескриптора, отличным от дескриптора, первоначально выделенного для АРД или APD.|  
|HY024|Недопустимое значение атрибута|При наличии указанного значения *атрибута* в *ValuePtr* было указано недопустимое значение. (Диспетчер драйверов возвращает значение SQLSTATE только для атрибутов соединения и инструкций, принимающих дискретный набор значений, таких как SQL_ATTR_ACCESS_MODE или SQL_ ATTR_ASYNC_ENABLE. Для всех других атрибутов соединения и инструкции драйвер должен проверить значение, указанное в *ValuePtr*.)<br /><br /> Аргумент *атрибута* был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC, а *ValuePtr* — это явно выделенный дескриптор дескриптора, который не находится в том же соединении, что и аргумент *статеменсандле* .|  
|HY090|Недопустимая длина строки или буфера|(DM) *\* ValuePtr* является символьной строкой, а аргумент *StringLength* был меньше 0, но не SQL_NTS.|  
|HY092|Недопустимый идентификатор атрибута или параметра|(DM) значение, указанное для *атрибута* Argument, недопустимо для версии ODBC, поддерживаемой драйвером.<br /><br /> (DM) значение, указанное для *атрибута* Argument, было атрибутом только для чтения.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Значение, заданное для *атрибута* Argument, было допустимым атрибутом инструкции ODBC для версии ODBC, поддерживаемой драйвером, но не поддерживаемой драйвером.<br /><br /> Аргумент *атрибута* был SQL_ATTR_ASYNC_ENABLE, а вызов **SQLGetInfo** с *инфотипе* SQL_ASYNC_MODE возвращает SQL_AM_CONNECTION.<br /><br /> Аргумент *атрибута* был SQL_ATTR_ENABLE_AUTO_IPD, а значение атрибута соединения SQL_ATTR_AUTO_IPD было SQL_FALSE.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|S1118|Драйвер не поддерживает асинхронное уведомление|При вызове **SQLSetStmtAttr** для установки SQL_ATTR_ASYNC_STMT_EVENT; Асинхронное уведомление не поддерживается драйвером.|  
  
## <a name="comments"></a>Комментарии  
 Атрибуты инструкции для инструкции действуют до тех пор, пока они не будут изменены другим вызовом **SQLSetStmtAttr** или до тех пор, пока инструкция не будет удалена вызовом **SQLFreeHandle**. Вызов **SQLFreeStmt** с параметром SQL_CLOSE, SQL_UNBIND или SQL_RESET_PARAMS не сбрасывает атрибуты инструкции.  
  
 Некоторые атрибуты инструкции поддерживают подстановку аналогичного значения, если источник данных не поддерживает значение, указанное в *ValuePtr*. В таких случаях драйвер возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01S02 (значение параметра изменено). Например, если *атрибут* имеет значение SQL_ATTR_CONCURRENCY и *ValuePtr* имеет SQL_CONCUR_ROWVER, и если источник данных не поддерживает это, драйвер подставляет SQL_CONCUR_VALUES и возвращает SQL_SUCCESS_WITH_INFO. Чтобы определить заменяющее значение, приложение вызывает **SQLGetStmtAttr**.  
  
 Формат набора данных с *ValuePtr* зависит от указанного *атрибута*. **SQLSetStmtAttr** принимает данные атрибутов в одном из двух разных форматов: символьной или целочисленной. Формат каждого из них отмечен в описании атрибута. Этот формат применяется к сведениям, возвращаемым для каждого атрибута в **SQLGetStmtAttr**. Символьные строки, на которые указывает аргумент *ValuePtr* параметра **SQLSetStmtAttr** , имеют длину *StringLength*.  
  
> [!NOTE]
>  Возможность установки атрибутов инструкций на уровне соединения путем вызова **SQLSetConnectAttr** является устаревшей в ODBC *3. x*. Приложения ODBC *3. x* никогда не должны задавать атрибуты инструкций на уровне соединения. Атрибуты инструкций ODBC *3. x* не могут быть установлены на уровне соединения, за исключением атрибутов SQL_ATTR_METADATA_ID и SQL_ATTR_ASYNC_ENABLE, которые являются атрибутами соединения и атрибутами инструкции, и могут быть заданы на уровне соединения или инструкции.  
> 
> [!NOTE]
>  Драйверы ODBC *3. x* должны поддерживать эту функцию только в том случае, если они должны работать с приложениями ODBC 2 *. x* , которые задают параметры инструкции ODBC *2. x* на уровне соединения. Дополнительные сведения см. в разделе "Установка параметров инструкции на уровне подключения" раздела [SQLSetConnectOption Mapping](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) в приложении G: рекомендации по драйверу для обеспечения обратной совместимости.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Атрибуты инструкции, устанавливающие поля дескриптора  
 Многие атрибуты инструкции соответствуют полю заголовка дескриптора. Установка этих атрибутов фактически приводит к заданию полей дескриптора. Установка полей с помощью вызова **SQLSetStmtAttr** , а не **SQLSetDescField** , имеет преимущество получения дескриптора дескриптора для вызова функции.  
  
> [!CAUTION]  
>  Вызов **SQLSetStmtAttr** для одного оператора может повлиять на другие инструкции. Это происходит, когда APD или АРД, связанные с инструкцией, явным образом выделены и также связаны с другими инструкциями. Поскольку **SQLSetStmtAttr** изменяет APD или АРД, изменения применяются ко всем инструкциям, с которыми связан этот дескриптор. Если это не является необходимым поведением, приложение должно отменить связь этого дескриптора с другими инструкциями (путем вызова **SQLSetStmtAttr** , чтобы задать SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC поле для другого дескриптора дескриптора) перед повторным вызовом **SQLSetStmtAttr** .  
  
 Если поле дескриптора задано в результате задания соответствующего атрибута инструкции, поле задается только для применимых дескрипторов, которые в настоящее время связаны с инструкцией, определяемой аргументом *статеменсандле* , а параметр атрибута не влияет на дескрипторы, которые могут быть связаны с этой инструкцией в будущем. Если поле дескриптора, которое также является атрибутом инструкции, задается вызовом **SQLSetDescField**, то устанавливается соответствующий атрибут инструкции. Если явно выделенный дескриптор не связан с инструкцией, то атрибут инструкции, соответствующий полю заголовка, вернется к значению поля в неявно выделенном дескрипторе.  
  
 При выделении инструкции (см. [функцию SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)) четыре дескриптора дескриптора автоматически выделяются и связываются с инструкцией. Явно выделенные дескрипторы дескриптора можно связать с инструкцией, вызвав **функцию SQLAllocHandle** с *фхандлетипе* SQL_HANDLE_DESC, чтобы выделить дескриптор дескриптора и затем вызвать **SQLSetStmtAttr** , чтобы связать дескриптор дескриптора с инструкцией.  
  
 Атрибуты инструкции в следующей таблице соответствуют полям заголовка дескриптора.  
  
|Атрибут инструкции|Поле заголовка|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ард|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ард|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ард|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ард|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Атрибуты инструкции  
 В следующей таблице показаны определенные атрибуты и версия ODBC, в которой они были представлены. Ожидается, что драйверы будут определять дополнительные атрибуты, чтобы воспользоваться преимуществами различных источников данных. Диапазон атрибутов зарезервирован ODBC; Разработчики драйверов должны зарезервировать значения для собственного использования драйвера из Open Group. Дополнительные сведения см. в разделе [зависящие от драйвера типы данных, Типы дескрипторов, типы сведений, типы диагностики и атрибуты](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|Содержимое *ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3,0)|Маркер APD для последующих вызовов **SQLExecute** и **SQLExecDirect** на маркере инструкции. Начальное значение этого атрибута является дескриптором, неявно выделенным при первоначальном выделении инструкции. Если этому атрибуту присвоено значение SQL_NULL_DESC или дескриптор, изначально выделенный для дескриптора, то явно выделенный дескриптор APD, который ранее был связан с дескриптором инструкции, отменяется от него, а дескриптор инструкции возвращается к неявному выделенному дескриптору APD.<br /><br /> Этот атрибут не может быть задан дескриптором дескриптора, неявно выделенным для другой инструкции или другим дескриптором, неявно установленным для той же инструкции. неявно выделенные дескрипторы дескриптора не могут быть связаны с более чем одной инструкцией или дескриптором дескриптора.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3,0)|Дескриптор АРД для последующей выборки в дескрипторе инструкции. Начальное значение этого атрибута является дескриптором, неявно выделенным при первоначальном выделении инструкции. Если этому атрибуту присвоено значение SQL_NULL_DESC или дескриптор, изначально выделенный для дескриптора, то явно выделенный дескриптор АРД, который ранее был связан с дескриптором инструкции, отменяется от него, а дескриптор инструкции возвращается к неявному выделенному дескриптору АРД.<br /><br /> Этот атрибут не может быть задан дескриптором дескриптора, неявно выделенным для другой инструкции или другим дескриптором, неявно установленным для той же инструкции. неявно выделенные дескрипторы дескриптора не могут быть связаны с более чем одной инструкцией или дескриптором дескриптора.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1,0)|Значение SQLULEN, указывающее, выполняется ли асинхронное выполнение функции, вызываемой с указанной инструкцией:<br /><br /> SQL_ASYNC_ENABLE_OFF = отключить поддержку асинхронного выполнения на уровне инструкций (по умолчанию).<br /><br /> SQL_ASYNC_ENABLE_ON = включить поддержку асинхронного выполнения на уровне инструкций.<br /><br /> Дополнительные сведения см. в разделе [асинхронное выполнение (метод опроса)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Для драйверов с поддержкой асинхронного выполнения на уровне инструкций атрибут инструкции SQL_ATTR_ASYNC_ENABLE доступен только для чтения. Его значение совпадает со значением атрибута уровня соединения с тем же именем на момент выделения маркера инструкции.<br /><br /> Вызов **SQLSetStmtAttr** для установки SQL_ATTR_ASYNC_ENABLE при возвращении SQL_ASYNC_MODE *инфотипе* SQL_AM_CONNECTION возвращает значение SQLSTATE HYC00 (дополнительная функция не реализована). Дополнительные сведения см. в разделе [функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) .|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3,8)|Значение СКЛПОИНТЕР, которое является обработчиком события.<br /><br /> Уведомление о завершении асинхронных функций включается путем вызова **SQLSetStmtAttr** для установки атрибута **SQL_ATTR_ASYNC_STMT_EVENT** и указания обработчика событий.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3,8)|СКЛПОИНТЕР асинхронной функции обратного вызова.<br /><br /> Только диспетчер драйверов может вызвать функцию **SQLSetStmtAttr** драйвера с этим атрибутом.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3,8)|СКЛПОИНТЕР к структуре контекста<br /><br /> Только диспетчер драйверов может вызвать функцию **SQLSetStmtAttr** драйвера с этим атрибутом.|  
|SQL_ATTR_CONCURRENCY (ODBC 2,0)|Значение SQLULEN, указывающее параллелизм курсора:<br /><br /> SQL_CONCUR_READ_ONLY = курсор доступен только для чтения. Обновления не разрешены.<br /><br /> SQL_CONCUR_LOCK = Cursor использует самый низкий уровень блокировки, достаточный, чтобы гарантировать возможность обновления строки.<br /><br /> SQL_CONCUR_ROWVER = Cursor использует управление оптимистичным параллелизмом, сравнивая версии строк, такие как Склбасе ROWID или Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor использует управление оптимистичным параллелизмом, сравнивая значения.<br /><br /> Значение по умолчанию для SQL_ATTR_CONCURRENCY — SQL_CONCUR_READ_ONLY.<br /><br /> Этот атрибут не может быть указан для открытого курсора. Дополнительные сведения см. в разделе [типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Если *атрибут* SQL_ATTR_CURSOR_TYPE изменен на тип, который не поддерживает текущее значение SQL_ATTR_CONCURRENCY, значение SQL_ATTR_CONCURRENCY будет изменено во время выполнения, а предупреждение выдается при вызове **SQLExecDirect** или **SQLPrepare** .<br /><br /> Если драйвер поддерживает инструкцию **SELECT для Update** и такая инструкция выполняется, когда для параметра SQL_ATTR_CONCURRENCY задано значение SQL_CONCUR_READ_ONLY, то возвращается ошибка. Если значение SQL_ATTR_CONCURRENCY изменено на значение, поддерживаемое драйвером для некоторого значения SQL_ATTR_CURSOR_TYPE но не для текущего значения SQL_ATTR_CURSOR_TYPE, значение SQL_ATTR_CURSOR_TYPE будет изменено во время выполнения, а значение SQLSTATE 01S02 (изменение значения параметра) выдается при вызове **SQLExecDirect** или **SQLPrepare** .<br /><br /> Если указанный параллелизм не поддерживается источником данных, драйвер заменяет другой параллелизм и возвращает значение SQLSTATE 01S02 (изменение значения параметра). Для SQL_CONCUR_VALUES драйвер подставляет SQL_CONCUR_ROWVER и наоборот. Для SQL_CONCUR_LOCK драйвер подставляет, по порядку, SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Допустимость заменяемого значения не проверяется до времени выполнения.<br /><br /> Дополнительные сведения о связи между SQL_ATTR_CONCURRENCY и другими атрибутами курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3,0)|Значение SQLULEN, указывающее уровень поддержки, требуемый приложению. Установка этого атрибута влияет на последующие вызовы **SQLExecDirect** и **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = прокручиваемые курсоры не требуются для маркера инструкции. Если приложение вызывает **SQLFetchScroll** для этого маркера, единственное допустимое значение *фетчориентатион* — SQL_FETCH_NEXT. Это значение по умолчанию.<br /><br /> SQL_SCROLLABLE = прокручиваемые курсоры являются обязательными для маркера инструкции. При вызове **SQLFetchScroll** приложение может указать любое допустимое значение *фетчориентатион*, достигая позиционирования курсора в режимах, отличных от последовательного.<br /><br /> Дополнительные сведения о прокручиваемых курсорах см. в разделе [прокручиваемые курсоры](../../../odbc/reference/develop-app/scrollable-cursors.md). Дополнительные сведения о связи между SQL_ATTR_CURSOR_SCROLLABLE и другими атрибутами курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md) .|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3,0)|Значение SQLULEN, указывающее, видны ли курсоры в маркере инструкции изменениям, внесенным в результирующий набор другим курсором. Установка этого атрибута влияет на последующие вызовы **SQLExecDirect** и **SQLExecute**. Приложение может считывать значение этого атрибута, чтобы получить его начальное состояние или его состояние, как Последнее заданное приложением.<br /><br /> SQL_UNSPECIFIED = не указано, что такое тип курсора, а курсоры в маркере оператора становятся видимыми изменениям, внесенным в результирующий набор другим курсором. Курсоры в маркере инструкции могут сделать видимыми ничего, некоторые или все подобные изменения. Это значение по умолчанию.<br /><br /> SQL_INSENSITIVE = все курсоры на маркере инструкции отображают результирующий набор, не отражая изменения, внесенные в него любым другим курсором. Нечувствительные курсоры доступны только для чтения. Это соответствует статическому курсору с параллелизмом, который доступен только для чтения.<br /><br /> SQL_SENSITIVE = все курсоры в маркере инструкции делают видимыми все изменения, внесенные в результирующий набор другим курсором.<br /><br /> Дополнительные сведения о связи между SQL_ATTR_CURSOR_SENSITIVITY и другими атрибутами курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2,0)|Значение SQLULEN, указывающее тип курсора:<br /><br /> SQL_CURSOR_FORWARD_ONLY = курсор прокручивается вперед.<br /><br /> SQL_CURSOR_STATIC = данные в результирующем наборе являются статическими.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = драйвер сохраняет и использует ключи для количества строк, указанных в атрибуте инструкции SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = драйвер сохраняет и использует только ключи для строк в наборе строк.<br /><br /> Значение по умолчанию — SQL_CURSOR_FORWARD_ONLY. Этот атрибут не может быть указан после подготовки инструкции SQL.<br /><br /> Если указанный тип курсора не поддерживается источником данных, драйвер подставляет другой тип курсора и возвращает значение SQLSTATE 01S02 (изменение значения параметра). Для смешанного или динамического курсора драйвер подставляет, по порядку, управляемый набором ключей или статический курсор. Для курсора, управляемого набором ключей, драйвер подставляет статический курсор.<br /><br /> Дополнительные сведения о типах курсоров с возможностью прокрутки см. в разделе [типы прокручиваемых курсоров](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Дополнительные сведения о связи между SQL_ATTR_CURSOR_TYPE и другими атрибутами курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3,0)|Значение SQLULEN, указывающее, выполняется ли автоматическое заполнение IPD:<br /><br /> SQL_TRUE = включает автоматическое заполнение IPD после вызова **SQLPrepare**. SQL_FALSE = отключает автоматическое заполнение IPD после вызова **SQLPrepare**. (Приложение по-прежнему может получить информацию о поле IPD путем вызова **SQLDescribeParam**, если поддерживается.) Значение по умолчанию атрибута инструкции SQL_ATTR_ENABLE_AUTO_IPD SQL_FALSE. Дополнительные сведения см. [в статье Автоматическое заполнение IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3,0)|Объект SQLLEN \* , указывающий на двоичное значение закладки. Когда **SQLFetchScroll** вызывается с *ффетчориентатион* , равным SQL_FETCH_BOOKMARK, драйвер выбирает значение закладки из этого поля. По умолчанию для этого поля задан пустой указатель. Дополнительные сведения см. [в разделе Прокрутка по закладке](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Значение, на которое указывает это поле, не используется для удаления с помощью закладки, обновления по закладке или выборки с помощью закладок в **SQLBulkOperations**, в которых используются закладки, кэшированные в буферах набора строк.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3,0)|Описатель для IPD. Значение этого атрибута является дескриптором, выделенным при первоначальном выделении инструкции. Приложению не удается задать этот атрибут.<br /><br /> Этот атрибут может быть извлечен вызовом **SQLGetStmtAttr** , но не задается вызовом **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3,0)|Описатель для IRD. Значение этого атрибута является дескриптором, выделенным при первоначальном выделении инструкции. Приложению не удается задать этот атрибут.<br /><br /> Этот атрибут может быть извлечен вызовом **SQLGetStmtAttr** , но не задается вызовом **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2,0)|Объект SQLULEN, указывающий количество строк в наборе ключей для курсора, управляемого набором ключей. Если размер набора ключей равен 0 (по умолчанию), курсор будет полностью управляемым набором ключей. Если размер набора ключей больше 0, курсор будет смешанным (на основе набора ключей и динамически вне набора ключей). Размер набора ключей по умолчанию равен 0. Дополнительные сведения о курсорах, управляемых набором ключей, см. в разделе [курсоры, управляемые набором ключей](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Если указанный размер превышает максимальный размер набора ключей, драйвер подставляет этот размер и возвращает значение SQLSTATE 01S02 (изменение значения параметра).<br /><br /> **SQLFetch** или **SQLFetchScroll** возвращает ошибку, если размер набора ключей больше 0 и меньше размера набора строк.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1,0)|Значение SQLULEN, указывающее максимальный объем данных, возвращаемый драйвером из символьного или двоичного столбца. Если *ValuePtr* меньше, чем длина доступных данных, **SQLFetch** или **SQLGetData** усекает данные и возвращает SQL_SUCCESS. Если *ValuePtr* имеет значение 0 (значение по умолчанию), драйвер пытается вернуть все доступные данные.<br /><br /> Если указанная длина меньше, чем минимальный объем данных, возвращаемый источником данных или превышающий максимальный объем данных, который может быть возвращен источником данных, драйвер подставляет это значение и возвращает значение SQLSTATE 01S02 (изменение значения параметра).<br /><br /> Значение этого атрибута может быть задано для открытого курсора; Однако этот параметр может не вступить в силу немедленно, в этом случае драйвер возвратит 01S02 SQLSTATE (значение параметра изменено) и сбрасывает атрибут в исходное значение.<br /><br /> Этот атрибут предназначен для уменьшения сетевого трафика и должен поддерживаться только в том случае, если источник данных (в отличие от драйвера) в многоуровневой драйвере может его реализовать. Этот механизм не следует использовать в приложениях для усечения данных. чтобы усечь полученные данные, приложение должно указать максимальную длину буфера в аргументе *BufferLength* в **SQLBindCol** или **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1,0)|Значение SQLULEN, соответствующее максимальному числу строк, возвращаемых в приложение для инструкции **SELECT** . Если \* *ValuePtr* равно 0 (значение по умолчанию), драйвер возвращает все строки.<br /><br /> Этот атрибут предназначен для уменьшения сетевого трафика. По сути, он применяется при создании результирующего набора и ограничивает результирующий набор первыми *ValuePtr* строками. Если число строк в результирующем наборе больше, чем *ValuePtr*, результирующий набор усекается.<br /><br /> SQL_ATTR_MAX_ROWS применяется ко всем результирующим наборам *инструкции*, включая возвращаемые функциями каталога. SQL_ATTR_MAX_ROWS устанавливает максимальное значение для значения счетчика строк курсора.<br /><br /> Драйвер не должен эмулировать поведение SQL_ATTR_MAX_ROWS для **SQLFetch** или **SQLFetchScroll** (если ограничения на размер результирующего набора не могут быть реализованы в источнике данных), если не может гарантировать, что SQL_ATTR_MAX_ROWS будет реализован правильно.<br /><br /> Он определяется драйвером независимо от того, применяется ли SQL_ATTR_MAX_ROWS к операторам, отличным от инструкций SELECT (например, функций каталога).<br /><br /> Значение этого атрибута может быть задано для открытого курсора; Однако этот параметр может не вступить в силу немедленно, в этом случае драйвер возвратит 01S02 SQLSTATE (значение параметра изменено) и сбрасывает атрибут в исходное значение.|  
|SQL_ATTR_METADATA_ID (ODBC 3,0)|Значение SQLULEN, определяющее, как обрабатываются строковые аргументы функций каталога.<br /><br /> Если SQL_TRUE, строковый аргумент функций каталога рассматривается как идентификаторы. Регистр не имеет значения. Для строк без разделителей драйвер удаляет все конечные пробелы, а строка выводится в верхний регистр. Для строк с разделителями драйвер удаляет все начальные или конечные пробелы и принимает любое значение между разделителями. Если для одного из этих аргументов задан пустой указатель, функция возвращает SQL_ERROR и SQLSTATE HY009 (недопустимое использование пустого указателя).<br /><br /> Если SQL_FALSE, строковые аргументы функций каталога не рассматриваются как идентификаторы. Регистр важен. Они могут содержать шаблон поиска строки или нет, в зависимости от аргумента.<br /><br /> Значение по умолчанию — SQL_FALSE.<br /><br /> Аргумент *TableType* объекта **SQLTables**, который принимает список значений, не затрагивается этим атрибутом.<br /><br /> SQL_ATTR_METADATA_ID также можно задать на уровне соединения. (Он и SQL_ATTR_ASYNC_ENABLE являются единственными атрибутами инструкций, которые также являются атрибутами соединения.)<br /><br /> Дополнительные сведения см. [в разделе аргументы в функциях каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1,0)|Значение SQLULEN, указывающее, должен ли драйвер сканировать строки SQL для escape-последовательностей:<br /><br /> SQL_NOSCAN_OFF = драйвер сканирует строки SQL для escape-последовательностей (по умолчанию).<br /><br /> SQL_NOSCAN_ON = драйвер не проверяет строки SQL для escape-последовательностей. Вместо этого драйвер отправляет инструкцию непосредственно в источник данных.<br /><br /> Дополнительные сведения см. [в разделе Escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3,0)|Значение SQLULEN *, которое указывает на смещение, добавленное в указатели на изменение привязки динамических параметров. Если это поле не равно null, драйвер отменяет ссылку на указатель, добавляет значение разыменования к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и использует новые значения указателя при привязке. По умолчанию задано значение null.<br /><br /> Смещение привязки всегда добавляется непосредственно в поля SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется на другое значение, новое значение по-прежнему добавляется непосредственно к значению в поле дескриптор. Новое смещение не добавляется к значению поля и всем предыдущим смещениям.<br /><br /> Дополнительные сведения см. в разделе [смещения привязки параметров](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_BIND_OFFSET_PTR в заголовке APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3,0)|Значение SQLULEN, указывающее ориентацию привязки, используемую для динамических параметров.<br /><br /> Для этого поля задано значение SQL_PARAM_BIND_BY_COLUMN (по умолчанию), чтобы выбрать привязку на уровне столбца.<br /><br /> Чтобы выбрать привязку на уровне строки, этому полю присваивается длина структуры или экземпляра буфера, который будет привязан к набору динамических параметров. Эта длина должна включать в себя пространство для всех привязанных параметров и любое заполнение структуры или буфера, чтобы гарантировать, что при увеличении адреса привязанного параметра на указанную длину результат будет указывать на начало того же параметра в следующем наборе параметров. При использовании оператора *sizeof* в ANSI C это поведение гарантировано.<br /><br /> Дополнительные сведения см. в разделе [Привязка массивов параметров](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ BIND_TYPE в заголовке APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3,0)|Значение СКЛУСМАЛЛИНТ \* , которое указывает на массив значений склусмаллинт, используемых для игнорирования параметра во время выполнения инструкции SQL. Каждому значению присваивается значение SQL_PARAM_PROCEED (для выполнения параметра) или SQL_PARAM_IGNORE (для игнорирования параметра).<br /><br /> Набор параметров можно пропустить во время обработки, установив значение состояния в массиве, на который указывает, SQL_DESC_ARRAY_STATUS_PTR в APD в значение SQL_PARAM_IGNORE. Набор параметров обрабатывается, если его значение состояния равно SQL_PARAM_PROCEED или если в массиве не заданы элементы.<br /><br /> Для этого атрибута инструкции можно задать пустой указатель, в этом случае драйвер не будет возвращать значения состояния параметра. Этот атрибут можно задать в любое время, но новое значение не будет использоваться до тех пор, пока не будет вызван следующий **SQLExecDirect** или **SQLExecute** .<br /><br /> Этот атрибут пропускается при отсутствии привязанного параметра.<br /><br /> Дополнительные сведения см. [в разделе Использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3,0)|Значение СКЛУСМАЛЛИНТ \* , которое указывает на массив значений склусмаллинт, содержащий сведения о состоянии для каждой строки значений параметров после вызова **SQLExecute** или **SQLExecDirect**. Это поле является обязательным только в том случае, если PARAMSET_SIZE больше 1.<br /><br /> Значения состояния могут содержать следующие значения:<br /><br /> SQL_PARAM_SUCCESS: инструкция SQL успешно выполнена для этого набора параметров.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: инструкция SQL успешно выполнена для этого набора параметров; Однако сведения о предупреждениях доступны в структуре диагностических данных.<br /><br /> SQL_PARAM_ERROR: произошла ошибка при обработке этого набора параметров. Дополнительные сведения об ошибке доступны в структуре диагностических данных.<br /><br /> SQL_PARAM_UNUSED: этот набор параметров был неиспользованным, возможно, из-за того, что некоторый предыдущий набор параметров привел к ошибке, вызвавшей дальнейшее выполнение обработки, или потому, что для этого набора параметров в массиве, указанном в SQL_ATTR_PARAM_OPERATION_PTR, был задан SQL_PARAM_IGNORE.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: драйвер обрабатывает массивы параметров как монолитную единицу и поэтому не создает этот уровень сведений об ошибках.<br /><br /> Для этого атрибута инструкции можно задать пустой указатель, в этом случае драйвер не будет возвращать значения состояния параметра. Этот атрибут можно задать в любое время, но новое значение не будет использоваться до тех пор, пока не будет вызван следующий **SQLExecute** или **SQLExecDirect** . Обратите внимание, что установка этого атрибута может повлиять на поведение выходного параметра, реализуемое драйвером.<br /><br /> Дополнительные сведения см. [в разделе Использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3,0)|\*Поле записи SQLULEN, указывающее на буфер, в котором возвращается число обработанных параметров, включая наборы ошибок. Если это указатель null, число не будет возвращено.<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ROWS_PROCESSED_PTR в заголовке IPD.<br /><br /> Если вызов **SQLExecDirect** или **SQLExecute** , который заполняет буфер, на который указывает этот атрибут, не возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.<br /><br /> Дополнительные сведения см. [в разделе Использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3,0)|Значение SQLULEN, указывающее количество значений для каждого параметра. Если SQL_ATTR_PARAMSET_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR точки APD в массивы. Количество элементов массива равно значению этого поля.<br /><br /> Этот атрибут пропускается при отсутствии привязанного параметра.<br /><br /> Дополнительные сведения см. [в разделе Использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ARRAY_SIZE в заголовке APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1,0)|Значение SQLULEN, соответствующее количеству секунд ожидания выполнения инструкции SQL перед возвратом в приложение. Если *ValuePtr* равен 0 (по умолчанию), время ожидания отсутствует.<br /><br /> Если указанное время ожидания превышает максимальное время ожидания в источнике данных или меньше, чем минимальное время ожидания, **SQLSetStmtAttr** заменяет это значение и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Обратите внимание, что приложению не требуется вызывать **SQLCloseCursor** для повторного использования инструкции, если истекло время ожидания инструкции **SELECT** .<br /><br /> Время ожидания запроса, установленное в этом атрибуте инструкции, допустимо в синхронном и асинхронном режимах.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2,0)|Значение SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** и, в ODBC *3. x*, **SQLFetch** получают данные после того, как он позиционирует курсор в указанное место. Это значение по умолчанию.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** и, в ODBC *3. x*, **SQLFetch** не извлекают данные после позиционирования курсора.<br /><br /> Установив для SQL_RETRIEVE_DATA значение SQL_RD_OFF, приложение может проверить, существует ли строка, или получить закладку для строки без затрат на получение строк. Дополнительные сведения см. в разделе [прокрутка и выборка строк](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Значение этого атрибута может быть задано для открытого курсора; Однако этот параметр может не вступить в силу немедленно, в этом случае драйвер возвратит 01S02 SQLSTATE (значение параметра изменено) и сбрасывает атрибут в исходное значение.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3,0)|Значение SQLULEN, указывающее количество строк, возвращаемых каждым вызовом метода **SQLFetch** или **SQLFetchScroll**. Это также число строк в массиве закладок, используемых в операции с массовыми закладками в **SQLBulkOperations**. Значение по умолчанию — 1.<br /><br /> Если указанный размер набора строк превышает максимальный размер набора строк, поддерживаемый источником данных, драйвер подставляет это значение и возвращает значение SQLSTATE 01S02 (изменение значения параметра).<br /><br /> Дополнительные сведения см. в разделе [Размер набора строк](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ARRAY_SIZE в заголовке АРД.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3,0)|Значение SQLULEN *, которое указывает на смещение, добавленное в указатели на изменение привязки данных столбца. Если это поле не равно null, драйвер отменяет ссылку на указатель, добавляет значение разыменования к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и использует новые значения указателя при привязке. По умолчанию задано значение null.<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_BIND_OFFSET_PTR в заголовке АРД.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1,0)|Значение SQLULEN, которое задает ориентацию привязки для использования при вызове **SQLFetch** или **SQLFetchScroll** для связанной инструкции. Привязка на уровне столбца выбирается путем установки значения SQL_BIND_BY_COLUMN. Привязка на уровне строки выбирается путем задания значения длины структуры или экземпляра буфера, в котором будут привязываться результирующие столбцы.<br /><br /> Если длина задана, она должна включать пробел для всех привязанных столбцов и любое заполнение структуры или буфера, чтобы гарантировать, что при увеличении адреса привязанного столбца с указанной длиной результат будет указывать на начало того же столбца в следующей строке. При использовании оператора **sizeof** с структурами или объединениями в ANSI C это поведение гарантировано.<br /><br /> Привязка на уровне столбца является ориентацией привязки по умолчанию для **SQLFetch** и **SQLFetchScroll**.<br /><br /> Дополнительные сведения см. в разделе [Привязка столбцов для использования с блочными курсорами](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_BIND_TYPE в заголовке АРД.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2,0)|Значение SQLULEN, которое является номером текущей строки во всем результирующем наборе. Если номер текущей строки не может быть определен или текущая строка отсутствует, драйвер возвращает значение 0.<br /><br /> Этот атрибут может быть извлечен вызовом **SQLGetStmtAttr** , но не задается вызовом **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3,0)|Значение СКЛУСМАЛЛИНТ \* , которое указывает на массив значений склусмаллинт, используемых для пропуска строки во время выполнения групповой операции с использованием функции **SQLSetPos**. Каждое значение задается как SQL_ROW_PROCEED (для строки, включаемой в операцию с массовыми операциями) или SQL_ROW_IGNORE (для строки, которая будет исключена из групповой операции). (Строки не могут быть пропущены с помощью этого массива во время вызовов **SQLBulkOperations**.)<br /><br /> Для этого атрибута инструкции можно задать пустой указатель, в этом случае драйвер не возвращает значения состояния строки. Этот атрибут можно задать в любое время, но новое значение не будет использоваться до следующего момента вызова метода **SQLSetPos** .<br /><br /> Дополнительные сведения см. в разделе [Обновление строк в наборе строк с помощью функции SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) и [Удаление строк в наборе строк с помощью функции SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ARRAY_STATUS_PTR в АРД.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3,0)|Значение СКЛУСМАЛЛИНТ \* , которое указывает на массив значений склусмаллинт, содержащих значения состояния строки после вызова **SQLFetch** или **SQLFetchScroll**. Массив содержит столько элементов, сколько строк в наборе строк.<br /><br /> Для этого атрибута инструкции можно задать пустой указатель, в этом случае драйвер не возвращает значения состояния строки. Этот атрибут можно задать в любое время, но новое значение не будет использоваться до следующего момента вызова **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll** или **SQLSetPos** .<br /><br /> Дополнительные сведения см. в разделе [число выбранных строк и состояние](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке IRD.<br /><br /> Этот атрибут сопоставлен с драйвером ODBC *2. x* в массиве *ргбровстатус* при вызове **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3,0)|Значение SQLULEN \* , указывающее на буфер, в котором возвращается число строк, извлекаемых после вызова **SQLFetch** или **SQLFetchScroll**; количество строк, затронутых массовыми операциями, выполненных путем вызова функции **SQLSetPos** с аргументом *операции* SQL_REFRESH; или числом строк, затронутых операцией, выполняемой **SQLBulkOperations**. Это число включает строки ошибок.<br /><br /> Дополнительные сведения см. в разделе [число выбранных строк и состояние](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Установка этого атрибута инструкции задает поле SQL_DESC_ROWS_PROCESSED_PTR в заголовке IRD.<br /><br /> Если вызов **SQLFetch** или **SQLFetchScroll** , который заполняет буфер, на который указывает этот атрибут, не возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2,0)|Значение SQLULEN, указывающее, будут ли драйверы, имитирующие позиционированные инструкции UPDATE и DELETE, гарантировать, что такие инструкции влияют только на одну строку.<br /><br /> Для имитации позиционированных инструкций UPDATE и DELETE большинство драйверов создают поисковые инструкции **Update** или **Delete** , содержащие предложение **WHERE** , которое задает значение каждого столбца в текущей строке. Если эти столбцы не составляют уникального ключа, такая инструкция может повлиять на более чем одну строку.<br /><br /> Чтобы гарантировать, что такие инструкции влияют только на одну строку, драйвер определяет столбцы в уникальном ключе и добавляет эти столбцы в результирующий набор. Если приложение гарантирует, что столбцы в результирующем наборе составляют уникальный ключ, этот драйвер не требуется. Это может сократить время выполнения.<br /><br /> SQL_SC_NON_UNIQUE = драйвер не гарантирует, что смоделированные позиционированные инструкции UPDATE или DELETE будут влиять только на одну строку; Это действие отвечает за приложение. Если инструкция затрагивает более одной строки, **SQLExecute**, **SQLExecDirect** или **SQLSetPos** возвращает значение SQLSTATE 01001 (конфликт операции курсора).<br /><br /> SQL_SC_TRY_UNIQUE = драйвер пытается гарантировать, что смоделированные позиционированные инструкции UPDATE или DELETE влияют только на одну строку. Драйвер всегда выполняет такие инструкции, даже если они могут повлиять на более чем одну строку, например при отсутствии уникального ключа. Если инструкция затрагивает более одной строки, **SQLExecute**, **SQLExecDirect** или **SQLSetPos** возвращает значение SQLSTATE 01001 (конфликт операции курсора).<br /><br /> SQL_SC_UNIQUE = драйвер гарантирует, что смоделированные позиционированные инструкции UPDATE или DELETE затрагивают только одну строку. Если драйвер не может гарантировать это для данной инструкции, **SQLExecDirect** или **SQLPrepare** возвращает ошибку.<br /><br /> Если источник данных обеспечивает собственную поддержку SQL для позиционированных инструкций UPDATE и DELETE, а драйвер не моделирует курсоры, SQL_SUCCESS возвращается при запросе SQL_SC_UNIQUE для SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO возвращается, если запрашивается SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE. Если источник данных предоставляет SQL_SC_TRY_UNIQUE уровень поддержки, а драйвер — нет, SQL_SUCCESS возвращается для SQL_SC_TRY_UNIQUE, а SQL_SUCCESS_WITH_INFO возвращается для SQL_SC_NON_UNIQUE.<br /><br /> Если указанный тип моделирования курсора не поддерживается источником данных, драйвер подставляет другой тип моделирования и возвращает значение SQLSTATE 01S02 (изменение значения параметра). Для SQL_SC_UNIQUE драйвер подставляет, по порядку, SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE. Для SQL_SC_TRY_UNIQUE драйвер подставляет SQL_SC_NON_UNIQUE.<br /><br /> Значение по умолчанию — SQL_SC_UNIQUE.<br /><br /> Дополнительные сведения см. в разделе [моделирование позиционированных инструкций UPDATE и DELETE](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2,0)|Значение SQLULEN, указывающее, будет ли приложение использовать закладки с курсором:<br /><br /> SQL_UB_OFF = Off (по умолчанию)<br /><br /> SQL_UB_VARIABLE = приложение будет использовать закладки с курсором, а драйвер предоставит закладки переменной длины, если они поддерживаются. SQL_UB_FIXED не рекомендуется использовать в ODBC *3. x*. Приложения ODBC *3. x* всегда должны использовать закладки переменной длины, даже при работе с драйверами ODBC *2. x* (поддерживающими только 4-байтовые закладки фиксированной длины). Это обусловлено тем, что закладка с фиксированной длиной является просто особым случаем закладки с переменной длиной. При работе с драйвером ODBC *2. x* диспетчер драйверов сопоставляет SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Чтобы использовать закладки с курсором, приложение должно указать этот атрибут со значением SQL_UB_VARIABLE перед открытием курсора.<br /><br /> Дополнительные сведения см. в разделе [получение закладок](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] эти функции можно вызывать асинхронно, только если дескриптор является дескриптором реализации, а не дескриптором приложения.  
  
 См. раздел [Привязка на уровне столбца](../../../odbc/reference/develop-app/column-wise-binding.md) и [Привязка по строкам](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат значения атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Возврат значения атрибута инструкции|[SQLGetStmtAttr, функция](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Установка атрибута соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Задание одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
