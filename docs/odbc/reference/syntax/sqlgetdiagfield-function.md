---
description: Функция SQLGetDiagField
title: Функция SQLGetDiagField | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLGetDiagField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetDiagField
helpviewer_keywords:
- SQLGetDiagField function [ODBC]
ms.assetid: 1dbc4398-97a8-4585-bb77-1f7ea75e24c4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 733933691297f22934fe59e0c337dfd6093ddd3b
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99194183"
---
# <a name="sqlgetdiagfield-function"></a>Функция SQLGetDiagField

**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 3,0: ISO 92  
  
 **Сводка**  
 **SQLGetDiagField** возвращает текущее значение поля записи структуры диагностических данных (связанное с указанным маркером), которое содержит ошибки, предупреждения и сведения о состоянии.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp

SQLRETURN SQLGetDiagField(  
     SQLSMALLINT     HandleType,  
     SQLHANDLE       Handle,  
     SQLSMALLINT     RecNumber,  
     SQLSMALLINT     DiagIdentifier,  
     SQLPOINTER      DiagInfoPtr,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   StringLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 Входной Идентификатор типа обработчика, описывающий тип обработчика, для которого требуются диагностические сведения. Должна быть одной из следующих:  
  
-   SQL_HANDLE_DBC  
  
-   SQL_HANDLE_DBC_INFO_TOKEN  
  
-   SQL_HANDLE_DESC  
  
-   SQL_HANDLE_ENV  
  
-   SQL_HANDLE_STMT  
  
 SQL_HANDLE_DBC_INFO_TOKENный обработчик используется только диспетчером драйверов и драйвером. Приложения не должны использовать этот тип обработчика. Дополнительные сведения о SQL_HANDLE_DBC_INFO_TOKEN см. [в разделе Разработка осведомленности Connection-Pool в драйвере ODBC](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md).  
  
 *Дескриптор*  
 Входной Маркер для структуры диагностических данных типа, указанного параметром *параметром handletype*. Если *параметром handletype* имеет SQL_HANDLE_ENV, то *Handle* может быть либо общим, либо несовместно используемым обработчиком среды.  
  
 *RecNumber*  
 Входной Указывает запись состояния, из которой приложение ищет сведения. Записи состояния нумеруются с 1. Если аргумент *диагидентифиер* указывает любое поле заголовка Diagnostics, *рекнумбер* игнорируется. Если нет, значение должно быть больше 0.  
  
 *диагидентифиер*  
 Входной Указывает поле диагностики, значение которого должно быть возвращено. Дополнительные сведения см. в подразделе «аргумент *диагидентифиер* » раздела «комментарии».  
  
 *диагинфоптр*  
 Проверки Указатель на буфер, в который возвращаются диагностические данные. Тип данных зависит от значения *диагидентифиер*. Если *диагинфоптр* имеет целочисленный тип, то приложения должны использовать буфер SQLULEN и инициализировать значение 0 перед вызовом этой функции, так как некоторые драйверы могут записывать только более низкие 32-разрядные или 16-разрядные буферы и оставлять бит более высокого порядка без изменений.  
  
 Если *диагинфоптр* имеет значение null, *стрингленгсптр* будет возвращать общее число байтов (исключая символ завершения null для символьных данных), доступный для возврата в буфер, на который указывает *диагинфоптр*.  
  
 *BufferLength*  
 Входной Если *диагидентифиер* — определяемая ODBC диагностика, а *диагинфоптр* указывает на символьную строку или двоичный буфер, этот аргумент должен иметь длину \* *диагинфоптр*. Если *диагидентифиер* является определяемым ODBC полем, а \* *диагинфоптр* — целым числом, *BufferLength* игнорируется. Если значение в *\* диагинфоптр* является строкой Юникода (при вызове **Склжетдиагфиелдв**), аргумент *BufferLength* должен быть четным числом.  
  
 Если *диагидентифиер* является полем, определенным драйвером, приложение указывает природу поля в диспетчере драйверов, установив аргумент *BufferLength* . *BufferLength* могут иметь следующие значения:  
  
-   Если *диагинфоптр* является указателем на символьную строку, *BufferLength* — это длина строки или SQL_NTS.  
  
-   Если *диагинфоптр* является указателем на двоичный буфер, приложение помещает результат макроса SQL_LEN_BINARY_ATTR (*length*) в *BufferLength*. Это помещает отрицательное значение в *BufferLength*.  
  
-   Если *диагинфоптр* является указателем на значение, отличное от символьной строки или двоичной строки, *BufferLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *\* диагинфоптр* содержит тип данных фиксированной длины, *BufferLength* — SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT или SQL_IS_USMALLINT, в зависимости от ситуации.  
  
 *стрингленгсптр*  
 Проверки Указатель на буфер, в котором возвращается общее число байтов (за исключением числа байтов, необходимых для завершающего символа null), доступных для возврата в \* *диагинфоптр*, для символьных данных. Если число возвращаемых байт больше или равно значению *BufferLength*, текст в \* *Диагинфоптр* усекается до *BufferLength* минус длину завершающего символа null.  
  
## <a name="returns"></a>Возвращаемое значение  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_NO_DATA.  
  
## <a name="diagnostics"></a>Диагностика  
 **SQLGetDiagField** не выполняет запись диагностических записей для себя. Он использует следующие возвращаемые значения, чтобы сообщить результат своего выполнения.  
  
-   SQL_SUCCESS: функция успешно вернула диагностические сведения.  
  
-   SQL_SUCCESS_WITH_INFO: \* *диагинфоптр* слишком мал для размещения запрошенного поля диагностики. Поэтому данные в поле диагностики были усечены. Чтобы определить, что произошло усечение, приложение должно сравнить *BufferLength* с фактическим числом доступных байтов, которое записывается в **стрингленгсптр*.  
  
-   SQL_INVALID_HANDLE: маркер, указанный *параметром handletype* и *Handle* , не является допустимым маркером.  
  
-   SQL_ERROR: произошла одна из следующих ошибок:  
  
    -   Аргумент *диагидентифиер* не является одним из допустимых значений.  
  
    -   Аргумент *диагидентифиер* был SQL_DIAG_CURSOR_ROW_COUNT, SQL_DIAG_DYNAMIC_FUNCTION, SQL_DIAG_DYNAMIC_FUNCTION_CODE или SQL_DIAG_ROW_COUNT, но *Handle* не является маркером инструкции. (Диспетчер драйверов возвращает эту диагностику.)  
  
    -   Аргумент *рекнумбер* был отрицательным или 0, когда *диагидентифиер* указал поле из диагностической записи. *Рекнумбер* игнорируется для полей заголовка.  
  
    -   Запрошенное значение было символьной строкой, а *BufferLength* меньше нуля.  
  
    -   При использовании асинхронного уведомления асинхронная операция с этим маркером не была завершена.  
  
-   SQL_NO_DATA: *рекнумбер* превышает число записей диагностики, существовавших для указанного в Handle маркера *.* Функция также возвращает SQL_NO_DATA для любого положительного *рекнумбер* , если отсутствуют диагностические записи для *обработчика*.  
  
## <a name="comments"></a>Комментарии  
 Приложение обычно вызывает **SQLGetDiagField** для выполнения одной из трех целей:  
  
1.  Чтобы получить конкретные сведения об ошибке или предупреждении, когда вызов функции возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO (или SQL_NEED_DATA для функции **SQLBrowseConnect** ).  
  
2.  Для определения количества строк в источнике данных, которые были затронуты при выполнении операций вставки, удаления или обновления с помощью вызова **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos** (из поля заголовка SQL_DIAG_ROW_COUNT), или для определения количества строк, существующих в текущем открытом курсоре, если драйвер может предоставить эти сведения (из поля заголовка SQL_DIAG_CURSOR_ROW_COUNT).  
  
3.  Чтобы определить, какая функция была выполнена вызовом **SQLExecDirect** или **SQLExecute** (из полей заголовка SQL_DIAG_DYNAMIC_FUNCTION и SQL_DIAG_DYNAMIC_FUNCTION_CODE).  
  
 Любая функция ODBC может отправлять несколько диагностических записей при каждом вызове, поэтому приложение может вызвать **SQLGetDiagField** после любого вызова функции ODBC. Количество диагностических записей, которые могут храниться в любой момент времени, не ограничено. **SQLGetDiagField** извлекает только диагностические сведения, которые недавно связаны с структурой диагностических данных, указанной в аргументе *Handle* . Если приложение вызывает функцию ODBC, отличную от **SQLGetDiagField** или **SQLGetDiagRec**, то теряются все диагностические сведения из предыдущего вызова с тем же маркером.  
  
 Приложение может сканировать все диагностические записи путем увеличения *рекнумбер*, если **SQLGetDiagField** возвращает SQL_SUCCESS. Число записей о состоянии указывается в поле заголовка SQL_DIAG_NUMBER. Вызовы **SQLGetDiagField** являются необратимыми для полей заголовков и записей. Приложение может снова вызвать **SQLGetDiagField** для получения поля из записи, если функция, отличная от функций диагностики, не была вызвана в промежуточной области, что приведет к публикации записей в одном и том же обработчике.  
  
 Приложение может вызывать **SQLGetDiagField** для возвращения любого диагностического поля в любое время, за исключением SQL_DIAG_CURSOR_ROW_COUNT или SQL_DIAG_ROW_COUNT, которые возвращают SQL_ERROR если *Handle* не является маркером инструкции. Если какое-либо другое поле диагностики не определено, вызов **SQLGetDiagField** возвратит SQL_SUCCESS (при отсутствии других диагностических сведений) и для поля возвращается неопределенное значение.  
  
 Дополнительные сведения см. в статьях [Использование SQLGetDiagRec и SQLGetDiagField](../../../odbc/reference/develop-app/using-sqlgetdiagrec-and-sqlgetdiagfield.md) и [Реализация SQLGetDiagRec и SQLGetDiagField](../../../odbc/reference/develop-app/implementing-sqlgetdiagrec-and-sqlgetdiagfield.md).  
  
 Вызов API, отличного от выполняемого асинхронно, приведет к формированию HY010 "ошибка последовательности функций". Однако запись об ошибке не может быть получена до завершения асинхронной операции.  
  
## <a name="handletype-argument"></a>Параметром handletype, аргумент  
 С каждым типом обработчика может быть связана диагностическая информация. Аргумент *параметром handletype* указывает *тип маркера.*  
  
 Некоторые поля заголовков и записей не могут быть возвращены для дескрипторов среды, соединения, инструкции и дескрипторов. Эти дескрипторы, для которых поле неприменимо, указаны в разделах "поля заголовка" и "поля записи" ниже.  
  
 Если *параметром handletype* имеет SQL_HANDLE_ENV, то *Handle* может быть либо общим, либо несовместно используемым обработчиком среды.  
  
 Нет связанных с драйвером полей диагностики заголовков, которые не должны быть связаны с обработчиком среды.  
  
 Единственными полями заголовка диагностики, определенными для дескриптора дескриптора, являются SQL_DIAG_NUMBER и SQL_DIAG_RETURNCODE.  
  
## <a name="diagidentifier-argument"></a>Диагидентифиер, аргумент  
 Этот аргумент указывает идентификатор поля, требуемого из структуры диагностических данных. Если *рекнумбер* больше или равен 1, данные в поле описывают диагностическую информацию, возвращенную функцией. Если *рекнумбер* имеет значение 0, поле находится в заголовке структуры диагностических данных и, следовательно, содержит данные, относящиеся к вызову функции, который вернул диагностические сведения, а не на конкретные сведения.  
  
 Драйверы могут определять поля заголовков и записей, относящиеся к драйверу, в структуре диагностических данных.  
  
 Приложение ODBC 3 *. x* , работающее с драйвером ODBC 2 *. x* , может вызывать **SQLGetDiagField** только с аргументом *диагидентифиер* SQL_DIAG_CLASS_ORIGIN, SQL_DIAG_CLASS_SUBCLASS_ORIGIN, SQL_DIAG_CONNECTION_NAME, SQL_DIAG_MESSAGE_TEXT, SQL_DIAG_NATIVE, SQL_DIAG_NUMBER, SQL_DIAG_RETURNCODE, SQL_DIAG_SERVER_NAME или SQL_DIAG_SQLSTATE. Все остальные поля диагностики будут возвращать SQL_ERROR.  
  
## <a name="header-fields"></a>Поля заголовка  
 Поля заголовка, перечисленные в следующей таблице, могут быть включены в аргумент *диагидентифиер* .  
  
|диагидентифиер|Возвращаемый тип|Возвращаемое значение|  
|--------------------|-----------------|-------------|  
|SQL_DIAG_CURSOR_ROW_COUNT|SQLLEN|Это поле содержит количество строк в курсоре. Его семантика зависит от типов сведений **SQLGetInfo** SQL_DYNAMIC_CURSOR_ATTRIBUTES2, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2, SQL_KEYSET_CURSOR_ATTRIBUTES2 и SQL_STATIC_CURSOR_ATTRIBUTES2, которые указывают, какие счетчики строк доступны для каждого типа курсора (в SQL_CA2_CRC_EXACT и SQL_CA2_CRC_APPROXIMATE).<br /><br /> Содержимое этого поля определяется только для дескрипторов операторов и только после вызова **SQLExecute**, **SQLExecDirect** или **SQLMoreResults** . Вызов **SQLGetDiagField** с *диагидентифиер* SQL_DIAG_CURSOR_ROW_COUNT, кроме маркера инструкции, возвратит SQL_ERROR.|  
|SQL_DIAG_DYNAMIC_FUNCTION|SQLCHAR|Это строка, описывающая инструкцию SQL, которая была выполнена базовой функцией. (См. раздел «значения полей динамической функции» далее в этом разделе для конкретных значений.) Содержимое этого поля определяется только для дескрипторов операторов и только после вызова **SQLExecute**, **SQLExecDirect** или **SQLMoreResults**. Вызов **SQLGetDiagField** с *диагидентифиер* SQL_DIAG_DYNAMIC_FUNCTION, кроме маркера инструкции, возвратит SQL_ERROR. Значение этого поля не определено перед вызовом **SQLExecute** или **SQLExecDirect**.|  
|SQL_DIAG_DYNAMIC_FUNCTION_CODE|SQLINTEGER|Это числовой код, описывающий инструкцию SQL, которая была выполнена базовой функцией. (См. раздел «значения полей динамической функции» далее в этом разделе для конкретного значения.) Содержимое этого поля определяется только для дескрипторов операторов и только после вызова **SQLExecute**, **SQLExecDirect** или **SQLMoreResults**. Вызов **SQLGetDiagField** с *диагидентифиер* SQL_DIAG_DYNAMIC_FUNCTION_CODE, кроме маркера инструкции, возвратит SQL_ERROR. Значение этого поля не определено перед вызовом **SQLExecute** или **SQLExecDirect**.|  
|SQL_DIAG_NUMBER|SQLINTEGER|Число записей о состоянии, доступных для указанного маркера.|  
|SQL_DIAG_RETURNCODE|склретурн|Возвращаемый функцией код. Список кодов возврата см. в разделе [коды возврата](../../../odbc/reference/develop-app/return-codes-odbc.md). Драйверу не требуется реализовывать SQL_DIAG_RETURNCODE; Он всегда реализуется диспетчером драйверов. Если для *маркера* еще не вызывалась функция, SQL_SUCCESS будет возвращен для SQL_DIAG_RETURNCODE.|  
|SQL_DIAG_ROW_COUNT|SQLLEN|Число строк, затронутых вставкой, удалением или обновлением, выполненным **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** или **SQLSetPos**. Он определяется драйвером после выполнения *спецификации курсора* . Содержимое этого поля определяется только для дескрипторов инструкций. Вызов **SQLGetDiagField** с *диагидентифиер* SQL_DIAG_ROW_COUNT, кроме маркера инструкции, возвратит SQL_ERROR. Данные в этом поле также возвращаются в аргументе *RowCountPtr* объекта **SQLRowCount**. Данные в этом поле сбрасываются после каждого недиагностического вызова функции, в то время как число строк, возвращаемое функцией **SQLRowCount** , остается прежним до тех пор, пока инструкция не будет возвращена в подготовленное или выделенное состояние.|  
  
## <a name="record-fields"></a>Поля записей  
 Поля записей, перечисленные в следующей таблице, могут быть включены в аргумент *диагидентифиер* .  
  
|диагидентифиер|Возвращаемый тип|Возвращаемое значение|  
|--------------------|-----------------|-------------|  
|SQL_DIAG_CLASS_ORIGIN|SQLCHAR|Строка, указывающая документ, который определяет часть значения SQLSTATE в этой записи для класса. Его значение — "ISO 9075" для всех SQLSTATE, определенных интерфейсом уровня вызовов Open Group и ISO. Для SQLSTATE, относящихся к ODBC (все, чей класс SQLSTATE является IM), его значение — "ODBC 3,0".|  
|SQL_DIAG_COLUMN_NUMBER|SQLINTEGER|Если поле SQL_DIAG_ROW_NUMBER является допустимым номером строки в наборе строк или наборе параметров, это поле содержит значение, представляющее номер столбца в результирующем наборе, или номер параметра в наборе параметров. Номера столбцов результирующего набора всегда начинаются с 1; Если эта запись состояния относится к столбцу закладки, поле может быть равно нулю. Номера параметров начинаются с 1. Он имеет значение SQL_NO_COLUMN_NUMBER, если запись состояния не связана с номером столбца или номером параметра. Если драйвер не может определить номер столбца или номер параметра, с которым связана эта запись, это поле имеет значение SQL_COLUMN_NUMBER_UNKNOWN.<br /><br /> Содержимое этого поля определяется только для дескрипторов инструкций.|  
|SQL_DIAG_CONNECTION_NAME|SQLCHAR|Строка, указывающая имя соединения, к которому относится диагностическая запись. Это поле определяется драйвером. Для структур диагностических данных, связанных с обработчиком среды, и для диагностики, которые не связаны ни с одним соединением, это поле является строкой нулевой длины.|  
|SQL_DIAG_MESSAGE_TEXT|SQLCHAR|Информационное сообщение об ошибке или предупреждении. Это поле форматируется, как описано в [сообщениях диагностики](../../../odbc/reference/develop-app/diagnostic-messages.md). Отсутствует максимальная длина текста диагностического сообщения.|  
|SQL_DIAG_NATIVE|SQLINTEGER|Собственный код ошибки (драйвер/источник данных). Если собственный код ошибки отсутствует, драйвер возвращает значение 0.|  
|SQL_DIAG_ROW_NUMBER|SQLLEN|Это поле содержит номер строки набора строк или номер параметра в наборе параметров, с которым связана запись о состоянии. Номера строк и номера параметров начинаются с 1. Это поле имеет значение SQL_NO_ROW_NUMBER, если эта запись состояния не связана с номером строки или номером параметра. Если драйвер не может определить номер строки или номер параметра, с которым связана эта запись, это поле имеет значение SQL_ROW_NUMBER_UNKNOWN.<br /><br /> Содержимое этого поля определяется только для дескрипторов инструкций.|  
|SQL_DIAG_SERVER_NAME|SQLCHAR|Строка, указывающая имя сервера, к которому относится диагностическая запись. Это то же самое, что и значение, возвращаемое для вызова **SQLGetInfo** с параметром SQL_DATA_SOURCE_NAME. Для структур диагностических данных, связанных с обработчиком среды, и для диагностики, которые не связаны ни с одним сервером, это поле является строкой нулевой длины.|  
|SQL_DIAG_SQLSTATE|SQLCHAR|Код диагностического кода SQLSTATE с пятью символами. Дополнительные сведения см. в разделе [SQLSTATE](../../../odbc/reference/develop-app/sqlstates.md).|  
|SQL_DIAG_SUBCLASS_ORIGIN|SQLCHAR|Строка с тем же форматом и допустимыми значениями, что и SQL_DIAG_CLASS_ORIGIN, которая определяет определяющую часть части кода SQLSTATE, которая является частью подкласса. SQLSTATE, зависящие от ODBC, для которого возвращается ODBC 3,0, включает следующие сведения:<br /><br /> 01S00, 01S01, 01S02, 01S06, 01S07, 07S01, 08S01, 21S01, 21S02, 25S01, 25S02, 25S03, 42S01, 42S02, 42S11, 42S12, 42S21, 42S22, HY095, HY097, HY098, HY099, HY100, HY101, HY105, HY107, HY109, HY110, HY111, HYT00, HYT01, IM001, IM002, IM003, IM004, IM005.|  
  
## <a name="values-of-the-dynamic-function-fields"></a>Значения полей динамической функции  
 В следующей таблице описаны значения SQL_DIAG_DYNAMIC_FUNCTION и SQL_DIAG_DYNAMIC_FUNCTION_CODE, которые применяются к каждому типу инструкции SQL, выполняемой вызовом **SQLExecute** или **SQLExecDirect**. Драйвер может добавлять в список значения, определенные драйвером.  
  
|Инструкция SQL<br /><br /> выполняется|Значение параметра <br /><br /> SQL_DIAG_DYNAMIC_FUNCTION|Значение параметра <br /><br /> SQL_DIAG_DYNAMIC_FUNCTION_CODE|  
|--------------------------------|-----------------------------------------------|-----------------------------------------------------|  
|*ALTER-Domain-оператор*|"ALTER DOMAIN"|SQL_DIAG_ALTER_DOMAIN|  
|*ALTER-TABLE-оператор*|"ALTER TABLE"|SQL_DIAG_ALTER_TABLE|  
|*утверждение-определение*|"СОЗДАТЬ УТВЕРЖДЕНИЕ"|SQL_DIAG_CREATE_ASSERTION|  
|*Определение набора символов*|"СОЗДАТЬ НАБОР СИМВОЛОВ"|SQL_DIAG_CREATE_CHARACTER_SET|  
|*параметры сортировки — определение*|"СОЗДАНИЕ ПАРАМЕТРОВ СОРТИРОВКИ"|SQL_DIAG_CREATE_COLLATION|  
|*доменn — определение*|"СОЗДАТЬ ДОМЕН"|SQL_DIAG_CREATE_DOMAIN|
|*Инструкция CREATE-INDEX-*|"СОЗДАТЬ ИНДЕКС"|SQL_DIAG_CREATE_INDEX|  
|*Инструкция CREATE-TABLE-*|"CREATE TABLE"|SQL_DIAG_CREATE_TABLE|  
|*Инструкция CREATE-VIEW-*|"СОЗДАТЬ ПРЕДСТАВЛЕНИЕ"|SQL_DIAG_CREATE_VIEW|  
|*Спецификация курсора*|"ВЫБОР КУРСОРА"|SQL_DIAG_SELECT_CURSOR|  
|*Инструкция DELETE — позиционированное расположение*|"ДИНАМИЧЕСКИЙ КУРСОР УДАЛЕНИЯ"|SQL_DIAG_DYNAMIC_DELETE_CURSOR|  
|*Инструкция DELETE — Поиск*|"УДАЛИТЬ, ГДЕ"|SQL_DIAG_DELETE_WHERE|  
|*Drop-assertion-Инструкция*|"DROP ASSERTION"|SQL_DIAG_DROP_ASSERTION|  
|*Drop-символ-Set-stmt*|"УДАЛИТЬ НАБОР СИМВОЛОВ"|SQL_DIAG_DROP_CHARACTER_SET|  
|*Drop-collation-Инструкция*|"УДАЛИТЬ ПАРАМЕТРЫ СОРТИРОВКИ"|SQL_DIAG_DROP_COLLATION|  
|*Drop-домен-Инструкция*|"УДАЛИТЬ ДОМЕН"|SQL_DIAG_DROP_DOMAIN|  
|*Drop-индекс — инструкция*|"DROP INDEX"|SQL_DIAG_DROP_INDEX|  
|*Инструкция Drop-Schema-*|"DROP SCHEMA"|SQL_DIAG_DROP_SCHEMA|  
|*Drop-таблица-Инструкция*|"DROP TABLE"|SQL_DIAG_DROP_TABLE|  
|*Drop-Translation — Инструкция*|"УДАЛИТЬ ПЕРЕВОД"|SQL_DIAG_DROP_TRANSLATION|  
|*Drop-View-Инструкция*|"УДАЛИТЬ ПРЕДСТАВЛЕНИЕ"|SQL_DIAG_DROP_VIEW|  
|*грантстатемент*|ИМ|SQL_DIAG_GRANT|
|*Инструкция INSERT*|ВСТАВЛЯЕТ|SQL_DIAG_INSERT|  
|*Расширение процедуры ODBC*|ОБРАЩЕНИЕ|ВЫЗОВ SQL_DIAG_|  
|*REVOKE-Инструкция*|REVOKE|SQL_DIAG_REVOKE|  
|*определение схемы*|"СОЗДАТЬ СХЕМУ"|SQL_DIAG_CREATE_SCHEMA|  
|*Преобразование-определение*|"СОЗДАТЬ ПЕРЕВОД"|SQL_DIAG_CREATE_TRANSLATION|  
|*Update — инструкция позиционирована*|"ДИНАМИЧЕСКИЙ КУРСОР ОБНОВЛЕНИЯ"|SQL_DIAG_DYNAMIC_UPDATE_CURSOR|  
|*Update — Поиск по инструкциям*|"ОБНОВЛЕНИЕ WHERE"|SQL_DIAG_UPDATE_WHERE|  
|Неизвестно|*пустая строка*|SQL_DIAG_UNKNOWN_STATEMENT|  

<!--
These two malformed table rows were fixed by educated GUESS only.
Each pair starts with the original flawed row.
Flawed because treated as only two cells by HTML render,
and because missing info anyway.
Also, these flawed rows lacked '|' as their first nonWhitespace character (although markdown technically allows this omission, unfortunately).
Arguably the following SQL.H file shows the sequence of the flawed rows in the table was suboptimal also.

ftp://www.fpc.org/fpc32/VS6Disk1/VC98/INCLUDE/SQL.H

GeneMi , 2019/01/19
- - - - - - - - - - - - - -

n-definition*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|  

|*domain-definition*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|

-statement*|"GRANT"|SQL_DIAG_GRANT|  

|*grant-statement*|"GRANT"|SQL_DIAG_GRANT|

-->

## <a name="sequence-of-status-records"></a>Последовательность записей состояния

 Записи состояния располагаются в последовательности на основе номера строки и типа диагностики. Диспетчер драйверов определяет окончательный порядок, в котором возвращаются генерируемые записи о состоянии. Драйвер определяет окончательный порядок, в котором возвращаются генерируемые записи о состоянии.  
  
 Если записи диагностики публикуются как диспетчер драйверов, так и драйвер, диспетчер драйверов отвечает за их упорядочивание.  
  
 При наличии двух или более записей состояния последовательность записей определяется сначала по номеру строки. Для определения последовательности записей диагностики по строке применяются следующие правила.  
  
-   Записи, которые не соответствуют какой-либо строке, отображаются перед записями, соответствующими определенной строке, поскольку SQL_NO_ROW_NUMBER определяется как-1.  
  
-   Записи, для которых номер строки неизвестен, отображаются перед всеми другими записями, поскольку SQL_ROW_NUMBER_UNKNOWN определяется как-2.  
  
-   Для всех записей, относящихся к конкретным строкам, записи сортируются по значению в поле SQL_DIAG_ROW_NUMBER. Перечислены все ошибки и предупреждения первой затронутой строки, а затем все ошибки и предупреждения следующей строки и т. д.  
  
> [!NOTE]
>  Диспетчер драйверов ODBC 3 *. x* не упорядочивает записи состояния в очереди диагностики, если значение SQLSTATE 01S01 (ошибка в строке) возвращено драйвером ODBC 2 *. x* или если значение SQLSTATE 01S01 (ошибка в строке) возвращается драйвером ODBC 3 *. x* , когда вызывается **SQLExtendedFetch** или метод **SQLSetPos** вызывается для курсора, который был помещен в **SQLExtendedFetch**.  
  
 В каждой строке или для всех записей, которые не соответствуют строке или для которых номер строки неизвестен или для всех этих записей с номером строки, равным SQL_NO_ROW_NUMBER, первая указанная запись определяется с помощью набора правил сортировки. После первой записи порядок других записей, влияющих на строку, не определен. Приложение не может предположить, что ошибки предшествуют предупреждениям после первой записи. Приложения должны сканировать полную структуру диагностических данных для получения полных сведений о неудачном вызове функции.  
  
 Для определения первой записи в строке используются следующие правила. Запись с самым высоким рангом является первой записью. Источник записи (диспетчер драйверов, драйвер, шлюз и т. д.) не учитывается при ранжировании записей.  
  
-   **Ошибки** Записи состояния, описывающие ошибки, имеют наивысший ранг. Для сортировки ошибок применяются следующие правила.  
  
    -   Записи, указывающие на сбой транзакции или возможную неудачную попытку транзакции, могут расранжировать все остальные записи.  
  
    -   Если две или более записей описывают одно и то же условие ошибки, то SQLSTATE, определяемые спецификацией Open Group CLI (classes 03 – Гц), характеризуется рангом ODBC и определяемым драйвером SQLSTATE.  
  
-   **Реализация-не определено значений данных** Записи состояния, описывающие определенный драйвером, значения данных (класс 02) имеют второй высший ранг.  
  
-   **Предупреждения** Записи состояния, описывающие предупреждения (класс 01), имеют самый низкий ранг. Если две или более записей описывают одно и то же условие предупреждения, то предупреждение SQLSTATE, определенное в спецификации Open Group CLI, определяется с помощью драйвера SQLSTATE, определяемого ODBC.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Получение нескольких полей структуры диагностических данных|[Функция SQLGetDiagRec](sqlgetdiagrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
