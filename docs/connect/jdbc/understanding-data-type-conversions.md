---
title: Основные сведения о преобразованиях типов данных
description: Сведения о том, как драйвер JDBC для SQL Server обеспечивает преобразование типов данных между типами данных JDBC и базы данных.
ms.custom: ''
ms.date: 08/12/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: 98fa7488-aac3-45b4-8aa4-83ed6ab638b4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 266db3efac0fb737ccb36900ef3b27f24c8c8888
ms.sourcegitcommit: 7eb80038c86acfef1d8e7bfd5f4e30e94aed3a75
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2020
ms.locfileid: "92081683"
---
# <a name="understanding-data-type-conversions"></a>Основные сведения о преобразованиях типов данных

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

Чтобы упростить преобразование типов данных языка программирования Java в типы данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], драйвер [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] реализует преобразование типов данных в соответствии с требованиями спецификации JDBC. Повышенная гибкость обеспечивается тем, что следующие типы можно преобразовывать в прямом и обратном направлениях: **Object**, **String** и **byte[]**.

## <a name="getter-method-conversions"></a>Преобразования метода считывания

На следующей диаграмме показана схема преобразования для драйвера JDBC, основанная на типах данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], для методов get\<Type>() класса [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md), а также поддерживаемое преобразование для методов get\<Type> класса [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md).

![Матрица преобразования типа JDBC в SQL Server](../../connect/jdbc/media/jdbcgetterconversions.gif "JDBCGetterConversions")

Преобразования, поддерживаемые методами считывания драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для случаев, когда тип метода считывания является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода getBigDecimal для базового десятичного столбца сервера преобразование не потребуется.

- **С преобразованием (y)**. Преобразования из числовых типов сервера в типы языка Java, когда преобразование осуществляется стандартным образом и отвечает правилам преобразования языка Java. Для этих видов преобразования точность всегда усекается (никогда не округляется), а переполнение обрабатывается как остаток от деления на целевой тип, который меньше по размеру. Например, вызов метода getInt для базового **десятичного** столбца, который содержит значение "1.9999", вернет значение "1", а если базовое **десятичное** значение равно "3000000000", то произойдет переполнение значения **int** и результат будет равен "-1294967296".

- **В зависимости от данных (z)**. Для преобразования из базовых символьных типов в числовые типы требуется, чтобы символьные типы содержали значения, которые могут быть преобразованы в данный тип. Никакие другие преобразования не выполняются. Если значение слишком велико для метода считывания, то оно является недопустимым. Например, если вызывается метод getInt относительно столбца varchar(50), который содержит значение "53", значение возвращается в виде **int**, однако, если базовое значение ― "xyz" или "3000000000", возникает ошибка.

Если метод getString вызывается для типов данных столбца **binary**, **varbinary**, **varbinary(max)** или **image**, возвращается шестнадцатеричное строковое значение.

## <a name="updater-method-conversions"></a>Преобразования метода обновления

Для данных на языке Java, передаваемых методам update\<Type>() класса [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md), применяются следующие виды преобразования.

![JDBCUpdaterConversions](../../connect/jdbc/media/jdbc_jdbcupdatterconversions.gif "JDBCUpdaterConversions")

Преобразования, поддерживаемые методами обновления драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для случаев, когда тип обновления является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода updateBidDecimal для базового десятичного столбца сервера преобразование не потребуется.

- **С преобразованием (y)**. Преобразования из числовых типов сервера в типы языка Java, когда преобразование осуществляется стандартным образом и отвечает правилам преобразования языка Java. Для этих видов преобразования точные значения всегда усекаются (и никогда не округляются), а при переполнении значение сокращается по модулю размера типа назначения (меньшего). Например, вызов метода updateDecimal для базового столбца **int**, который содержит значение "1.9999", вернет значение "1", а если базовое **десятичное** значение равно "3000000000", то произойдет переполнение значения **int** и результат будет равен "-1294967296".

- **В зависимости от данных (z)**. Для преобразования из типов данных базового источника в типы данных назначения требуется, чтобы содержащиеся значения могли быть преобразованы в типы назначения. Никакие другие преобразования не выполняются. Если значение слишком велико для метода считывания, то оно является недопустимым. Например, если вызывается метод updateString с аргументом «53» относительно столбца int, обновление завершается успешно; однако если базовое значение строки ― «foo» или «3000000000», возникает ошибка.

Если метод updateString вызывается для типов данных столбца **binary**, **varbinary**, **varbinary(max)** или **image**, он обрабатывает значение String в виде шестнадцатеричного строкового значения.

Если столбец [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] имеет тип данных **XML**, то значение данных должно быть допустимым **XML**. При вызове методов updateBytes, updateBinaryStream или updateBlob значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Пример:

```xml
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E
```

Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.

## <a name="setter-method-conversions"></a>Преобразования метода задания

Для данных на языке Javа, передаваемых методам set\<Type>() класса [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) и класса [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md), применяются следующие виды преобразования.

![JDBCSetterConversions](../../connect/jdbc/media/jdbc_jdbcsetterconversions_v2.gif "JDBCSetterConversions")

Сервер проверяет любые виды преобразования и возвращает ошибку при неудачном завершении.

Если это тип данных **String** и значение превышает длину **VARCHAR**, то оно сопоставляется с **LONGVARCHAR**. Аналогичным образом **NVARCHAR** сопоставляется с **LONGNVARCHAR**, если значение превышает поддерживаемую длину **NVARCHAR**. То же относится и к **byte[]**. Значения, превышающие **VARBINARY**, становятся **LONGVARBINARY**.

Преобразования, поддерживаемые методами задания драйвера JDBC, делятся на две категории.

- **Без потерь (x)**. Преобразования для числовых случаев, когда тип задания является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода setBigDecimal для базового **десятичного** столбца сервера преобразование не потребуется. В случае преобразования числовых данных в символьные тип данных Java **numeric** преобразуется в **String**. Например, вызов метода setDouble со значением "53" относительно столбца varchar(50) формирует символьное значение "53" в целевом столбце.

- **С преобразованием (y)**. Преобразования из типа Java **numeric** в базовый тип сервера **numeric**, меньший по размеру. Такое преобразование выполняется обычным образом и следует соглашениям о преобразованиях в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Точные значения всегда усекаются (никогда не округляются), а переполнение выводит ошибку неподдерживаемого преобразования. Например, вызов метода updateDecimal со значением "1,9999" для базового целочисленного столбца приводит к сохранению в целевом столбце значения "1", но, если будет передано значение "3000000000", драйвер вызовет исключение.

- **В зависимости от данных (z)**. Преобразования из типа Java **String** в базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] зависят от следующих условий. Драйвер отправляет значение **String** на [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], а [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] при необходимости выполняет преобразование. Если sendStringParametersAsUnicode имеет значение true, а базовым типом данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] является **image**, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не выполнит преобразование **nvarchar** в **image** и вызовет исключение SQLServerException. Если параметр sendStringParametersAsUnicode установлен в значение false и базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] — **image**, то [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняет преобразование **varchar** в **image**, а исключение не вызывается.

[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняет преобразования и передает ошибки обратно драйверу JDBC, если возникают проблемы.

Если столбец [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] имеет тип данных **XML**, то значение данных должно быть допустимым **XML**. При вызове методов updateBytes, updateBinaryStream или updateBlob значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Пример:

```xml
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E
```

Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.

## <a name="conversions-on-setobject"></a>Преобразование относительно setObject

> [!NOTE]  
> Microsoft JDBC Driver 4.2 (и выше) для SQL Server поддерживает JDBC 4.1 и 4.2. Дополнительные сведения о сопоставлениях и преобразованиях типов данных 4.1 и 4.2 см. в статьях [Соответствие JDBC 4.1 для JDBC Driver](../../connect/jdbc/jdbc-4-1-compliance-for-the-jdbc-driver.md) и [Соответствие JDBC 4.2 для JDBC Driver](../../connect/jdbc/jdbc-4-2-compliance-for-the-jdbc-driver.md).

Для данных на языке Java, передаваемых методам setObject(\<Type>) класса [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md), применяются следующие виды преобразования.

![JDBCSetObjectConversions](../../connect/jdbc/media/jdbc_jdbcsetobjectconversions.gif "JDBCSetObjectConversions")

Метод setObject с неуказанным целевым типом использует сопоставление по умолчанию. Если это тип данных **String** и значение превышает длину **VARCHAR**, то оно сопоставляется с **LONGVARCHAR**. Аналогичным образом **NVARCHAR** сопоставляется с **LONGNVARCHAR**, если значение превышает поддерживаемую длину **NVARCHAR**. То же относится и к **byte[]**. Значения, превышающие **VARBINARY**, становятся **LONGVARBINARY**.

Преобразования, поддерживаемые методами setObject драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для числовых случаев, когда тип задания является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода setBigDecimal для базового **десятичного** столбца сервера преобразование не потребуется. В случае преобразования числовых данных в символьные тип данных Java **numeric** преобразуется в **String**. Например, вызов метода setDouble со значением "53" относительно столбца varchar(50) формирует символьное значение "53" в целевом столбце.

- **С преобразованием (y)**. Преобразования из типа Java **numeric** в базовый тип сервера **numeric**, меньший по размеру. Такое преобразование выполняется обычным образом и следует соглашениям о преобразованиях в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Точные значения всегда усекаются (никогда не округляются), а переполнение выводит ошибку неподдерживаемого преобразования. Например, вызов метода updateDecimal со значением "1,9999" для базового целочисленного столбца приводит к сохранению в целевом столбце значения "1", но, если будет передано значение "3000000000", драйвер вызовет исключение.

- **В зависимости от данных (z)**. Преобразования из типа Java **String** в базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] зависят от следующих условий. Драйвер отправляет значение **String** на [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], а [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] при необходимости выполняет преобразование. Если свойство подключения sendStringParametersAsUnicode имеет значение true, а базовым типом данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] является **image**, то [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не выполнит преобразование **nvarchar** в **image** и вызовет исключение SQLServerException. Если параметр sendStringParametersAsUnicode установлен в значение false и базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] — **image**, то [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняет преобразование **varchar** в **image**, а исключение не вызывается.

[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняет ряд заданных преобразований и передает ошибки обратно драйверу JDBC, если возникают проблемы. Преобразование на стороне клиента является исключением и выполняется только в случае значений **date**, **time**, **timestamp**, **Boolean** и **String**.

Если столбец [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] имеет тип данных **XML**, то значение данных должно быть допустимым **XML**. При вызове методов setObject(byte[], SQLXML), setObject(inputStream, SQLXML) или setObject(Blob, SQLXML) значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Пример:

```xml
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E
```

Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.

## <a name="see-also"></a>См. также раздел

[Основные сведения о типах данных JDBC Driver](../../connect/jdbc/understanding-the-jdbc-driver-data-types.md)
