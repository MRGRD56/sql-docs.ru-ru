---
title: Вызов хранимой процедуры (OLE DB)
description: Сведения о вызове хранимой процедуры в OLE DB Driver for SQL Server в том числе о способах передачи значений параметров.
ms.custom: ''
ms.date: 06/12/2018
ms.prod: sql
ms.prod_service: database-engine, sql-database, synapse-analytics, pdw
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
helpviewer_keywords:
- calling stored procedures
- RPC escape sequence
- OLE DB, stored procedures
- parameters [OLE DB Driver for SQL Server], OLE DB
- ODBC CALL escape sequence
- stored procedures [OLE DB], calling
- OLE DB Driver for SQL Server, stored procedures
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 601e2c07e7b2abb188e75ace02d1856945e0d689
ms.sourcegitcommit: 524a0f0cc9533188f4b14d2e78ba1cfe816b3b9a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2021
ms.locfileid: "105633303"
---
# <a name="calling-a-stored-procedure-ole-db"></a>Вызов хранимой процедуры (OLE DB)

[!INCLUDE [SQL Server](../../../includes/applies-to-version/sql-asdb-asdbmi-asa-pdw.md)]

[!INCLUDE[Driver_OLEDB_Download](../../../includes/driver_oledb_download.md)]

Хранимая процедура может иметь ноль и более параметров. Также она может возвращать значение. При использовании OLE DB Driver for SQL Server параметры хранимых процедур могут передаваться следующими способами.  
  
- Заданные в коде значения данных.
- Указание параметров с помощью маркера параметра (?), привязка программной переменной к маркеру параметра и последующее помещение значений данных в программную переменную.

> [!NOTE]
> При вызове хранимых процедур [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] с использованием именованных параметров в OLE DB имена параметров должны начинаться со знака \@. Это ограничение, характерное для [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]. В OLE DB Driver for SQL Server это ограничение соблюдается более строго, чем в компонентах MDAC.
  
Для поддержки параметров объект команды предоставляет интерфейс **ICommandWithParameters**. Чтобы использовать параметры, потребитель сначала описывает параметры поставщика путем вызова метода **ICommandWithParameters::SetParameterInfo** (или при необходимости готовит инструкцию, вызывающую метод **GetParameterInfo**). Затем потребитель создает метод доступа, определяющий структуру буфера и помещающий значения параметров в этот буфер. После этого он передает дескриптор метода доступа и указатель на буфер функции **Execute**. При последующих вызовах **Execute** потребитель помещает новые значения параметров в буфер и вызывает функцию **Execute** с дескриптором метода доступа и указателем буфера.

Команда, вызывающая временную хранимую процедуру, использующую параметры, сначала должна вызвать метод **ICommandWithParameters::SetParameterInfo** для определения сведений о параметрах. Этот вызов необходимо выполнить до успешной подготовки команды. Это требование связано с тем, что внутреннее имя временной хранимой процедуры отличается от внешнего имени, используемого клиентом. MSOLEDBSQL не может запрашивать системные таблицы, чтобы определить сведения о параметрах временной хранимой процедуры.

Далее приведены шаги процесса привязки параметров.

1. Внесите сведения о параметре (имя параметра, специфическое для поставщика имя типа данных параметра или стандартное имя типа данных и т. д.) в массив структур DBPARAMBINDINFO. Каждая структура в массиве описывает один параметр. Затем этот массив передается методу **SetParameterInfo**.
2. Вызовите метод **ICommandWithParameters::SetParameterInfo**, чтобы описать параметры для поставщика. Метод **SetParameterInfo** определяет собственный тип данных каждого параметра. Метод **SetParameterInfo** использует следующие аргументы.
    - Количество параметров, для которых задаются сведения о типе.
    - Массив порядковых номеров параметров, для которых задаются сведения о типе.
    - Массив структур DBPARAMBINDINFO.
3. Создайте метод доступа к параметру с помощью команды **IAccessor::CreateAccessor**. Метод доступа указывает структуру буфера и помещает в буфер значения параметров. Команда **CreateAccessor** создает метод доступа на основе набора привязок. Эти привязки описываются потребителем с помощью массива структур DBBINDING. Каждая привязка связывает отдельный параметр с буфером потребителя и содержит следующие сведения.
    - Порядковый номер параметра, к которому применяется привязка.
    - Что привязывается (значение данных, длина и состояние).
    - Смещение в буфере для каждой из этих частей.
    - Длина и тип значения данных в том виде, в котором оно представлено в буфере потребителя.

    Метод доступа определяется его дескриптором типа HACCESSOR. Это дескриптор возвращается методом **CreateAccessor**. Когда потребитель завершает использование метода доступа, он должен вызвать метод **ReleaseAccessor**, чтобы освободить занимаемую память.  
  
    Когда потребитель вызывает метод, например **ICommand::Execute**, он передает дескриптор методу доступа, а указатель непосредственно буферу. Поставщик использует этот метод доступа, чтобы определить способ передачи данных из буфера.
4. Заполните структуру DBPARAMS. Переменные потребителя, из которых берутся значения входных параметров и в которые записываются значения выходных параметров, передаются во время выполнения методу **ICommand::Execute** в структуре DBPARAMS. Структура DBPARAMS включает три следующих элемента.
    - Указатель на буфер, из которого поставщик получает данные входных параметров и в который возвращает данные выходных параметров в соответствии с привязками, указанными дескриптором метода доступа.
    - Количество наборов параметров в буфере.
    - Дескриптор метода доступа, созданный на шаге 3 .
5. Выполните команду с помощью метода **ICommand::Execute**.

## <a name="methods-of-calling-a-stored-procedure"></a>Методы вызова хранимых процедур

При выполнении хранимой процедуры в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] OLE DB Driver for SQL Server поддерживает следующие элементы.

- Escape-последовательность ODBC CALL.
- Escape-последовательность удаленного вызова процедур (RPC).
- Инструкция [!INCLUDE[tsql](../../../includes/tsql-md.md)] EXECUTE.

### <a name="odbc-call-escape-sequence"></a>escape-последовательность ODBC CALL  

Если известны сведения о параметре, вызовите метод **ICommandWithParameters::SetParameterInfo**, чтобы описать параметры для поставщика. В противном случае, если для вызова хранимой процедуры используется синтаксис ODBC CALL, поставщик вызывает вспомогательную функцию для поиска сведений о параметрах хранимой процедуры.

Если сведения о параметрах (метаданные параметров) точно неизвестны, рекомендуется применять синтаксис ODBC CALL.

Общий синтаксис для вызова процедуры с помощью escape-последовательности ODBC CALL выглядит следующим образом.

{[ **?=** ]**call**_procedure\_name_[ **(** [*parameter*][ **,** [_parameter_]]... **)** ]}

Пример:

```sql
{call SalesByCategory('Produce', '1995')}
```

### <a name="rpc-escape-sequence"></a>escape-последовательность RPC

Escape-последовательность RPC похожа на синтаксис ODBC CALL для вызова хранимой процедуры. Если нужно вызывать процедуру несколько раз, escape-последовательность RPC обеспечивает наиболее оптимальную производительность по сравнению со всеми тремя способами вызова хранимой процедуры.

Если escape-последовательность RPC используется для выполнения хранимой процедуры, поставщик не вызывает вспомогательные функции для определения сведений о параметре, как в случае применения синтаксиса ODBC CALL. Синтаксис RPC проще синтаксиса ODBC CALL, поэтому команда анализируется быстрее, что увеличивает производительность. В этом случае необходимо указать сведения о параметрах путем выполнения метода **ICommandWithParameters::SetParameterInfo**.

Escape-последовательность RPC требует наличия возвращаемого значения. Если хранимая процедура не возвращает значение, сервер по умолчанию возвращает 0. Кроме того, для хранимой процедуры нельзя открыть курсор [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]. Хранимая процедура подготавливается неявно, и вызов метода **ICommandPrepare::Prepare** завершится ошибкой. Запрашивать метаданные столбцов нельзя, поскольку невозможно подготовить вызов RPC. Методы IColumnsInfo::GetColumnInfo и IColumnsRowset::GetColumnsRowset будут возвращать значение DB_E_NOTPREPARED.

Если известны все метаданные параметров, для выполнения хранимых процедур рекомендуется использовать escape-последовательность RPC.

Далее приведен код SQL с примером escape-последовательности RPC для вызова хранимой процедуры.

```sql
{rpc SalesByCategory}
```

Пример приложения, которое демонстрирует применение escape-последовательности RPC, см. в статье [Выполнение хранимой процедуры с использованием RPC и обработка выходных данных](../ole-db-how-to/results/execute-stored-procedure-with-rpc-and-process-output.md).

### <a name="transact-sql-execute-statement"></a>Инструкция Transact-SQL EXECUTE

Escape-последовательность ODBC CALL и escape-последовательность RPC — это предпочтительные способы вызова хранимых процедур в отличие от инструкции [EXECUTE](../../../t-sql/language-elements/execute-transact-sql.md). В этом случае драйвер OLE DB для SQL Server использует механизм RPC в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], чтобы оптимизировать обработку команды. Этот протокол RPC повышает производительность, устраняя большую часть обработки параметров и синтаксической проверки инструкций на сервере.

Ниже приведен пример инструкции [!INCLUDE[tsql](../../../includes/tsql-md.md)] **EXECUTE** в SQL:

```sql
EXECUTE SalesByCategory 'Produce', '1995'
```

## <a name="see-also"></a>См. также раздел

[Хранимые процедуры](stored-procedures.md)
