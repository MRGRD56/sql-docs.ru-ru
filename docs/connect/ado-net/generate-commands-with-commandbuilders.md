---
title: Создание команд с помощью CommandBuilder
description: Узнайте, как использовать построители команд для автоматического создания команд INSERT, UPDATE и DELETE для `DataAdapter` с командой SELECT с одной таблицей.
ms.date: 11/25/2020
dev_langs:
- csharp
ms.assetid: 6e3fb8b5-373b-4f9e-ab03-a22693df8e91
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.topic: conceptual
author: David-Engel
ms.author: v-daenge
ms.reviewer: v-chmalh
ms.openlocfilehash: 091f7c2736c240951beb0f434fdcd2efb39a9b59
ms.sourcegitcommit: debaff72dbfae91b303f0acd42dd6d99e03135a2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "96428304"
---
# <a name="generating-commands-with-commandbuilders"></a>Создание команд с помощью CommandBuilder

[!INCLUDE[appliesto-netfx-netcore-netst-md](../../includes/appliesto-netfx-netcore-netst-md.md)]

[!INCLUDE[Driver_ADONET_Download](../../includes/driver_adonet_download.md)]

Если свойство `SelectCommand` объекта <xref:System.Data.Common.DbDataAdapter> динамически указывается во время выполнения, например с помощью средства запроса, которое принимает текстовую команду от пользователя, вы, возможно, не сможете указать соответствующие `InsertCommand`, `UpdateCommand` или `DeleteCommand` во время разработки. Если <xref:System.Data.DataTable> сопоставляется с одной таблицей базы данных или создается из нее, то можно воспользоваться преимуществом объекта <xref:System.Data.Common.DbCommandBuilder> для автоматического создания сущностей `DeleteCommand`, `InsertCommand` и `UpdateCommand` объекта <xref:System.Data.Common.DbDataAdapter>.

> [!NOTE]
> В поставщике данных Microsoft SqlClient для SQL Server класс <xref:Microsoft.Data.SqlClient.SqlDataAdapter> является производным от класса <xref:System.Data.Common.DbDataAdapter>, а класс <xref:Microsoft.Data.SqlClient.SqlCommandBuilder> — производным от класса <xref:System.Data.Common.DbCommandBuilder>.

Минимальным требованием для работы автоматического создания команд является задание свойства `SelectCommand`. Схема таблицы, получаемая свойством `SelectCommand`, определяет синтаксис автоматически созданных инструкций INSERT, UPDATE и DELETE.

Для возврата метаданных, необходимых для создания команд INSERT, UPDATE и DELETE SQL, объект <xref:System.Data.Common.DbCommandBuilder> должен выполнить команду `SelectCommand`. В результате необходим дополнительный цикл приема-передачи с источником данных, что может снизить производительность. Для достижения оптимальной производительности вместо использования <xref:System.Data.Common.DbCommandBuilder> следует задать команды явным образом.

> [!NOTE]
> Свойство `SelectCommand` должно также возвратить по крайней мере один столбец первичного ключа или столбец с атрибутом UNIQUE. В противном случае вызывается исключение `InvalidOperation` и команды не создаются.

При наличии связи с `DataAdapter` объект <xref:System.Data.Common.DbCommandBuilder> автоматически создает свойства `InsertCommand`, `UpdateCommand` и `DeleteCommand` объекта `DataAdapter`, если они являются пустыми ссылками. Если для свойства уже существует `Command`, используется существующая `Command`.

Представления базы данных, созданные соединением двух или более таблиц, не считаются одной таблицей базы данных. В этом экземпляре нельзя использовать <xref:System.Data.Common.DbCommandBuilder> для автоматического создания команд. Вам нужно явно указать свои команды.

Может потребоваться сопоставить выходные параметры с обновленной строкой `DataSet`. Одной общей задачей будет извлечение значения автоматически созданного поля идентификатора или временной метки из источника данных. <xref:System.Data.Common.DbCommandBuilder> по умолчанию не будет сопоставлять выходные параметры со столбцами обновленной строки. В этом экземпляре нужно явно указать команду.

## <a name="rules-for-automatically-generated-commands"></a>Правила для автоматически создаваемых команд

В следующей таблице показаны правила создания автоматически созданных команд.

|Команда|Правило|  
|-------------|----------|  
|`InsertCommand`|Выполняет операцию вставки строки в источнике данных для всех строк таблицы со свойством <xref:System.Data.DataRow.RowState%2A> равным <xref:System.Data.DataRowState.Added>. Вставляет значения для всех обновляемых столбцов (за исключением идентификаторов, выражений или временных меток).|  
|`UpdateCommand`|Выполняет обновление строк в источнике данных для всех строк таблицы со свойством `RowState` равным <xref:System.Data.DataRowState.Modified>. Обновляет значения всех столбцов, за исключением столбцов, которые не являются обновляемыми, например идентификаторов или выражений. Обновляет все строки, в которых значения столбцов в источнике данных совпадают со значениями столбцов первичных ключей строки и в которых оставшиеся в источнике данных столбцы совпадают с исходными значениями строки. Дополнительные сведения см. в подразделе «Модель оптимистичного параллелизма для обновлений и удалений» далее в этом разделе.|  
|`DeleteCommand`|Выполняет операцию удаления строки в источнике данных для всех строк таблицы, у которых свойство `RowState` равно <xref:System.Data.DataRowState.Deleted>. Удаляет все строки, в которых значения столбцов совпадают со значениями столбцов первичных ключей строки и в которых оставшиеся в источнике данных столбцы совпадают с исходными значениями строки. Дополнительные сведения см. в разделе [Модель оптимистической блокировки для операций обновления и удаления](#optimistic-concurrency-model-for-updates-and-deletes) далее в этой статье.|

## <a name="optimistic-concurrency-model-for-updates-and-deletes"></a>Модель оптимистической блокировки для операций обновления и удаления

Логика автоматического создания команд для инструкций UPDATE и DELETE базируется на модели *оптимистической блокировки*, когда записи не блокируются для редактирования и могут быть в любое время изменены другими пользователями или процессами. Вследствие того что запись можно изменить после ее возврата из инструкции SELECT, но до вызова инструкции UPDATE или DELETE, автоматически созданная инструкция UPDATE или DELETE содержит предложение WHERE, указывающее на то, что строка обновляется только в случае наличия в ней всех исходных значений и она не была удалена из источника данных. Это делается во избежание перезаписи новых данных.
 
> [!NOTE]
> Когда автоматически созданное обновление пытается обновить строку, которая была удалена или не содержит исходные значения, найденные в <xref:System.Data.DataSet>, команда не изменяет записи и вызывается исключение <xref:System.Data.DBConcurrencyException>.

Если требуется выполнить инструкцию UPDATE или DELETE независимо от исходных значений, необходимо явно задать свойство `UpdateCommand` для `DataAdapter` и не полагаться на автоматическое создание команд.

## <a name="limitations-of-automatic-command-generation-logic"></a>Ограничения логики автоматического создания команд

На автоматическое создание команд накладываются следующие ограничения.

### <a name="unrelated-tables-only"></a>Только несвязанные таблицы

Логика автоматического создания команд создает инструкции INSERT, UPDATE или DELETE для изолированных таблиц, не принимая во внимание связи с другими таблицами в источнике данных. В результате при вызове `Update` для отправки изменений столбца, участвующего в ограничении внешнего ключа базы данных, может произойти ошибка. Чтобы избежать этого исключения, не следует использовать <xref:System.Data.Common.DbCommandBuilder> для обновления столбцов, вовлеченных в ограничение внешнего ключа. Вместо этого нужно явно задать инструкции, используемые для выполнения операции.

### <a name="table-and-column-names"></a>Имена таблиц и столбцов

Логика автоматического создания команд может дать сбой при наличии в именах столбцов или таблиц любых специальных символов, например пробелов, точек, двойных кавычек или других символов, отличных от буквенно-цифровых, даже отделенных квадратными скобками. В зависимости от поставщика, задавая параметры QuotePrefix и QuoteSuffix, можно дать возможность логике создания обрабатывать пробелы, но для специальных символов это не сработает. Поддерживаются полностью указанные имена таблиц в виде *catalog.schema.table*.

## <a name="using-the-commandbuilder-to-automatically-generate-an-sql-statement"></a>Использование CommandBuilder для автоматического создания инструкции SQL

Чтобы автоматически создать инструкции SQL для `DataAdapter`, сначала следует установить его свойство `SelectCommand`, затем создать объект `DataAdapter` и в качестве аргумента, для которого `CommandBuilder` автоматически создаст инструкции SQL, указать `DataAdapter`.

[!code-csharp[SqlCommandBuilder_Create#1](~/../sqlclient/doc/samples/SqlCommandBuilder_Create.cs#1)]

## <a name="modifying-the-selectcommand"></a>Изменение SelectCommand

При изменении свойства `CommandText`, принадлежащего свойству `SelectCommand`, после автоматического создания команд INSERT, UPDATE или DELETE может возникнуть исключение. Если измененное свойство `SelectCommand.CommandText` содержит сведения о схеме, которые не согласованы с используемыми `SelectCommand.CommandText` сведениями при автоматическом создании команд INSERT, UPDATE или DELETE, то последующие вызовы к методу `DataAdapter.Update` могут содержать попытки обращения к столбцам, которых больше нет в текущей таблице, на которую ссылается `SelectCommand`, и в этом случае возникнет исключение.

Для обновления сведений о схеме, используемой `CommandBuilder` для автоматического создания команд, следует вызвать метод `RefreshSchema` объекта `CommandBuilder`.

Чтобы узнать, какая команда была автоматически создана, необходимо с помощью методов `GetInsertCommand`, `GetUpdateCommand` и `GetDeleteCommand` объекта `CommandBuilder` получить ссылку на автоматически созданные команды и проверить свойство `CommandText`, соответствующее команде.

Следующий пример кода записывает в консоль автоматически созданную команду UPDATE.

[!code-csharp[SqlCommandBuilder_Create#2](~/../sqlclient/doc/samples/SqlCommandBuilder_Create.cs#2)]

В следующем примере создается таблица в наборе данных. Метод **RefreshSchema** вызывается для внесения новых сведений о столбцах в автоматически созданные команды.

[!code-csharp[SqlCommandBuilder_Create#3](~/../sqlclient/doc/samples/SqlCommandBuilder_Create.cs#3)]

## <a name="see-also"></a>См. также

- [Команды и параметры](commands-parameters.md)
- [Выполнение команды](execute-command.md)
