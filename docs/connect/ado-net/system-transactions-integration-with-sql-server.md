---
title: Интеграция System.Transactions с SQL Server
description: Описывает интеграцию System.Transactions с SQL Server для работы с распределенными транзакциями.
ms.date: 11/25/2020
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.topic: conceptual
author: David-Engel
ms.author: v-daenge
ms.reviewer: v-chmalh
ms.openlocfilehash: af0ba2865719a5388314a4ca695e09191cb56173
ms.sourcegitcommit: 2add15a99df7b85d271adb261523689984dfd134
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2020
ms.locfileid: "97051377"
---
# <a name="systemtransactions-integration-with-sql-server"></a>Интеграция System.Transactions с SQL Server

[!INCLUDE[appliesto-netfx-netcore-netst-md](../../includes/appliesto-netfx-netcore-netst-md.md)]

[!INCLUDE[Driver_ADONET_Download](../../includes/driver_adonet_download.md)]

Платформа .NET включает новую платформу транзакций, к которой можно обращаться через пространство имен <xref:System.Transactions>. Эта платформа предоставляет транзакции в полностью интегрированном с .NET виде, включая ADO.NET.  
  
Помимо улучшенных способов программирования, <xref:System.Transactions> и ADO.NET могут работать вместе для координации оптимизации при работе с транзакциями. Повышаемая транзакция — это упрощенная (локальная) транзакция, которая по необходимости может быть автоматически повышена до полностью распределенной транзакции.

Поставщик данных Microsoft SqlClient для SQL Server поддерживает повышаемые транзакций при работе с SQL Server. Повышаемая транзакция не вызывает дополнительную нагрузку распределенной транзакции, если таковая не требуется. Повышаемые транзакции выполняются автоматически и не требуют вмешательства разработчика.

## <a name="creating-promotable-transactions"></a>Создание повышаемых транзакций

Поставщик данных Microsoft SqlClient для SQL Server обеспечивает поддержку повышаемых транзакций, которые обрабатываются с помощью классов в пространстве имен <xref:System.Transactions>. Повышаемые транзакции оптимизируют работу с распределенными транзакциями за счет отсрочки создания распределенной транзакции до того момента, когда она будет необходима. Если требуется только один диспетчер ресурсов, то распределенная транзакция не создается.

> [!NOTE]
> В частично доверенном сценарии при повышении транзакции до распределенной требуется право доступа <xref:System.Transactions.DistributedTransactionPermission> .

## <a name="promotable-transaction-scenarios"></a>Сценарии применения повышаемых транзакций

Как правило, для распределенных транзакций требуются значительные системные ресурсы, поскольку они управляются координатором распределенных транзакций (Майкрософт), который интегрирует все диспетчеры ресурсов, используемые в транзакции. Повышаемая транзакция — это особая форма транзакции <xref:System.Transactions>, эффективно делегирующая работу простой транзакции SQL Server. <xref:System.Transactions>, <xref:Microsoft.Data.SqlClient> и SQL Server координируют работу, выполняемую при обработке транзакции, при необходимости повышая ее до полностью распределенной транзакции.

Преимущество использования повышаемых транзакций заключается в том, что при открытии соединения с помощью активной транзакции <xref:System.Transactions.TransactionScope> и отсутствии других открытых соединений такая транзакция фиксируется как упрощенная, что позволяет избежать излишних затрат ресурсов на полностью распределенную транзакцию.

### <a name="connection-string-keywords"></a>Ключевые слова в строке подключения

В свойстве <xref:Microsoft.Data.SqlClient.SqlConnection.ConnectionString%2A> поддерживается использование ключевого слова `Enlist`, которое указывает, будет ли клиент <xref:Microsoft.Data.SqlClient> обнаруживать контексты транзакций и автоматически прикреплять соединение к распределенной транзакции. Если `Enlist=true`, то соединение автоматически прикрепляется к текущему контексту транзакции открывающего потока. Если `Enlist=false`, то соединение `SqlClient` не будет взаимодействовать с распределенной транзакцией. Значение `Enlist` по умолчанию - true. Если ключевое слово `Enlist` в строке соединения не задано, то соединение автоматически прикрепляется к распределенной транзакции, если она будет обнаружена при открытии соединения.

Ключевые слова `Transaction Binding` в строке соединения <xref:Microsoft.Data.SqlClient.SqlConnection> управляют связью соединения с прикрепленной транзакцией `System.Transactions` . Эта связь также доступна через свойство <xref:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding%2A> построителя <xref:Microsoft.Data.SqlClient.SqlConnectionStringBuilder>.

В следующей таблице описаны возможные значения.
  
|Ключевое слово|Описание|  
|-------------|-----------------|  
|Implicit Unbind|Это значение используется по умолчанию. Соединение отсоединяется от транзакции по ее завершении, вновь переходя в режим автоматической фиксации.|
|Explicit Unbind|Соединение остается прикрепленным к транзакции до ее закрытия. Соединение будет потеряно, если связанная с ним транзакция не активна или не соответствует <xref:System.Transactions.Transaction.Current%2A>.|

## <a name="using-transactionscope"></a>Использование класса TransactionScope

Класс <xref:System.Transactions.TransactionScope> делает блок кода транзакционным, неявно прикрепляя соединения к распределенной транзакции. В конце блока <xref:System.Transactions.TransactionScope.Complete%2A> перед тем, как выйти из него, необходимо вызвать метод <xref:System.Transactions.TransactionScope> . При выходе из этого блока вызывается метод <xref:System.Transactions.TransactionScope.Dispose%2A> . При возникновении исключения, в результате которого исполнение кода выходит за пределы области, транзакция считается прерванной.

Рекомендуется использовать блок `using` , чтобы гарантировать вызов метода <xref:System.Transactions.TransactionScope.Dispose%2A> для объекта <xref:System.Transactions.TransactionScope> при выходе из блока using. Неудачная попытка зафиксировать или откатить незавершенные транзакции может значительно снизить производительность, поскольку время ожидания по умолчанию для объекта <xref:System.Transactions.TransactionScope> составляет одну минуту. Если инструкция `using` не используется, необходимо явно выполнить все действия в блоке `Try` и вызвать метод <xref:System.Transactions.TransactionScope.Dispose%2A> в блоке `Finally`.

Если в объекте <xref:System.Transactions.TransactionScope>возникает исключение, транзакция помечается как несогласованная и прерывается. При удалении объекта <xref:System.Transactions.TransactionScope> будет произведен ее откат. Если исключений не возникает, то участвующие транзакции будут зафиксированы.

> [!NOTE]
> Класс `TransactionScope` создает транзакцию с уровнем изоляции <xref:System.Transactions.Transaction.IsolationLevel%2A>, равным `Serializable` по умолчанию. В зависимости от приложения уровень изоляции можно понижать во избежание большого количества состязаний данных в приложении.

> [!NOTE]
> В рамках распределенных транзакций рекомендуется выполнять только операции обновления, вставки и удаления, поскольку они потребляют значительные ресурсы базы данных. Инструкции выборки могут без необходимости блокировать ресурсы базы данных, и в некоторых случаях для выборки может потребоваться использование транзакций. Любые не связанные с базой данных действия должны выполняться за пределами области транзакции, если только в ней не задействованы другие диспетчеры ресурсов транзакций.
Хотя исключение в области транзакции не позволяет зафиксировать транзакцию, класс <xref:System.Transactions.TransactionScope> не имеет возможности отката каких-либо изменений, внесенных кодом за пределами области самой транзакции. При необходимости предпринять какие-либо действия, когда производится откат транзакции, следует написать собственную реализацию интерфейса <xref:System.Transactions.IEnlistmentNotification> и явно прикрепить его к транзакции.

## <a name="example"></a>Пример

Для работы с <xref:System.Transactions> необходима ссылка на файл System.Transactions.dll.

Следующая функция показывает, как создать повышаемую транзакцию для двух разных экземпляров SQL Server, представленных двумя разными объектами <xref:Microsoft.Data.SqlClient.SqlConnection> , которые заключены в оболочку с помощью блок <xref:System.Transactions.TransactionScope> .

В приведенном ниже коде создается блок <xref:System.Transactions.TransactionScope> с инструкцией `using` и открывается первое соединение, которое автоматически прикрепляет транзакцию к блоку <xref:System.Transactions.TransactionScope>.

Изначально транзакция прикрепляется как упрощенная, а не полностью распределенная транзакция. Второе соединение прикрепляется к транзакции <xref:System.Transactions.TransactionScope> , только если при выполнении команды в первом соединении не возникает исключения. При открытии второго соединения транзакция автоматически повышается до полностью распределенной.

Позднее вызывается метод <xref:System.Transactions.TransactionScope.Complete%2A>, который фиксирует транзакцию только в том случае, если не были созданы исключения. Если в любой точке блока <xref:System.Transactions.TransactionScope> возникло исключение, метод `Complete` вызван не будет и при удалении транзакции <xref:System.Transactions.TransactionScope> в конце ее блока `using` будет произведен откат распределенной транзакции.

[!code-csharp[SqlTransactionScope#1](~/../sqlclient/doc/samples/SqlTransactionScope.cs#1)]

## <a name="see-also"></a>См. также раздел

- [Транзакции и параллельность](transactions-and-concurrency.md)
- [Microsoft ADO.NET для SQL Server](microsoft-ado-net-sql-server.md)
