---
title: Правила приведения типов в XQuery | Документация Майкрософт
description: Сведения о правилах, применяемых при явном или неявном приведении одного типа данных к другому в XQuery.
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: sql
ms.reviewer: ''
ms.technology: xml
ms.topic: language-reference
dev_langs:
- XML
helpviewer_keywords:
- XQuery, type casting
- casting rules [XML in SQL Server]
- explicit casting [SQL Server]
- type casting rules [XML in SQL Server]
- cast as operator
- implicit casting
ms.assetid: f2e91306-2b1b-4e1c-b6d8-a34fb9980057
author: rothja
ms.author: jroth
ms.openlocfilehash: 0cd4a68b21ae23b60c2bea5618308c0d13300cab
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "100353274"
---
# <a name="type-casting-rules-in-xquery"></a>Правила приведения типов в запросах XQuery
[!INCLUDE [SQL Server Azure SQL Database ](../includes/applies-to-version/sqlserver.md)]

  В следующей диаграмме спецификаций функций и операторов языков W3C XQuery 1.0 и XPath 2.0 показаны встроенные типы данных. К ним относятся встроенные примитивные и встроенные производные типы.  
  
 ![Иерархия типов XQuery 1.0](../xquery/media/xquery-typing-rules.gif "Иерархия типов XQuery 1.0")  
  
 В этом разделе описаны правила приведения типов, применяемые при приведении одного типа к другому с помощью одного из следующих методов.  
  
-   Явное приведение с помощью функции **Cast как** или функций конструктора типа (например, `xs:integer("5")` ).  
  
-   Неявное приведение, выполняемое в процессе повышения типов.  
  
## <a name="explicit-casting"></a>Явное приведение  
 В следующей таблице показано разрешенное приведение встроенных примитивных типов друг к другу.  
  
 ![Описывает правила приведения типов языка XQuery.](../xquery/media/casting-builtin-types.gif "Описывает правила приведения типов языка XQuery.")  
  
-   Встроенный примитивный тип может быть приведен к другому встроенному примитивному типу на основе правил, указанных в таблице.  
  
-   Примитивный тип может быть приведен к любому производному от него типу. Например, можно выполнить приведение из **xs: decimal** в **xs: integer** или из **xs: decimal** в **xs: long**.  
  
-   Производный тип может быть приведен к любому типу, являющемуся его предком в иерархии типов, вплоть до его встроенного примитивного базового типа. Например, можно выполнить приведение типа **xs: Token** к **типу xs: normalizedString** или к **типу xs: String**.  
  
-   Производный тип может быть приведен к примитивному типу в случае, если его примитивный тип-предок может быть приведен к целевому типу. Например, можно привести тип **xs: integer**, производный от типа **xs: String** **, тип**-примитив, который может быть приведен к **типу xs:** **Decimal**.  
  
-   Производный тип может быть приведен к другому производному типу, если примитивный тип-предок исходного типа может быть приведен к примитивному типу-предку целевого типа. Например, можно выполнить приведение типа **xs: integer** к **типу xs: Token**, так как вы можете привести его из **xs: decimal** в **xs: String**.  
  
-   Правила приведения определяемых пользователем типов к встроенным являются теми же, что и для встроенных типов. Например, можно определить тип **минтежер** , производный от типа **xs: integer** . Затем **минтежер** можно привести к типу **xs: Token**, поскольку **xs: decimal** можно привести к типу **xs: String**.  
  
 Следующие способы приведения типов не поддерживаются.  
  
-   Приведение к списковым типам или списковых типов к другим недопустимо. К ним относятся как пользовательские типы списков, так и встроенные типы списков, такие как **xs: IDREFS**, **xs: Entities** и **xs: NMTOKENS**.  
  
-   Приведение к **типу xs: QName** или из него не поддерживается.  
  
-   **xs: Notation** и полностью упорядоченные подтипы Duration, **xdt: еармонсдуратион** и **xdt: dayTimeDuration** не поддерживаются. В результате приведение к этим типам или этих типов к другим не поддерживается.  
  
 В следующих примерах показано явное приведение типов.  
  
### <a name="example-a"></a>Пример A  
 В следующем примере запрашивается переменная XML-типа. Запрос возвращает последовательность значения простого типа, типизированного как xs:string.  
  
```  
declare @x xml  
set @x = '<e>1</e><e>2</e>'  
select @x.query('/e[1] cast as xs:string?')  
go  
```  
  
### <a name="example-b"></a>Пример Б  
 В следующем примере запрашивается типизированная переменная типа XML. Сначала создается коллекция XML-схем. Затем эта коллекция используется для создания типизированной переменной типа XML. В схеме содержатся сведения о типизации для экземпляра XML, назначенного переменной. После этого запросы направляются к данной переменной.  
  
```  
create xml schema collection myCollection as N'  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">  
      <xs:element name="root">  
            <xs:complexType>  
                  <xs:sequence>  
                        <xs:element name="A" type="xs:string"/>  
                        <xs:element name="B" type="xs:string"/>  
                        <xs:element name="C" type="xs:string"/>  
                  </xs:sequence>  
            </xs:complexType>  
      </xs:element>  
</xs:schema>'  
go  
```  
  
 Следующий запрос возвращает статическую ошибку, так как неизвестно, сколько элементов верхнего уровня <`root`> в экземпляре документа.  
  
```  
declare @x xml(myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>  
          <root><A>4</A><B>5</B><C>6</baz></C>'  
select @x.query('/root/A cast as xs:string?')  
go  
```  
  
 Если указать в выражении одноэлементный <`root`>, запрос будет выполнен. Запрос возвращает последовательность значения простого типа, типизированного как xs:string.  
  
```  
declare @x xml(myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>  
              <root><A>4</A><B>5</B><C>6</C></root>'  
select @x.query('/root[1]/A cast as xs:string?')  
go  
```  
  
 В следующем примере переменная XML-типа содержит ключевое слово document, указывающее на коллекцию XML-схем. Это слово указывает, что экземпляр XML должен представлять собой документ с одиночным элементом верхнего уровня. Если вы создаете `root` в экземпляре XML два элемента <>, он вернет ошибку.  
  
```  
declare @x xml(document myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>  
              <root><A>4</A><B>5</B><C>6</C></root>'  
go  
```  
  
 Можно изменить экземпляр таким образом, чтобы он содержал только один элемент верхнего уровня, и запрос будет работать. Запрос вновь возвращает последовательность значения простого типа, типизированного как xs:string.  
  
```  
declare @x xml(document myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>'  
select @x.query('/root/A cast as xs:string?')  
go  
```  
  
## <a name="implicit-casting"></a>Неявное приведение  
 Неявное приведение разрешено только для числовых типов и нетипизированных атомарных типов. Например, следующая функция **min ()** возвращает минимальное из двух значений:  
  
```  
min(xs:integer("1"), xs:double("1.1"))  
```  
  
 В этом примере два значения, передаваемые функции XQuery **min ()** , имеют разные типы. Таким образом, неявное преобразование выполняется, когда **целочисленный** тип повышается до **Double** и сравниваются два значения типа **double** .  
  
 Повышение типов, описанное в данном примере, выполняется по следующим правилам.  
  
-   Встроенный производный числовой тип можно повышать до его базового типа. Например, **целое число** можно повысить до **десятичного**.  
  
-   **Десятичный** тип может быть повышен до **float,** а тип **float** может быть повышен до **Double**.  
  
 Так как неявное приведение допустимо только для числовых типов, следующие операции недопустимы.  
  
-   Неявное приведение строковых типов недопустимо. Например, если ожидается два **строковых** типа и вы передаете **строку** и **маркер**, неявное приведение не происходит и возвращается ошибка.  
  
-   Неявное приведение числовых типов к строковым недопустимо. Например, в случае передачи значения целого типа функции, принимающей параметр строкового типа, неявное приведение выполняться не будет, и будет возвращена ошибка.  
  
## <a name="casting-values"></a>Приведение значений  
 При приведении одного типа к другому фактические значения трансформируются из пространства значений исходного типа в пространство значений целевого типа. Например, при приведении значения типа xs:decimal к типу xs:double значение decimal будет преобразовано в значение double.  
  
 Ниже приведены некоторые правила преобразования.  
  
##### <a name="casting-a-value-from-a-string-or-untypedatomic-type"></a>Приведение значения типа string или untypedAtomic к другому типу  
 Значение, которое приводится к типу string или untypedAtomic, преобразуется таким же образом, что и при проверке значения на основе правил целевого типа. Сюда входят правила сопоставления с ожидаемым шаблоном и обработки пробелов. Например, следующая операция завершится успехом, а результатом ее будет значение типа double 1.1e0:  
  
 `xs:double("1.1")`  
  
 При приведении типов string или untypedAtomic к двоичным типам, например xs:base64Binary или xs:hexBinary, входные значения должны быть закодированы по алгоритму base64 или hex соответственно.  
  
##### <a name="casting-a-value-to-a-string-or-untypedatomic-type"></a>Приведение значения к типу string или untypedAtomic  
 При приведении значения к типу string или untypedAtomic оно будет преобразовано в свое каноническое лексическое представление в языке XQuery. Конкретно это означает, что значение, которое при вводе укладывалось в заданный шаблон или другое ограничение, не будет представлено в соответствии с данным ограничением.  Чтобы информировать пользователей об этом, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] типы флагов, в которых ограничение типа может стать проблемой, выдавая предупреждение при загрузке этих типов в коллекцию схем.  
  
 При приведении значения типа xs:float к типу xs:double или какому-либо из его подтипов, к типу string или untypedAtomic, значение будет представлено в экспоненциальной записи. Это производится только в случае, если абсолютное значение данного значения меньше 1.0E-6 или же больше или равно 1.0E6. Таким образом, 0 сериализуется в экспоненциальном представлении в форме 0.0E0.  
  
 Например, операция `xs:string(1.11e1)` возвращает строковое значение `"11.1"`, в то время как операция `xs:string(-0.00000000002e0)` возвращает строковое значение `"-2.0E-11"`.  
  
 При приведении двоичных типов, например xs:base64Binary или xs:hexBinary, к типу string или untypedAtomic, двоичные значения будут представлены в закодированной форме по алгоритму base64 или hex соответственно.  
  
##### <a name="casting-a-value-to-a-numeric-type"></a>Приведение значения к числовому типу  
 При приведении значения одного числового типа к значению другого числового типа оно отображается из одного пространства значений в другое без строковой сериализации. Если значение не удовлетворяет ограничениям целевого типа, применяются следующие правила.  
  
-   Если исходное значение уже является числовым, а целевой тип — xs:float либо его подтип, для которого допустимы значения -INF и INF, и приведение исходного числового значения к целевому типу вызовет переполнение, значение сопоставляется с INF, если оно положительное, и с -INF — если отрицательное. Если для целевого типа недопустимы значения INF и -INF и может произойти переполнение, приведение завершается неудачей и SQL Server выдает в качестве результата пустую последовательность.  
  
-   Если исходное значение уже является числовым, а целевой тип — числовой и его диапазон приемлемых значений включает 0, -0e0 или 0e0 и приведение исходного числового значения к целевому типу вызовет потерю точности, сопоставление значения выполняется следующим образом.  
  
    -   Для десятичного целевого типа значению сопоставляется 0.  
  
    -   В случае потери точности отрицательного значения ему сопоставляется -0e0.  
  
    -   В случае потери точности положительного значения для целевого типа с плавающей точкой или с двойной точностью ему сопоставляется 0e0.  
  
     Если в пространство значений целевого типа не входит ноль, приведение завершается неудачей, а результатом является пустая последовательность.  
  
     Обратите внимание, что при приведении значения к двоичному типу с плавающей запятой, например xs:float, xs:double или любому из их подтипов, точность может снизиться.  
  
## <a name="implementation-limitations"></a>Ограничения реализации  
 Существуют следующие ограничения:  
  
-   Значение NaN (нечисловое) с плавающей запятой не поддерживается.  
  
-   На значения, доступные для приведения, накладываются ограничения реализации целевых типов. Например, нельзя привести строку даты с отрицательным годом к **типу xs: Date**. Если значение предоставляется во время выполнения, результатом такого приведения будет пустая последовательность (а не ошибка времени выполнения).   
  
## <a name="see-also"></a>См. также:  
 [Определение сериализации XML-данных](../relational-databases/xml/define-the-serialization-of-xml-data.md)  
  
  
