---
title: XQuery и статическая типизация | Документация Майкрософт
description: Сведения о выводе статического типа и проверке статических типов в XQuery.
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.prod_service: sql
ms.reviewer: ''
ms.technology: xml
ms.topic: language-reference
dev_langs:
- XML
helpviewer_keywords:
- XQuery, static typing
- static typing
- checking static types
- inference [XQuery]
ms.assetid: d599c791-200d-46f8-b758-97e761a1a5c0
author: rothja
ms.author: jroth
ms.openlocfilehash: 6dcaa7bbbd5674c6db3b6d8ec5185cc31e890707
ms.sourcegitcommit: 917df4ffd22e4a229af7dc481dcce3ebba0aa4d7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "100352309"
---
# <a name="xquery-and-static-typing"></a>XQuery и статическая типизация
[!INCLUDE [SQL Server Azure SQL Database ](../includes/applies-to-version/sqlserver.md)]

  В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] XQuery является языком со статической типизацией. Это означает, что при компиляции запросов, если выражение возвращает значение, тип или количество элементов которого неприемлемы для указанной функции или оператора, будет выдана ошибка преобразования типов. В дополнение к этому статическая проверка типов может также обнаружить несоответствие типа выражения пути в типизированном документе XML. Компилятор XQuery сначала применяет фазу нормализации, во время которой добавляются неявные операции (например атомизация), а затем производит статический вывод и статическую проверку типов.  
  
## <a name="static-type-inference"></a>Статический вывод типов  
 Во время операции вывода статического типа определяется тип возвращаемого значения выражения. Для этого берутся статические типы входных параметров и статическая семантика операции и выводится статический тип результата. Например статический тип выражения «1 + 2.3» определяется следующим образом.  
  
-   Статический тип 1 — **xs: integer** , а статический тип 2,3 — **xs: decimal**. Основываясь на динамической семантике, статическая семантика **+** операции Преобразует целое число в десятичное, а затем возвращает десятичное число. Выводимый статический тип затем будет **xs: decimal**.  
  
 Для нетипизированных экземпляров XML имеются специальные типы, обозначающие, что данные нетипизированы. Эти сведения используются при статической проверке типов и для неявного приведения некоторых типов.  
  
 Для типизированных данных входной тип выводится из коллекции XML-схем, ограничивающей экземпляр типа данных XML. Например, если схема допускает только элементы типа **xs: integer**, результаты выражения пути, использующего этот элемент, будут содержать ноль или более элементов типа **xs: integer**. В настоящее время оно выражается с помощью выражения, например, `element(age,xs:integer)*` где звездочка ( \* ) указывает количество элементов результирующего типа. В этом примере выражение может привести к появлению нуля или более элементов с именем age и Type **xs: integer**. Другие кратности являются ровно единицами и выражаются с использованием только имени типа, нуля или единицы и выражения с вопросительным знаком (**?**) и 1 или более и выражаются с помощью знака плюс ( **+** ).  
  
 Иногда вывод статического типа может определить, что выражение всегда возвращает пустую последовательность. Например, если выражение пути для типизированного типа данных XML выполняет поиск \<name> элемента внутри \<customer> элемента (/Кустомер/наме), но схема не разрешает \<name> внутри \<customer> , вывод статического типа определит, что результат будет пустым. Он будет использоваться для обнаружения неверных запросов и будет отображаться как статическая ошибка, если только выражение не имело значение () или **данные (())**.  
  
 Подробное описание правил вывода содержится в формальной семантике спецификации XQuery. Корпорация Майкрософт только незначительно изменила их для работы с типизированными экземплярами типа данных XML. Наиболее важное отличие от стандарта заключается в том, что неявный узел документа знает тип данных экземпляра XML. Поэтому выражение пути в форме «/age» на основе этих сведений будет точно типизировано.  
  
 Используя [шаблоны SQL Server Profiler и разрешения](../tools/sql-server-profiler/sql-server-profiler-templates-and-permissions.md), можно увидеть статические типы, возвращаемые в составе компиляций запросов. Чтобы просмотреть их, трассировка должна включать событие XQuery Static Type в категории событий TSQL.  
  
## <a name="static-type-checking"></a>Статическая проверка типов  
 Статическая проверка типов гарантирует, что на стадии выполнения операции будут переданы только те значения, которые имеют соответствующие типы данных. Поскольку эти типы на стадии выполнения не надо проверять, потенциальные ошибки могут быть обнаружены на ранней стадии компиляции,  что позволяет повысить производительность. Однако статическая типизация требует точности формулировок при написании запроса.  
  
 Ниже приведены все применимые типы:  
  
-   типы, явно допустимые для функции или операции;  
  
-   подтипы явно допустимых типов.  
  
 Подтипы определяются на основе правил создания подтипов XML-схемы при наследовании по ограничению или по расширению. Например, тип S является подтипом типа T, если все значения, которые имеет тип S, являются также экземплярами типа T.   
  
 Кроме того, в соответствии с иерархией типов XML-схемы, все целочисленные значения являются также и десятичными. Но при этом не все десятичные значения являются целочисленными. Иными словами, целочисленное является подтипом десятичного, но не наоборот. Например, **+** Операция допускает только значения определенных типов, например числовые типы **xs: integer**, **xs: decimal**, **xs: float** и **xs: Double**. Если передаются значения других типов, например **xs: String**, операция вызывает ошибку типа. Это называется строгой типизацией. Значения других типов, например атомарного типа, применяемого для обозначения нетипизированного XML, могут быть неявно преобразованы в значение типа, поддерживаемого для данной операции. Это называется слабой типизацией.  
  
 Если требуется неявное преобразование, статическая проверка типов гарантирует, что операции будут переданы только значения допустимых типов с верным количеством элементов. Для "String" + 1 он распознает, что статический тип "строка" является **xs: String**. Так как этот тип не является допустимым для **+** операции, возникает ошибка типа.  
  
 При сложении результатов произвольного выражения E1 и произвольного выражения E2 (E1 + E2) статический вывод типов сначала определяет статические типы E1 и E2, а затем сверяет их с типами, допустимыми для данной операции. Например, если статический тип E1 может быть либо **xs: String** , либо **xs: integer**, то проверка статического типа вызывает ошибку типа, даже если некоторые значения во время выполнения могут быть целыми числами. То же самое произойдет, если статический тип E1 **— xs: integer&#42;**. Так как **+** операция принимает только одно целочисленное значение и E1 может вернуть ноль или более 1, статическая проверка типа вызовет ошибку.  
  
 Как говорилось ранее, вывод типов часто определяет тип более свободно, чем известно о передаваемом типе данных пользователю. В таких случаях пользователь должен переписать запрос. Некоторые наиболее распространенные причины этого:  
  
-   Тип выводит более общий тип: супертип или объединение типов. Если тип является атомарным, для обозначения действительного статического типа необходимо применить выражение явного приведения или функцию конструктора. Например, если выводимый тип выражения E1 является выбором между **xs: String** или **xs: integer** , а сложение требует **xs: integer**, следует написать `xs:integer(E1) + E2` вместо `E1+E2` . Это выражение может завершиться ошибкой во время выполнения, если обнаружено строковое значение, которое не может быть приведено к **типу xs: integer**. но зато теперь выражение будет проходить статическую проверку типов. Такое выражение сопоставляется с пустой последовательностью.  
  
-   Тип выводит количество элементов большее, чем в действительности содержат данные. Это происходит часто, поскольку тип данных **XML** может содержать более одного элемента верхнего уровня, и коллекция схем XML не может ограничивать это. Чтобы ограничить статический тип и гарантировать, что передается не более одного значения, следует применять позиционный предикат `[1]`. Например, чтобы добавить 1 к значению атрибута `c` элемента `b` под элементом верхнего уровня, необходимо выполнить `write (/a/b/@c)[1]+1`. Также ключевое слово DOCUMENT может использоваться с коллекцией XML-схем.  
  
-   Некоторые операции приводят к потере типа данных во время вывода. Например, если тип узла не может быть определен, он превращается в **anyType**. Это не неявное приведение типа к любому другому типу. Эти преобразования наиболее заметно появляются во время перемещения с помощью родительской оси. Если выражение приводит к ошибке статической типизации, избегайте таких операций и перепишите запрос.  
  
## <a name="type-checking-of-union-types"></a>Контроль типов объединенных типов   
 Работать с объединенными типами нужно особенно внимательно из-за проверки типов. Следующие примеры поясняют две из возможных проблем.  
  
### <a name="example-function-over-union-type"></a>Пример: функция над объединением типа  
 Рассмотрим определение элемента для <`r`> типа объединения:  
  
```  
<xs:element name="r">  
<xs:simpleType>  
   <xs:union memberTypes="xs:int xs:float xs:double"/>  
</xs:simpleType>  
</xs:element>  
```  
  
 В контексте XQuery функция "Average" `fn:avg (//r)` возвращает статическую ошибку, так как компилятор XQuery не может добавлять значения различных типов (**xs: int**, **xs: float** или **xs: Double**) для <`r`> элементов в аргументе **fn: AVG ()**. Чтобы решить эту проблему, перепишите вызов функции как `fn:avg(for $r in //r return $r cast as xs:double ?)`.  
  
### <a name="example-operator-over-union-type"></a>Пример: оператор над типом объединения  
 Оператор сложения ('+') требует использования точных типов операндов. В результате выражение `(//r)[1] + 1` возвращает статическую ошибку с ранее описанным определением типа элемента <`r`>. Единственное решение — переписать его как `(//r)[1] cast as xs:int? +1`, где «?» обозначает появление 0 или 1. В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] требуется указывать «cast as» с «?», так как любое приведение может вызвать пустую последовательность в результате ошибок во время выполнения.  
  
## <a name="see-also"></a>См. также:  
 [Справочник по языку XQuery (SQL Server)](../xquery/xquery-language-reference-sql-server.md)  
  
  
