---
title: Спецификация интерфейса виртуального устройства резервного копирования (VDI) — SQL Server на Linux
description: Сведения об интерфейсах, предоставляемых клиентским пакетом SDK для интерфейса виртуального устройства (VDI) SQL Server на Linux.
author: VanMSFT
ms.author: vanto
ms.reviewer: vanto
ms.date: 03/17/2017
ms.topic: conceptual
ms.prod: sql
ms.technology: linux
ms.assetid: 0250ba2b-8cdd-450e-9109-bf74f70e1247
ms.openlocfilehash: 8351bf128b2e53e51b49020588c8ff1ba44422a7
ms.sourcegitcommit: 610e3ebe21ac6575850a29641a32f275e71557e3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2020
ms.locfileid: "91784817"
---
# <a name="sql-server-on-linux-vdi-client-sdk-specification"></a>Спецификация клиентского пакета SDK для VDI SQL Server на Linux

[!INCLUDE [SQL Server - Linux](../includes/applies-to-version/sql-linux.md)]

В этом документе описываются интерфейсы, предоставляемые клиентским пакетом SDK для интерфейса виртуального устройства (VDI) SQL Server на Linux. Независимые поставщики программного обеспечения могут использовать API-интерфейс виртуального устройства резервного копирования для интеграции SQL Server в свои продукты. Как правило, VDI в Linux работает аналогично VDI в Windows, но со следующими отличиями:

- общая память Windows становится общей памятью POSIX;
- семафоры Windows становятся семафорами POSIX;
- типы Windows, такие как HRESULT и DWORD, меняются на целочисленные эквиваленты;
- COM-интерфейсы удалены и заменены парой классов C++;
- SQL Server на Linux не поддерживает именованные экземпляры, поэтому ссылки на имена экземпляров были удалены; 
- общая библиотека реализована в файле libsqlvdi.so, установленном по пути /opt/mssql/lib/libsqlvdi.so.

Этот документ является дополнением к файлу **vbackup.chm**, в котором подробно описана спецификация Microsoft SQL Server VDI в Windows. Скачайте [спецификацию SQL VDI в Windows](https://www.microsoft.com/download/details.aspx?id=17282).

Также ознакомьтесь с примером решения для резервного копирования VDI в [репозитории GitHub с образцами для SQL Server](https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/sqlvdi-linux).

## <a name="user-permissions-setup"></a>Настройка разрешений пользователя

В Linux примитивы POSIX принадлежат создающему их пользователю и группе по умолчанию. Объекты, созданные SQL Server, по умолчанию будут принадлежать пользователю mssql и группе mssql. Чтобы разрешить совместное использование на SQL Server и клиенте VDI, рекомендуется воспользоваться одним из следующих методов.

1. Запустите клиент VDI в качестве пользователя mssql.
   
   Выполните следующую команду, чтобы переключиться на пользователя mssql:
   
   ```bash
   sudo su mssql
   ```

2. Добавьте пользователя mssql в группу vdiuser, а vdiuser — в группу mssql.
   
   Выполните следующие команды:

   ```bash
   sudo useradd vdiuser
   sudo usermod -a -G mssql vdiuser
   sudo usermod -a -G vdiuser mssql
   ```

   Перезапустите сервер, чтобы выбрать новые группы для SQL Server и vdiuser.

## <a name="client-functions"></a>Функции клиента

В этой главе содержатся описания функций клиента. В описаниях приводятся следующие сведения:

- Назначение функции
- Синтаксис функции
- Список параметров
- Возвращаемые значения
- Remarks

## <a name="clientvirtualdevicesetcreate"></a>ClientVirtualDeviceSet::Create

**Назначение.** Эта функция создает набор виртуальных устройств.

**Синтаксис**
   ```
   int ClientVirtualDeviceSet::Create (
   char *   name,       // name for the set
   VDConfig   * cfg     // configuration for the set
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| | **name** | Определяет набор виртуальных устройств. Необходимо следовать правилам для имен, используемых в CreateFileMapping(). Можно использовать любой символ, кроме обратной косой черты (\)). Это символьная строка. К строке рекомендуется добавить префикс в виде названия продукта или компании пользователя и имени базы данных. |
| |**cfg** | Это конфигурация для набора виртуальных устройств. Дополнительные сведения см. в разделе "Конфигурация" далее в этом документе.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** | Функция выполнена успешно. |
| |**VD_E_NOTSUPPORTED** |Одно или несколько полей в конфигурации недопустимы или не поддерживаются. |
| |**VD_E_PROTOCOL** | Набор виртуальных устройств уже существует.

**Примечание.** Метод Create следует вызывать только один раз для каждой операции резервного копирования или восстановления. После вызова метода Close клиент может повторно использовать интерфейс для создания другого набора виртуальных устройств.

## <a name="clientvirtualdevicesetgetconfiguration"></a>ClientVirtualDeviceSet::GetConfiguration

**Назначение.** Эта функция используется для ожидания настройки набора виртуальных устройств сервером.
**Синтаксис**
   ```
   int ClientVirtualDeviceSet::GetConfiguration (
   time_t       timeout,    // in milliseconds
   VDConfig *       cfg // selected configuration
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| | **timeout** | Это время ожидания в миллисекундах. Чтобы избежать времени ожидания, используйте INFINITE или любое отрицательное целое число.
| | **cfg** | После успешного выполнения содержит конфигурацию, выбранную сервером. Дополнительные сведения см. в разделе "Конфигурация" далее в этом документе.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** | Конфигурация возвращена.
| |**VD_E_ABORT** |Вызван SignalAbort.
| |**VD_E_TIMEOUT** |Время ожидания функции истекло.

**Примечание.** Эта функция блокируется в состоянии ожидания оповещения. После успешного вызова можно открыть устройства в наборе виртуальных устройств.


## <a name="clientvirtualdevicesetopendevice"></a>ClientVirtualDeviceSet::OpenDevice
**Назначение.** Эта функция открывает одно из устройств в наборе виртуальных устройств.
**Синтаксис**
   ```
   int ClientVirtualDeviceSet::OpenDevice (
   char *           name,       // name for the set
   ClientVirtualDevice **       ppVirtualDevice // returns interface to device
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| | **name** |Определяет набор виртуальных устройств.
| | **ppVirtualDevice** |После успешного выполнения функции возвращается указатель на виртуальное устройство. Это устройство используется для команд GetCommand и CompleteCommand.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Функция выполнена успешно.
| |**VD_E_ABORT** | Запрошено прерывание.
| |**VD_E_OPEN** |  Все устройства открыты.
| |**VD_E_PROTOCOL** |  Набор не находится в состоянии инициализации, либо это конкретное устройство уже открыто.
| |**VD_E_INVALID** |Недопустимое имя устройства. Это имя не используется в наборе.

**Примечание.** Может быть возвращен VD_E_OPEN. Клиент может многократно вызывать OpenDevice, пока не будет возвращен этот код.
Если настроено несколько устройств, например *n*, набор виртуальных устройств вернет *n* уникальных интерфейсов устройств.

Функцию `GetConfiguration` можно использовать для ожидания открытия устройств.
Если эта функция завершается ошибкой, аргумент ppVirtualDevice возвращает значение NULL.
 
## <a name="clientvirtualdevicegetcommand"></a>ClientVirtualDevice::GetCommand

**Назначение.** Эта функция используется для получения следующей команды в очереди на устройстве. При запросе эта функция ожидает следующую команду.

**Синтаксис**
   ```
   int ClientVirtualDevice::GetCommand (
   time_t       timeout,    // time-out in milliseconds
   VDC_Command**    ppCmd   // returns the next command
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**timeout** |Это время ожидания (в миллисекундах). Используйте INFINTE для бесконечного ожидания. Используйте 0, чтобы запросить команду. Если команда в данный момент недоступна, возвращается VD_E_TIMEOUT. Если наступает время ожидания, клиент принимает решение о следующем действии.
| |**Timeout** |Это время ожидания (в миллисекундах). Используйте INFINTE или отрицательное значение для бесконечного ожидания. Используйте 0, чтобы запросить команду. Если до истечения времени ожидания доступных команд нет, возвращается VD_E_TIMEOUT. Если наступает время ожидания, клиент принимает решение о следующем действии.
| |**ppCmd** |При успешном возвращении команды параметр возвращает адрес выполняемой команды. Возвращенная память доступна только для чтения. После выполнения команды этот указатель передается в подпрограмму CompleteCommand. Дополнительные сведения о каждой команде см. в разделе "Команды" далее в этом документе.
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Команда получена.
| |**VD_E_CLOSE** |Устройство было закрыто сервером.
| |**VD_E_TIMEOUT** |Доступных команд не было. Время ожидания истекло.
| |**VD_E_ABORT** |Клиент или сервер использовал SignalAbort для принудительного завершения работы.

**Примечание.** Если возвращается VD_E_CLOSE, значит, SQL Server закрыл устройство. Это часть нормального завершения работы. После закрытия всех устройств клиент вызывает функцию ClientVirtualDeviceSet::Close, чтобы закрыть набор виртуальных устройств.
Если эта подпрограмма должна блокироваться для ожидания команды, поток остается в состоянии ожидания оповещения.

## <a name="clientvirtualdevicecompletecommand"></a>ClientVirtualDevice::CompleteCommand

**Назначение** Эта функция используется для уведомления SQL Server о завершении команды. Должны возвращаться сведения о завершении, соответствующие команде. Дополнительные сведения см. в разделе "Команды" далее в этом документе.

**Синтаксис** 

   ```
   int ClientVirtualDevice::CompleteCommand (
   VDC_Command pCmd,        // the command
   int  completionCode,     // completion code
   unsigned long    bytesTransferred,   // bytes transferred
   int64_t  position        // current position
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**pCmd** |Это адрес команды, ранее возвращенной функцией ClientVirtualDevice::GetCommand.
| |**completionCode** |Это код состояния, указывающий состояние завершения. Этот параметр должен возвращаться для всех команд. Возвращаемый код должен соответствовать выполняемой команде. ERROR_SUCCESS используется во всех случаях для обозначения успешно выполненной команды. Полный список возможных кодов см. в файле vdierror.h. Список стандартных кодов состояния для каждой команды см. в разделе "Команды" далее в этом документе.
| |**bytesTransferred** |Количество успешно переданных байт. Возвращается только для команд чтения и записи при передаче данных.
| |**position** |Это ответ только на команду GetPosition.
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Завершение отмечено правильно.
| |**VD_E_INVALID** |pCmd не была активной командой.
| |**VD_E_ABORT** |Получена команда о прерывании.
| |**VD_E_PROTOCOL** |Устройство не открыто.

**Примечание.** Нет

## <a name="clientvirtualdevicesetsignalabort"></a>ClientVirtualDeviceSet::SignalAbort

**Назначение.** Эта функция используется для предупреждения об аварийном завершении.

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::SignalAbort ();
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |None | Неприменимо
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR**|Уведомление о прерывании успешно создано.

**Примечание.** Клиент может прервать операцию резервного копирования или восстановления в любое время. Эта подпрограмма оповещает о необходимости прекращения всех операций. Весь набор виртуальных устройств переходит в состояние аварийного завершения. На устройства не возвращаются никакие дополнительные команды. Все незавершенные команды завершаются автоматически, возвращая ERROR_OPERATION_ABORTED в качестве кода завершения. После безопасного завершения всех необработанных операций использования буферов клиент должен вызвать ClientVirtualDeviceSet::Close. Дополнительные сведения см. в разделе "Аварийное завершение" ранее в этом документе.

## <a name="clientvirtualdevicesetclose"></a>ClientVirtualDeviceSet::Close

**Назначение.** Эта функция закрывает набор виртуальных устройств, созданный с помощью ClientVirtualDeviceSet::Create. В результате высвобождаются все ресурсы, связанные с набором виртуальных устройств.

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::Close ();
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |None |Неприменимо
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Возвращается при успешном закрытии набора виртуальных устройств.
| |**VD_E_PROTOCOL** |Действия не выполнялись, так как набор виртуальных устройств не открывался.
| |**VD_E_OPEN** |Устройства по-прежнему открыты.

**Примечание.** Вызов функции Close является объявлением клиента о необходимости высвобождения всех ресурсов, используемых набором виртуальных устройств. Клиент должен убедиться, что перед вызовом функции Close завершены все действия с использованием буферов данных и виртуальных устройств. Функция Close делает недействительными все интерфейсы виртуальных устройств, возвращенные OpenDevice.
После возвращения вызова функции Close клиент может вызвать функцию Create для интерфейса набора виртуальных устройств. В этом случае создается новый набор виртуальных устройств для последующей операции резервного копирования или восстановления.
Если функция Close вызывается, когда открыты одно или несколько виртуальных устройств, возвращается VD_E_OPEN. В этом случае инициируется SignalAbort, чтобы при возможности обеспечить правильное завершение работы. Высвобождаются ресурсы VDI. Перед вызовом функции ClientVirtualDeviceSet::Close клиент должен дождаться указания VD_E_CLOSE на каждом устройстве. Если клиент знает, что набор виртуальных устройств уже находится в состоянии аварийного завершения, он не должен ждать указания VD_E_CLOSE от команды GetCommand и может вызвать функцию ClientVirtualDeviceSet::Close сразу же после завершения действия в общих буферах.
Дополнительные сведения см. в разделе "Аварийное завершение" ранее в этом документе.

## <a name="clientvirtualdevicesetopeninsecondary"></a>ClientVirtualDeviceSet::OpenInSecondary

**Назначение.** Эта функция открывает набор виртуальных устройств на дополнительном клиенте. Основной клиент уже должен был использовать функции Create и GetConfiguration для настройки набора виртуальных устройств.

**Синтаксис** 
   
   ```
   int ClientVirtualDeviceSet::OpenInSecondary (
   char *   setName         // name of the set
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**setName** |Определяет набор. Это имя зависит от регистра и должно совпадать с именем, используемым основным клиентом при вызове функции ClientVirtualDeviceSet::Create.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Функция выполнена успешно.
| |**VD_E_PROTOCOL** |Набор виртуальных устройств не создан, уже открыт на этом клиенте, или набор виртуальных устройств не готов принимать открытые запросы с дополнительных клиентов.
| |**VD_E_ABORT** |Операция прерывается.

**Примечание.** При использовании модели с несколькими процессами первичный клиент несет ответственность за обнаружение нормального и аномального завершения работы вторичных клиентов.

## <a name="clientvirtualdevicesetgetbufferhandle"></a>ClientVirtualDeviceSet::GetBufferHandle

**Назначение.** Для работы с буферами, возвращаемыми функцией ClientVirtualDevice::GetCommand, некоторым приложениям может требоваться несколько процессов. В таких случаях процесс, который получает команду, может использовать GetBufferHandle для получения независимого от процесса дескриптора, определяющего буфер. Затем этот дескриптор можно передать в любой другой процесс, где открыт тот же набор виртуальных устройств. Этот процесс будет использовать функцию ClientVirtualDeviceSet::MapBufferHandle для получения адреса буфера. Скорее всего, адрес будет отличаться от адреса в партнерском процессе, так как каждый процесс может сопоставлять буферы по разным адресам.

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::GetBufferHandle (
   uint8_t*     pBuffer,        // in: buffer address
   unsigned int*        pBufferHandle   // out: buffer handle
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**pBuffer** |Это адрес буфера, полученный в результате выполнения команды чтения или записи.
| |**BufferHandle** |Возвращается уникальный идентификатор буфера.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Функция выполнена успешно.
| |**VD_E_PROTOCOL** |Набор виртуальных устройств в настоящее время не открыт.
| |**VD_E_INVALID** |pBuffer не является допустимым адресом.

Примечание. Процесс, вызывающий функцию GetBufferHandle, отвечает за вызов ClientVirtualDevice::CompleteCommand по завершении передачи данных.

## <a name="clientvirtualdevicesetmapbufferhandle"></a>ClientVirtualDeviceSet::MapBufferHandle

**Назначение.** Эта функция используется для получения допустимого адреса буфера из дескриптора буфера, полученного из другого процесса. 

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::MapBufferHandle (
   i        nt  dwBuffer,   // in: buffer handle
   uint8_t**    ppBuffer        // out: buffer address
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**dwBuffer** |Это дескриптор, возвращаемый функцией ClientVirtualDeviceSet::GetBufferHandle.
| |**ppBuffer** |Это адрес буфера, допустимый в текущем процессе.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**NOERROR** |Функция выполнена успешно.
| |**VD_E_PROTOCOL** |Набор виртуальных устройств в настоящее время не открыт.
| |**VD_E_INVALID** |ppBuffer является недопустимым дескриптором.

**Примечание.** Необходимо правильно передавать данные о дескрипторах. Дескрипторы являются локальными по отношению к одному набору виртуальных устройств. Партнерские процессы с общим дескриптором должны гарантировать использование дескрипторов буферов только в пределах набора виртуальных устройств, из которого буфер был получен изначально.


